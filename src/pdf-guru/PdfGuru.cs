using System;
using System;
using System.Collections.Generic;
using System.Text;
using System;
using System;
using System;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Globalization;
using System.Drawing;
using GdiFontFamily = System.Drawing.FontFamily;
using System;
using System.Diagnostics;
using System.Drawing;
using GdiFont = System.Drawing.Font;
using GdiFontStyle = System.Drawing.FontStyle;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System;
using System.Collections.Generic;
using System;
using System;
using System.Diagnostics;
using System.IO;
using System;
using System.Diagnostics;
using System.IO;
using System.Drawing.Imaging;
using System.Drawing;
using System;
using System.Diagnostics;
using System.Globalization;
using System.ComponentModel;
using System;
using System.Globalization;
using System.ComponentModel;
using System.Threading;
using System;
using System.Diagnostics;
using System.Globalization;
using System.ComponentModel;
using System.Drawing;
using GdiFontFamily = System.Drawing.FontFamily;
using GdiFont = System.Drawing.Font;
using GdiFontStyle = System.Drawing.FontStyle;
using System;
using GdiFont = System.Drawing.Font;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using GdiFont = System.Drawing.Font;
using System;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System.Globalization;
using GdiFont = System.Drawing.Font;
using GdiFontStyle = System.Drawing.FontStyle;
using System;
using System.Diagnostics;
using System;
using System;
using System.Diagnostics;
using System.IO;
using System.Drawing;
using System;
using System;
using System.ComponentModel;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices
using System;
using System.IO;
using System;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System;
using System.Collections.Generic;
using System.IO;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System;
using System;
using System;
using System.Diagnostics;
using System.Globalization;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System;
using System.ComponentModel;
using System;
using System;
using System;
using System;
using System;
using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.IO;
using System;
using System;
using System;
using System;
using System.Collections.Generic;
using System;
using System;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Collections.Generic;
using System.Text;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System;
using System.Collections.Generic;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Text;
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System;
using System;
using System.Diagnostics;
using GdiFont = System.Drawing.Font;
using GdiFontStyle = System.Drawing.FontStyle;
using System.Drawing;
using GdiFont = System.Drawing.Font;
using System;
using System.Collections.Generic;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Text;
using System;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System.Text;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System.Text;
using Fixed = System.Int32;
using FWord = System.Int16;
using UFWord = System.UInt16;
using System.Diagnostics;
using System.IO;
using System.Diagnostics;
using System;
using System;
using System;
using System.Globalization;
using System;
using System.Diagnostics;
using System;
using System.Runtime.InteropServices;
using System;
using System.Threading;
using System;
using System.Runtime.InteropServices;
using System;
using System.Globalization;
using System;
using System;
using System;
using System;
using System;
using System;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Text;
using System.Diagnostics;
using System.Diagnostics;
using System;
using System;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Text;
using System;
using System.Diagnostics;
using System.IO;
using System;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Diagnostics;
using System.Globalization;
using System;
using System;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System.Globalization;
using System;
using System.Diagnostics;
using System.Globalization;
using System;
using System.Collections.Generic;
using System.Collections;
using System;
using System.Diagnostics;
using System.Globalization;
using System.ComponentModel;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.Globalization;
using System;
using System.Diagnostics;
using System.Globalization;
using System;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Diagnostics;
using System.Text;
using System.Diagnostics;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Diagnostics;
using System.Globalization;
using System.Diagnostics;
using System;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System;
using System;
using System;











namespace pdf_guru
{
    internal enum PathStart
    {
        MoveTo1st,

        LineTo1st,

        Ignore1st,
    }
    public enum XColorSpace
    {
        Rgb,

        Cmyk,

        GrayScale,
    }
    public enum XCombineMode
    {
        Replace = 0,

        Intersect = 1,

        Union = 2,

        Xor = 3,

        Exclude = 4,

        Complement = 5,
    }
    public enum XDashStyle
    {
        Solid = 0,

        Dash = 1,

        Dot = 2,

        DashDot = 3,

        DashDotDot = 4,

        Custom = 5,
    }
    public enum XFillMode
    {
        Alternate = 0,

        Winding = 1,
    }
    public enum XFontStyle
    {
        Regular = XGdiFontStyle.Regular,

        Bold = XGdiFontStyle.Bold,

        Italic = XGdiFontStyle.Italic,

        BoldItalic = XGdiFontStyle.BoldItalic,

        Underline = XGdiFontStyle.Underline,

        Strikeout = XGdiFontStyle.Strikeout,

    }
    internal enum XGdiFontStyle
    {
        Regular = 0,

        Bold = 1,

        Italic = 2,

        BoldItalic = 3,

        Underline = 4,

        Strikeout = 8,
    }
    enum XGraphicTargetContext
    {
        NONE = 0,

        CORE = 1,

        GDI = 2,

        WPF = 3,

        UWP = 10,
    }
    internal enum XGraphicsPathItemType
    {
        Lines,
        Beziers,
        Curve,
        Arc,
        Rectangle,
        RoundedRectangle,
        Ellipse,
        Polygon,
        CloseFigure,
        StartFigure,
    }
    public enum XGraphicsPdfPageOptions
    {
        Append,

        Prepend,

        Replace,
    }
    public enum XGraphicsUnit
    {
        Point = 0,

        Inch = 1,

        Millimeter = 2,

        Centimeter = 3,

        Presentation = 4,
    }
    public enum XKnownColor
    {
        AliceBlue = 0,

        AntiqueWhite = 1,

        Aqua = 2,

        Aquamarine = 3,

        Azure = 4,

        Beige = 5,

        Bisque = 6,

        Black = 7,

        BlanchedAlmond = 8,

        Blue = 9,

        BlueViolet = 10,

        Brown = 11,

        BurlyWood = 12,

        CadetBlue = 13,

        Chartreuse = 14,

        Chocolate = 15,

        Coral = 16,

        CornflowerBlue = 17,

        Cornsilk = 18,

        Crimson = 19,

        Cyan = 20,

        DarkBlue = 21,

        DarkCyan = 22,

        DarkGoldenrod = 23,

        DarkGray = 24,

        DarkGreen = 25,

        DarkKhaki = 26,

        DarkMagenta = 27,

        DarkOliveGreen = 28,

        DarkOrange = 29,

        DarkOrchid = 30,

        DarkRed = 31,

        DarkSalmon = 32,

        DarkSeaGreen = 33,

        DarkSlateBlue = 34,

        DarkSlateGray = 35,

        DarkTurquoise = 36,

        DarkViolet = 37,

        DeepPink = 38,

        DeepSkyBlue = 39,

        DimGray = 40,

        DodgerBlue = 41,

        Firebrick = 42,

        FloralWhite = 43,

        ForestGreen = 44,

        Fuchsia = 45,

        Gainsboro = 46,

        GhostWhite = 47,

        Gold = 48,

        Goldenrod = 49,

        Gray = 50,

        Green = 51,

        GreenYellow = 52,

        Honeydew = 53,

        HotPink = 54,

        IndianRed = 55,

        Indigo = 56,

        Ivory = 57,

        Khaki = 58,

        Lavender = 59,

        LavenderBlush = 60,

        LawnGreen = 61,

        LemonChiffon = 62,

        LightBlue = 63,

        LightCoral = 64,

        LightCyan = 65,

        LightGoldenrodYellow = 66,

        LightGray = 67,

        LightGreen = 68,

        LightPink = 69,

        LightSalmon = 70,

        LightSeaGreen = 71,

        LightSkyBlue = 72,

        LightSlateGray = 73,

        LightSteelBlue = 74,

        LightYellow = 75,

        Lime = 76,

        LimeGreen = 77,

        Linen = 78,

        Magenta = 79,

        Maroon = 80,

        MediumAquamarine = 81,

        MediumBlue = 82,

        MediumOrchid = 83,

        MediumPurple = 84,

        MediumSeaGreen = 85,

        MediumSlateBlue = 86,

        MediumSpringGreen = 87,

        MediumTurquoise = 88,

        MediumVioletRed = 89,

        MidnightBlue = 90,

        MintCream = 91,

        MistyRose = 92,

        Moccasin = 93,

        NavajoWhite = 94,

        Navy = 95,

        OldLace = 96,

        Olive = 97,

        OliveDrab = 98,

        Orange = 99,

        OrangeRed = 100,

        Orchid = 101,

        PaleGoldenrod = 102,

        PaleGreen = 103,

        PaleTurquoise = 104,

        PaleVioletRed = 105,

        PapayaWhip = 106,

        PeachPuff = 107,

        Peru = 108,

        Pink = 109,

        Plum = 110,

        PowderBlue = 111,

        Purple = 112,

        Red = 113,

        RosyBrown = 114,

        RoyalBlue = 115,

        SaddleBrown = 116,

        Salmon = 117,

        SandyBrown = 118,

        SeaGreen = 119,

        SeaShell = 120,

        Sienna = 121,

        Silver = 122,

        SkyBlue = 123,

        SlateBlue = 124,

        SlateGray = 125,

        Snow = 126,

        SpringGreen = 127,

        SteelBlue = 128,

        Tan = 129,

        Teal = 130,

        Thistle = 131,

        Tomato = 132,

        Transparent = 133,

        Turquoise = 134,

        Violet = 135,

        Wheat = 136,

        White = 137,

        WhiteSmoke = 138,

        Yellow = 139,

        YellowGreen = 140,
    }
    public enum XLineAlignment
    {
        Near = 0,

        Center = 1,

        Far = 2,

        BaseLine = 3,
    }
    public enum XLinearGradientMode
    {
        Horizontal = 0,

        Vertical = 1,

        ForwardDiagonal = 2,

        BackwardDiagonal = 3,
    }
    public enum XLineCap
    {
        Flat = 0,

        Round = 1,

        Square = 2
    }
    public enum XLineJoin
    {
        Miter = 0,

        Round = 1,

        Bevel = 2,
    }
    public enum XMatrixOrder
    {
        Prepend = 0,

        Append = 1,
    }
    public enum XPageDirection
    {
        Downwards = 0,

        [Obsolete("Not implemeted - yagni")]
        Upwards = 1,
    }
    public enum XSmoothingMode
    {
        Invalid = -1,

        Default = 0,

        HighSpeed = 1,

        HighQuality = 2,

        None = 3,

        AntiAlias = 4,
    }
    public enum XStringAlignment
    {
        Near = 0,

        Center = 1,

        Far = 2,
    }
    public enum XStyleSimulations
    {
        None = 0,

        BoldSimulation = 1,

        ItalicSimulation = 2,

        BoldItalicSimulation = ItalicSimulation | BoldSimulation,
    }
    public enum XSweepDirection
    {
        Counterclockwise = 0,

        Clockwise = 1,
    }
    internal class CoreGraphicsPath
    {
        const byte PathPointTypeStart = 0;
        const byte PathPointTypeLine = 1;
        const byte PathPointTypeBezier = 3;
        const byte PathPointTypePathTypeMask = 0x07;
        const byte PathPointTypeCloseSubpath = 0x80;

        public CoreGraphicsPath()
        { }

        public CoreGraphicsPath(CoreGraphicsPath path)
        {
            _points = new List<XPoint>(path._points);
            _types = new List<byte>(path._types);
        }

        public void MoveOrLineTo(double x, double y)
        {
            if (_types.Count == 0 || (_types[_types.Count - 1] & PathPointTypeCloseSubpath) == PathPointTypeCloseSubpath)
                MoveTo(x, y);
            else
                LineTo(x, y, false);
        }

        public void MoveTo(double x, double y)
        {
            _points.Add(new XPoint(x, y));
            _types.Add(PathPointTypeStart);
        }

        public void LineTo(double x, double y, bool closeSubpath)
        {
            if (_points.Count > 0 && _points[_points.Count - 1].Equals(new XPoint(x, y)))
                return;

            _points.Add(new XPoint(x, y));
            _types.Add((byte)(PathPointTypeLine | (closeSubpath ? PathPointTypeCloseSubpath : 0)));
        }

        public void BezierTo(double x1, double y1, double x2, double y2, double x3, double y3, bool closeSubpath)
        {
            _points.Add(new XPoint(x1, y1));
            _types.Add(PathPointTypeBezier);
            _points.Add(new XPoint(x2, y2));
            _types.Add(PathPointTypeBezier);
            _points.Add(new XPoint(x3, y3));
            _types.Add((byte)(PathPointTypeBezier | (closeSubpath ? PathPointTypeCloseSubpath : 0)));
        }

        public void QuadrantArcTo(double x, double y, double width, double height, int quadrant, bool clockwise)
        {
            if (width < 0)
                throw new ArgumentOutOfRangeException("width");
            if (height < 0)
                throw new ArgumentOutOfRangeException("height");

            double w = Const.κ * width;
            double h = Const.κ * height;
            double x1, y1, x2, y2, x3, y3;
            switch (quadrant)
            {
                case 1:
                    if (clockwise)
                    {
                        x1 = x + w;
                        y1 = y - height;
                        x2 = x + width;
                        y2 = y - h;
                        x3 = x + width;
                        y3 = y;
                    }
                    else
                    {
                        x1 = x + width;
                        y1 = y - h;
                        x2 = x + w;
                        y2 = y - height;
                        x3 = x;
                        y3 = y - height;
                    }
                    break;

                case 2:
                    if (clockwise)
                    {
                        x1 = x - width;
                        y1 = y - h;
                        x2 = x - w;
                        y2 = y - height;
                        x3 = x;
                        y3 = y - height;
                    }
                    else
                    {
                        x1 = x - w;
                        y1 = y - height;
                        x2 = x - width;
                        y2 = y - h;
                        x3 = x - width;
                        y3 = y;
                    }
                    break;

                case 3:
                    if (clockwise)
                    {
                        x1 = x - w;
                        y1 = y + height;
                        x2 = x - width;
                        y2 = y + h;
                        x3 = x - width;
                        y3 = y;
                    }
                    else
                    {
                        x1 = x - width;
                        y1 = y + h;
                        x2 = x - w;
                        y2 = y + height;
                        x3 = x;
                        y3 = y + height;
                    }
                    break;

                case 4:
                    if (clockwise)
                    {
                        x1 = x + width;
                        y1 = y + h;
                        x2 = x + w;
                        y2 = y + height;
                        x3 = x;
                        y3 = y + height;
                    }
                    else
                    {
                        x1 = x + w;
                        y1 = y + height;
                        x2 = x + width;
                        y2 = y + h;
                        x3 = x + width;
                        y3 = y;
                    }
                    break;

                default:
                    throw new ArgumentOutOfRangeException("quadrant");
            }
            BezierTo(x1, y1, x2, y2, x3, y3, false);
        }

        public void CloseSubpath()
        {
            int count = _types.Count;
            if (count > 0)
                _types[count - 1] |= PathPointTypeCloseSubpath;
        }

        XFillMode FillMode
        {
            get { return _fillMode; }
            set { _fillMode = value; }
        }
        XFillMode _fillMode;

        public void AddArc(double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
            XMatrix matrix = XMatrix.Identity;
            List<XPoint> points = GeometryHelper.BezierCurveFromArc(x, y, width, height, startAngle, sweepAngle, PathStart.MoveTo1st, ref matrix);
            int count = points.Count;
            Debug.Assert((count + 2) % 3 == 0);

            MoveOrLineTo(points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx += 3)
                BezierTo(points[idx].X, points[idx].Y, points[idx + 1].X, points[idx + 1].Y, points[idx + 2].X, points[idx + 2].Y, false);
        }

        public void AddArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArg, XSweepDirection sweepDirection)
        {
            List<XPoint> points = GeometryHelper.BezierCurveFromArc(point1, point2, size, rotationAngle, isLargeArg,
                sweepDirection == XSweepDirection.Clockwise, PathStart.MoveTo1st);
            int count = points.Count;
            Debug.Assert((count + 2) % 3 == 0);

            MoveOrLineTo(points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx += 3)
                BezierTo(points[idx].X, points[idx].Y, points[idx + 1].X, points[idx + 1].Y, points[idx + 2].X, points[idx + 2].Y, false);
        }

        public void AddCurve(XPoint[] points, double tension)
        {
            int count = points.Length;
            if (count < 2)
                throw new ArgumentException("AddCurve requires two or more points.", "points");

            tension /= 3;
            MoveOrLineTo(points[0].X, points[0].Y);
            if (count == 2)
            {
                ToCurveSegment(points[0], points[0], points[1], points[1], tension);
            }
            else
            {
                ToCurveSegment(points[0], points[0], points[1], points[2], tension);
                for (int idx = 1; idx < count - 2; idx++)
                {
                    ToCurveSegment(points[idx - 1], points[idx], points[idx + 1], points[idx + 2], tension);
                }
                ToCurveSegment(points[count - 3], points[count - 2], points[count - 1], points[count - 1], tension);
            }
        }

        void ToCurveSegment(XPoint pt0, XPoint pt1, XPoint pt2, XPoint pt3, double tension3)
        {
            BezierTo(
                pt1.X + tension3 * (pt2.X - pt0.X), pt1.Y + tension3 * (pt2.Y - pt0.Y),
                pt2.X - tension3 * (pt3.X - pt1.X), pt2.Y - tension3 * (pt3.Y - pt1.Y),
                pt2.X, pt2.Y,
                false);
        }

        public XPoint[] PathPoints { get { return _points.ToArray(); } }

        public byte[] PathTypes { get { return _types.ToArray(); } }

        readonly List<XPoint> _points = new List<XPoint>();
        readonly List<byte> _types = new List<byte>();
    }
    internal sealed class FontFamilyCache
    {
        FontFamilyCache()
        {
            _familiesByName = new Dictionary<string, FontFamilyInternal>(StringComparer.OrdinalIgnoreCase);
        }

        public static FontFamilyInternal GetFamilyByName(string familyName)
        {
            try
            {
                Lock.EnterFontFactory();
                FontFamilyInternal family;
                Singleton._familiesByName.TryGetValue(familyName, out family);
                return family;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static FontFamilyInternal CacheOrGetFontFamily(FontFamilyInternal fontFamily)
        {
            try
            {
                Lock.EnterFontFactory();
                FontFamilyInternal existingFontFamily;
                if (Singleton._familiesByName.TryGetValue(fontFamily.Name, out existingFontFamily))
                {

                    return existingFontFamily;
                }
                Singleton._familiesByName.Add(fontFamily.Name, fontFamily);
                return fontFamily;
            }
            finally { Lock.ExitFontFactory(); }
        }

        static FontFamilyCache Singleton
        {
            get
            {
                if (_singleton == null)
                {
                    try
                    {
                        Lock.EnterFontFactory();
                        if (_singleton == null)
                            _singleton = new FontFamilyCache();
                    }
                    finally { Lock.ExitFontFactory(); }
                }
                return _singleton;
            }
        }
        static volatile FontFamilyCache _singleton;

        internal static string GetCacheState()
        {
            StringBuilder state = new StringBuilder();
            state.Append("====================\n");
            state.Append("Font families by name\n");
            Dictionary<string, FontFamilyInternal>.KeyCollection familyKeys = Singleton._familiesByName.Keys;
            int count = familyKeys.Count;
            string[] keys = new string[count];
            familyKeys.CopyTo(keys, 0);
            Array.Sort(keys, StringComparer.OrdinalIgnoreCase);
            foreach (string key in keys)
                state.AppendFormat("  {0}: {1}\n", key, Singleton._familiesByName[key].DebuggerDisplay);
            state.Append("\n");
            return state.ToString();
        }

        readonly Dictionary<string, FontFamilyInternal> _familiesByName;
    }
    internal class FontFamilyInternal
    {
        FontFamilyInternal(string familyName, bool createPlatformObjects)
        {
            _sourceName = _name = familyName;

            if (createPlatformObjects)
            {
                _gdiFontFamily = new GdiFontFamily(familyName);
                _name = _gdiFontFamily.Name;
            }

        }

#if CORE || GDI
        FontFamilyInternal(GdiFontFamily gdiFontFamily)
        {
            _sourceName = _name = gdiFontFamily.Name;
            _gdiFontFamily = gdiFontFamily;
        }
#endif


        internal static FontFamilyInternal GetOrCreateFromName(string familyName, bool createPlatformObject)
        {
            try
            {
                Lock.EnterFontFactory();
                FontFamilyInternal family = FontFamilyCache.GetFamilyByName(familyName);
                if (family == null)
                {
                    family = new FontFamilyInternal(familyName, createPlatformObject);
                    family = FontFamilyCache.CacheOrGetFontFamily(family);
                }
                return family;
            }
            finally { Lock.ExitFontFactory(); }
        }

#if CORE || GDI
        internal static FontFamilyInternal GetOrCreateFromGdi(GdiFontFamily gdiFontFamily)
        {
            try
            {
                Lock.EnterFontFactory();
                FontFamilyInternal fontFamily = new FontFamilyInternal(gdiFontFamily);
                fontFamily = FontFamilyCache.CacheOrGetFontFamily(fontFamily);
                return fontFamily;
            }
            finally { Lock.ExitFontFactory(); }
        }
#endif

        public string SourceName
        {
            get { return _sourceName; }
        }
        readonly string _sourceName;

        public string Name
        {
            get { return _name; }
        }
        readonly string _name;

#if CORE || GDI
        public GdiFontFamily GdiFamily
        {
            get { return _gdiFontFamily; }
        }
        readonly GdiFontFamily _gdiFontFamily;
#endif


        internal string DebuggerDisplay
        {
            get { return string.Format(CultureInfo.InvariantCulture, "FontFamily: '{0}'", Name); }
        }
    }
    static class FontHelper
    {
        public static XSize MeasureString(string text, XFont font, XStringFormat stringFormat_notyetused)
        {
            XSize size = new XSize();

            OpenTypeDescriptor descriptor = FontDescriptorCache.GetOrCreateDescriptorFor(font) as OpenTypeDescriptor;
            if (descriptor != null)
            {
                size.Height = (descriptor.Ascender + descriptor.Descender) * font.Size / font.UnitsPerEm;
                Debug.Assert(descriptor.Ascender > 0);

                bool symbol = descriptor.FontFace.cmap.symbol;
                int length = text.Length;
                int width = 0;
                for (int idx = 0; idx < length; idx++)
                {
                    char ch = text[idx];
                    if (ch < 32)
                        continue;

                    if (symbol)
                    {
                        ch = (char)(ch | (descriptor.FontFace.os2.usFirstCharIndex & 0xFF00));
                    }
                    int glyphIndex = descriptor.CharCodeToGlyphIndex(ch);
                    width += descriptor.GlyphIndexToWidth(glyphIndex);
                }
                size.Width = width * font.Size / descriptor.UnitsPerEm;

                if ((font.GlyphTypeface.StyleSimulations & XStyleSimulations.BoldSimulation) == XStyleSimulations.BoldSimulation)
                {
                    size.Width += length * font.Size * Const.BoldEmphasis;
                }
            }
            Debug.Assert(descriptor != null, "No OpenTypeDescriptor.");
            return size;
        }

#if CORE || GDI
        public static GdiFont CreateFont(string familyName, double emSize, GdiFontStyle style, out XFontSource fontSource)
        {
            fontSource = null;
            GdiFont font;

            font = new GdiFont(familyName, (float)emSize, style, GraphicsUnit.World);
            return font;
        }
#endif


        public static ulong CalcChecksum(byte[] buffer)
        {
            if (buffer == null)
                throw new ArgumentNullException("buffer");

            const uint prime = 65521;
            uint s1 = 0;
            uint s2 = 0;
            int length = buffer.Length;
            int offset = 0;
            while (length > 0)
            {
                int n = 3800;
                if (n > length)
                    n = length;
                length -= n;
                while (--n >= 0)
                {
                    s1 += buffer[offset++];
                    s2 = s2 + s1;
                }
                s1 %= prime;
                s2 %= prime;
            }
            ulong ul1 = (ulong)s2 << 16;
            ul1 = ul1 | s1;
            ulong ul2 = (ulong)buffer.Length;
            return (ul1 << 32) | ul2;
        }

        public static XFontStyle CreateStyle(bool isBold, bool isItalic)
        {
            return (isBold ? XFontStyle.Bold : 0) | (isItalic ? XFontStyle.Italic : 0);
        }
    }
    static class GeometryHelper
    {


        public static List<XPoint> BezierCurveFromArc(double x, double y, double width, double height, double startAngle, double sweepAngle,
            PathStart pathStart, ref XMatrix matrix)
        {
            List<XPoint> points = new List<XPoint>();

            double α = startAngle;
            if (α < 0)
                α = α + (1 + Math.Floor((Math.Abs(α) / 360))) * 360;
            else if (α > 360)
                α = α - Math.Floor(α / 360) * 360;
            Debug.Assert(α >= 0 && α <= 360);

            double β = sweepAngle;
            if (β < -360)
                β = -360;
            else if (β > 360)
                β = 360;

            if (α == 0 && β < 0)
                α = 360;
            else if (α == 360 && β > 0)
                α = 0;

            bool smallAngle = Math.Abs(β) <= 90;

            β = α + β;
            if (β < 0)
                β = β + (1 + Math.Floor((Math.Abs(β) / 360))) * 360;

            bool clockwise = sweepAngle > 0;
            int startQuadrant = Quadrant(α, true, clockwise);
            int endQuadrant = Quadrant(β, false, clockwise);

            if (startQuadrant == endQuadrant && smallAngle)
                AppendPartialArcQuadrant(points, x, y, width, height, α, β, pathStart, matrix);
            else
            {
                int currentQuadrant = startQuadrant;
                bool firstLoop = true;
                do
                {
                    if (currentQuadrant == startQuadrant && firstLoop)
                    {
                        double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);
                        AppendPartialArcQuadrant(points, x, y, width, height, α, ξ, pathStart, matrix);
                    }
                    else if (currentQuadrant == endQuadrant)
                    {
                        double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);
                        AppendPartialArcQuadrant(points, x, y, width, height, ξ, β, PathStart.Ignore1st, matrix);
                    }
                    else
                    {
                        double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);
                        double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);
                        AppendPartialArcQuadrant(points, x, y, width, height, ξ1, ξ2, PathStart.Ignore1st, matrix);
                    }

                    if (currentQuadrant == endQuadrant && smallAngle)
                        break;
                    smallAngle = true;

                    if (clockwise)
                        currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;
                    else
                        currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;

                    firstLoop = false;
                } while (true);
            }
            return points;
        }

        static int Quadrant(double φ, bool start, bool clockwise)
        {
            Debug.Assert(φ >= 0);
            if (φ > 360)
                φ = φ - Math.Floor(φ / 360) * 360;

            int quadrant = (int)(φ / 90);
            if (quadrant * 90 == φ)
            {
                if ((start && !clockwise) || (!start && clockwise))
                    quadrant = quadrant == 0 ? 3 : quadrant - 1;
            }
            else
                quadrant = clockwise ? ((int)Math.Floor(φ / 90)) % 4 : (int)Math.Floor(φ / 90);
            return quadrant;
        }

        static void AppendPartialArcQuadrant(List<XPoint> points, double x, double y, double width, double height, double α, double β, PathStart pathStart, XMatrix matrix)
        {
            Debug.Assert(α >= 0 && α <= 360);
            Debug.Assert(β >= 0);
            if (β > 360)
                β = β - Math.Floor(β / 360) * 360;
            Debug.Assert(Math.Abs(α - β) <= 90);

            double δx = width / 2;
            double δy = height / 2;

            double x0 = x + δx;
            double y0 = y + δy;

            bool reflect = false;
            if (α >= 180 && β >= 180)
            {
                α -= 180;
                β -= 180;
                reflect = true;
            }

            double cosα, cosβ, sinα, sinβ;
            if (width == height)
            {
                α = α * Calc.Deg2Rad;
                β = β * Calc.Deg2Rad;
            }
            else
            {
                α = α * Calc.Deg2Rad;
                sinα = Math.Sin(α);
                if (Math.Abs(sinα) > 1E-10)
                    α = Math.PI / 2 - Math.Atan(δy * Math.Cos(α) / (δx * sinα));
                β = β * Calc.Deg2Rad;
                sinβ = Math.Sin(β);
                if (Math.Abs(sinβ) > 1E-10)
                    β = Math.PI / 2 - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));
            }

            double κ = 4 * (1 - Math.Cos((α - β) / 2)) / (3 * Math.Sin((β - α) / 2));
            sinα = Math.Sin(α);
            cosα = Math.Cos(α);
            sinβ = Math.Sin(β);
            cosβ = Math.Cos(β);

            if (!reflect)
            {
                switch (pathStart)
                {
                    case PathStart.MoveTo1st:
                        points.Add(matrix.Transform(new XPoint(x0 + δx * cosα, y0 + δy * sinα)));
                        break;

                    case PathStart.LineTo1st:
                        points.Add(matrix.Transform(new XPoint(x0 + δx * cosα, y0 + δy * sinα)));
                        break;

                    case PathStart.Ignore1st:
                        break;
                }
                points.Add(matrix.Transform(new XPoint(x0 + δx * (cosα - κ * sinα), y0 + δy * (sinα + κ * cosα))));
                points.Add(matrix.Transform(new XPoint(x0 + δx * (cosβ + κ * sinβ), y0 + δy * (sinβ - κ * cosβ))));
                points.Add(matrix.Transform(new XPoint(x0 + δx * cosβ, y0 + δy * sinβ)));
            }
            else
            {
                switch (pathStart)
                {
                    case PathStart.MoveTo1st:
                        points.Add(matrix.Transform(new XPoint(x0 - δx * cosα, y0 - δy * sinα)));
                        break;

                    case PathStart.LineTo1st:
                        points.Add(matrix.Transform(new XPoint(x0 - δx * cosα, y0 - δy * sinα)));
                        break;

                    case PathStart.Ignore1st:
                        break;
                }
                points.Add(matrix.Transform(new XPoint(x0 - δx * (cosα - κ * sinα), y0 - δy * (sinα + κ * cosα))));
                points.Add(matrix.Transform(new XPoint(x0 - δx * (cosβ + κ * sinβ), y0 - δy * (sinβ - κ * cosβ))));
                points.Add(matrix.Transform(new XPoint(x0 - δx * cosβ, y0 - δy * sinβ)));
            }
        }

        public static List<XPoint> BezierCurveFromArc(XPoint point1, XPoint point2, XSize size,
            double rotationAngle, bool isLargeArc, bool clockwise, PathStart pathStart)
        {
            double δx = size.Width;
            double δy = size.Height;
            Debug.Assert(δx * δy > 0);
            double factor = δy / δx;
            bool isCounterclockwise = !clockwise;

            XMatrix matrix = new XMatrix();
            matrix.RotateAppend(-rotationAngle);
            matrix.ScaleAppend(δy / δx, 1);
            XPoint pt1 = matrix.Transform(point1);
            XPoint pt2 = matrix.Transform(point2);

            XPoint midPoint = new XPoint((pt1.X + pt2.X) / 2, (pt1.Y + pt2.Y) / 2);
            XVector vect = pt2 - pt1;
            double halfChord = vect.Length / 2;

            XVector vectRotated;

            if (isLargeArc == isCounterclockwise)
                vectRotated = new XVector(-vect.Y, vect.X);
            else
                vectRotated = new XVector(vect.Y, -vect.X);

            vectRotated.Normalize();

            double centerDistance = Math.Sqrt(δy * δy - halfChord * halfChord);
            if (double.IsNaN(centerDistance))
                centerDistance = 0;

            XPoint center = midPoint + centerDistance * vectRotated;

            double α = Math.Atan2(pt1.Y - center.Y, pt1.X - center.X);
            double β = Math.Atan2(pt2.Y - center.Y, pt2.X - center.X);

            if (isLargeArc == (Math.Abs(β - α) < Math.PI))
            {
                if (α < β)
                    α += 2 * Math.PI;
                else
                    β += 2 * Math.PI;
            }

            matrix.Invert();
            double sweepAngle = β - α;

            return BezierCurveFromArc(center.X - δx * factor, center.Y - δy, 2 * δx * factor, 2 * δy,
              α / Calc.Deg2Rad, sweepAngle / Calc.Deg2Rad, pathStart, ref matrix);
        }
    }
    internal class GraphicsStateStack
    {
        public GraphicsStateStack(XGraphics gfx)
        {
            _current = new InternalGraphicsState(gfx);
        }

        public int Count
        {
            get { return _stack.Count; }
        }

        public void Push(InternalGraphicsState state)
        {
            _stack.Push(state);
            state.Pushed();
        }

        public int Restore(InternalGraphicsState state)
        {
            if (!_stack.Contains(state))
                throw new ArgumentException("State not on stack.", "state");
            if (state.Invalid)
                throw new ArgumentException("State already restored.", "state");

            int count = 1;
            InternalGraphicsState top = _stack.Pop();
            top.Popped();
            while (top != state)
            {
                count++;
                state.Invalid = true;
                top = _stack.Pop();
                top.Popped();
            }
            state.Invalid = true;
            return count;
        }

        public InternalGraphicsState Current
        {
            get
            {
                if (_stack.Count == 0)
                    return _current;
                return _stack.Peek();
            }
        }

        readonly InternalGraphicsState _current;

        readonly Stack<InternalGraphicsState> _stack = new Stack<InternalGraphicsState>();
    }
    internal class InternalGraphicsState
    {
        public InternalGraphicsState(XGraphics gfx)
        {
            _gfx = gfx;
        }

        public InternalGraphicsState(XGraphics gfx, XGraphicsState state)
        {
            _gfx = gfx;
            State = state;
            State.InternalState = this;
        }

        public InternalGraphicsState(XGraphics gfx, XGraphicsContainer container)
        {
            _gfx = gfx;
            container.InternalState = this;
        }

        public XMatrix Transform
        {
            get { return _transform; }
            set { _transform = value; }
        }
        XMatrix _transform;

        public void Pushed()
        {


        }

        public void Popped()
        {
            Invalid = true;



        }

        public bool Invalid;

        readonly XGraphics _gfx;

        internal XGraphicsState State;
    }
    internal interface IXGraphicsRenderer
    {
        void Close();

        void DrawLine(XPen pen, double x1, double y1, double x2, double y2);

        void DrawLines(XPen pen, XPoint[] points);

        void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);

        void DrawBeziers(XPen pen, XPoint[] points);

        void DrawCurve(XPen pen, XPoint[] points, double tension);

        void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle);

        void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height);

        void DrawRectangles(XPen pen, XBrush brush, XRect[] rects);

        void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight);

        void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height);

        void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode);

        void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle);

        void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, double tension, XFillMode fillmode);

        void DrawPath(XPen pen, XBrush brush, XGraphicsPath path);

        void DrawString(string s, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format);

        void DrawImage(XImage image, double x, double y, double width, double height);
        void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit);

        void Save(XGraphicsState state);

        void Restore(XGraphicsState state);

        void BeginContainer(XGraphicsContainer container, XRect dstrect, XRect srcrect, XGraphicsUnit unit);

        void EndContainer(XGraphicsContainer container);

        void AddTransform(XMatrix transform, XMatrixOrder matrixOrder);

        void SetClip(XGraphicsPath path, XCombineMode combineMode);

        void ResetClip();

        void WriteComment(string comment);

    }
    public class XPdfFontOptions
    {
        internal XPdfFontOptions() { }

        [Obsolete("Must not specify an embedding option anymore.")]
        public XPdfFontOptions(PdfFontEncoding encoding, PdfFontEmbedding embedding)
        {
            _fontEncoding = encoding;
        }

        public XPdfFontOptions(PdfFontEncoding encoding)
        {
            _fontEncoding = encoding;
        }

        [Obsolete("Must not specify an embedding option anymore.")]
        public XPdfFontOptions(PdfFontEmbedding embedding)
        {
            _fontEncoding = PdfFontEncoding.WinAnsi;
        }

        public PdfFontEmbedding FontEmbedding
        {
            get { return PdfFontEmbedding.Always; }
        }

        public PdfFontEncoding FontEncoding
        {
            get { return _fontEncoding; }
        }
        readonly PdfFontEncoding _fontEncoding;

        public static XPdfFontOptions WinAnsiDefault
        {
            get { return new XPdfFontOptions(PdfFontEncoding.WinAnsi); }
        }

        public static XPdfFontOptions UnicodeDefault
        {
            get { return new XPdfFontOptions(PdfFontEncoding.Unicode); }
        }
    }
    public class XBitmapDecoder
    {
        internal XBitmapDecoder()
        { }

        public static XBitmapDecoder GetPngDecoder()
        {
            return new XPngBitmapDecoder();
        }
    }
    internal sealed class XPngBitmapDecoder : XBitmapDecoder
    {
        internal XPngBitmapDecoder()
        { }
    }
    public abstract class XBitmapEncoder
    {
        internal XBitmapEncoder()
        {
        }

        public static XBitmapEncoder GetPngEncoder()
        {
            return new XPngBitmapEncoder();
        }

        public XBitmapSource Source
        {
            get { return _source; }
            set { _source = value; }
        }
        XBitmapSource _source;

        public abstract void Save(Stream stream);
    }
    internal sealed class XPngBitmapEncoder : XBitmapEncoder
    {
        internal XPngBitmapEncoder()
        { }

        public override void Save(Stream stream)
        {
            if (Source == null)
                throw new InvalidOperationException("No image source.");
#if CORE_WITH_GDI || GDI
            if (Source.AssociatedGraphics != null)
            {
                Source.DisassociateWithGraphics();
                Debug.Assert(Source.AssociatedGraphics == null);
            }
            try
            {
                Lock.EnterGdiPlus();
                Source._gdiImage.Save(stream, ImageFormat.Png);
            }
            finally { Lock.ExitGdiPlus(); }
#endif
        }
    }
    public sealed class XBitmapImage : XBitmapSource
    {
        internal XBitmapImage(int width, int height)
        {
#if GDI || CORE_WITH_GDI
            try
            {
                Lock.EnterGdiPlus();
                _gdiImage = new Bitmap(width, height);
            }
            finally { Lock.ExitGdiPlus(); }
#endif

#if CORE || GDI && !WPF     
            Initialize();
#endif
        }

        public static XBitmapSource CreateBitmap(int width, int height)
        {
            return new XBitmapImage(width, height);
        }
    }
    public abstract class XBitmapSource : XImage
    {
        public override int PixelWidth
        {
            get
            {
#if (CORE_WITH_GDI || GDI) && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Width;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

        public override int PixelHeight
        {
            get
            {
#if (CORE_WITH_GDI || GDI) && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Height;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }
    }
    public static class XBrushes
    {
        public static XSolidBrush AliceBlue
        {
            get { return new XSolidBrush(XColors.AliceBlue, true); }
        }

        public static XSolidBrush AntiqueWhite
        {
            get { return new XSolidBrush(XColors.AntiqueWhite, true); }
        }

        public static XSolidBrush Aqua
        {
            get { return new XSolidBrush(XColors.Aqua, true); }
        }

        public static XSolidBrush Aquamarine
        {
            get { return new XSolidBrush(XColors.Aquamarine, true); }
        }

        public static XSolidBrush Azure
        {
            get { return new XSolidBrush(XColors.Azure, true); }
        }

        public static XSolidBrush Beige
        {
            get { return new XSolidBrush(XColors.Beige, true); }
        }

        public static XSolidBrush Bisque
        {
            get { return new XSolidBrush(XColors.Bisque, true); }
        }

        public static XSolidBrush Black
        {
            get { return new XSolidBrush(XColors.Black, true); }
        }

        public static XSolidBrush BlanchedAlmond
        {
            get { return new XSolidBrush(XColors.BlanchedAlmond, true); }
        }

        public static XSolidBrush Blue
        {
            get { return new XSolidBrush(XColors.Blue, true); }
        }

        public static XSolidBrush BlueViolet
        {
            get { return new XSolidBrush(XColors.BlueViolet, true); }
        }

        public static XSolidBrush Brown
        {
            get { return new XSolidBrush(XColors.Brown, true); }
        }

        public static XSolidBrush BurlyWood
        {
            get { return new XSolidBrush(XColors.BurlyWood, true); }
        }

        public static XSolidBrush CadetBlue
        {
            get { return new XSolidBrush(XColors.CadetBlue, true); }
        }

        public static XSolidBrush Chartreuse
        {
            get { return new XSolidBrush(XColors.Chartreuse, true); }
        }

        public static XSolidBrush Chocolate
        {
            get { return new XSolidBrush(XColors.Chocolate, true); }
        }

        public static XSolidBrush Coral
        {
            get { return new XSolidBrush(XColors.Coral, true); }
        }

        public static XSolidBrush CornflowerBlue
        {
            get { return new XSolidBrush(XColors.CornflowerBlue, true); }
        }

        public static XSolidBrush Cornsilk
        {
            get { return new XSolidBrush(XColors.Cornsilk, true); }
        }

        public static XSolidBrush Crimson
        {
            get { return new XSolidBrush(XColors.Crimson, true); }
        }

        public static XSolidBrush Cyan
        {
            get { return new XSolidBrush(XColors.Cyan, true); }
        }

        public static XSolidBrush DarkBlue
        {
            get { return new XSolidBrush(XColors.DarkBlue, true); }
        }

        public static XSolidBrush DarkCyan
        {
            get { return new XSolidBrush(XColors.DarkCyan, true); }
        }

        public static XSolidBrush DarkGoldenrod
        {
            get { return new XSolidBrush(XColors.DarkGoldenrod, true); }
        }

        public static XSolidBrush DarkGray
        {
            get { return new XSolidBrush(XColors.DarkGray, true); }
        }

        public static XSolidBrush DarkGreen
        {
            get { return new XSolidBrush(XColors.DarkGreen, true); }
        }

        public static XSolidBrush DarkKhaki
        {
            get { return new XSolidBrush(XColors.DarkKhaki, true); }
        }

        public static XSolidBrush DarkMagenta
        {
            get { return new XSolidBrush(XColors.DarkMagenta, true); }
        }

        public static XSolidBrush DarkOliveGreen
        {
            get { return new XSolidBrush(XColors.DarkOliveGreen, true); }
        }

        public static XSolidBrush DarkOrange
        {
            get { return new XSolidBrush(XColors.DarkOrange, true); }
        }

        public static XSolidBrush DarkOrchid
        {
            get { return new XSolidBrush(XColors.DarkOrchid, true); }
        }

        public static XSolidBrush DarkRed
        {
            get { return new XSolidBrush(XColors.DarkRed, true); }
        }

        public static XSolidBrush DarkSalmon
        {
            get { return new XSolidBrush(XColors.DarkSalmon, true); }
        }

        public static XSolidBrush DarkSeaGreen
        {
            get { return new XSolidBrush(XColors.DarkSeaGreen, true); }
        }

        public static XSolidBrush DarkSlateBlue
        {
            get { return new XSolidBrush(XColors.DarkSlateBlue, true); }
        }

        public static XSolidBrush DarkSlateGray
        {
            get { return new XSolidBrush(XColors.DarkSlateGray, true); }
        }

        public static XSolidBrush DarkTurquoise
        {
            get { return new XSolidBrush(XColors.DarkTurquoise, true); }
        }

        public static XSolidBrush DarkViolet
        {
            get { return new XSolidBrush(XColors.DarkViolet, true); }
        }

        public static XSolidBrush DeepPink
        {
            get { return new XSolidBrush(XColors.DeepPink, true); }
        }

        public static XSolidBrush DeepSkyBlue
        {
            get { return new XSolidBrush(XColors.DeepSkyBlue, true); }
        }

        public static XSolidBrush DimGray
        {
            get { return new XSolidBrush(XColors.DimGray, true); }
        }

        public static XSolidBrush DodgerBlue
        {
            get { return new XSolidBrush(XColors.DodgerBlue, true); }
        }

        public static XSolidBrush Firebrick
        {
            get { return new XSolidBrush(XColors.Firebrick, true); }
        }

        public static XSolidBrush FloralWhite
        {
            get { return new XSolidBrush(XColors.FloralWhite, true); }
        }

        public static XSolidBrush ForestGreen
        {
            get { return new XSolidBrush(XColors.ForestGreen, true); }
        }

        public static XSolidBrush Fuchsia
        {
            get { return new XSolidBrush(XColors.Fuchsia, true); }
        }

        public static XSolidBrush Gainsboro
        {
            get { return new XSolidBrush(XColors.Gainsboro, true); }
        }

        public static XSolidBrush GhostWhite
        {
            get { return new XSolidBrush(XColors.GhostWhite, true); }
        }

        public static XSolidBrush Gold
        {
            get { return new XSolidBrush(XColors.Gold, true); }
        }

        public static XSolidBrush Goldenrod
        {
            get { return new XSolidBrush(XColors.Goldenrod, true); }
        }

        public static XSolidBrush Gray
        {
            get { return new XSolidBrush(XColors.Gray, true); }
        }

        public static XSolidBrush Green
        {
            get { return new XSolidBrush(XColors.Green, true); }
        }

        public static XSolidBrush GreenYellow
        {
            get { return new XSolidBrush(XColors.GreenYellow, true); }
        }

        public static XSolidBrush Honeydew
        {
            get { return new XSolidBrush(XColors.Honeydew, true); }
        }

        public static XSolidBrush HotPink
        {
            get { return new XSolidBrush(XColors.HotPink, true); }
        }

        public static XSolidBrush IndianRed
        {
            get { return new XSolidBrush(XColors.IndianRed, true); }
        }

        public static XSolidBrush Indigo
        {
            get { return new XSolidBrush(XColors.Indigo, true); }
        }

        public static XSolidBrush Ivory
        {
            get { return new XSolidBrush(XColors.Ivory, true); }
        }

        public static XSolidBrush Khaki
        {
            get { return new XSolidBrush(XColors.Khaki, true); }
        }

        public static XSolidBrush Lavender
        {
            get { return new XSolidBrush(XColors.Lavender, true); }
        }

        public static XSolidBrush LavenderBlush
        {
            get { return new XSolidBrush(XColors.LavenderBlush, true); }
        }

        public static XSolidBrush LawnGreen
        {
            get { return new XSolidBrush(XColors.LawnGreen, true); }
        }

        public static XSolidBrush LemonChiffon
        {
            get { return new XSolidBrush(XColors.LemonChiffon, true); }
        }

        public static XSolidBrush LightBlue
        {
            get { return new XSolidBrush(XColors.LightBlue, true); }
        }

        public static XSolidBrush LightCoral
        {
            get { return new XSolidBrush(XColors.LightCoral, true); }
        }

        public static XSolidBrush LightCyan
        {
            get { return new XSolidBrush(XColors.LightCyan, true); }
        }

        public static XSolidBrush LightGoldenrodYellow
        {
            get { return new XSolidBrush(XColors.LightGoldenrodYellow, true); }
        }

        public static XSolidBrush LightGray
        {
            get { return new XSolidBrush(XColors.LightGray, true); }
        }

        public static XSolidBrush LightGreen
        {
            get { return new XSolidBrush(XColors.LightGreen, true); }
        }

        public static XSolidBrush LightPink
        {
            get { return new XSolidBrush(XColors.LightPink, true); }
        }

        public static XSolidBrush LightSalmon
        {
            get { return new XSolidBrush(XColors.LightSalmon, true); }
        }

        public static XSolidBrush LightSeaGreen
        {
            get { return new XSolidBrush(XColors.LightSeaGreen, true); }
        }

        public static XSolidBrush LightSkyBlue
        {
            get { return new XSolidBrush(XColors.LightSkyBlue, true); }
        }

        public static XSolidBrush LightSlateGray
        {
            get { return new XSolidBrush(XColors.LightSlateGray, true); }
        }

        public static XSolidBrush LightSteelBlue
        {
            get { return new XSolidBrush(XColors.LightSteelBlue, true); }
        }

        public static XSolidBrush LightYellow
        {
            get { return new XSolidBrush(XColors.LightYellow, true); }
        }

        public static XSolidBrush Lime
        {
            get { return new XSolidBrush(XColors.Lime, true); }
        }

        public static XSolidBrush LimeGreen
        {
            get { return new XSolidBrush(XColors.LimeGreen, true); }
        }

        public static XSolidBrush Linen
        {
            get { return new XSolidBrush(XColors.Linen, true); }
        }

        public static XSolidBrush Magenta
        {
            get { return new XSolidBrush(XColors.Magenta, true); }
        }

        public static XSolidBrush Maroon
        {
            get { return new XSolidBrush(XColors.Maroon, true); }
        }

        public static XSolidBrush MediumAquamarine
        {
            get { return new XSolidBrush(XColors.MediumAquamarine, true); }
        }

        public static XSolidBrush MediumBlue
        {
            get { return new XSolidBrush(XColors.MediumBlue, true); }
        }

        public static XSolidBrush MediumOrchid
        {
            get { return new XSolidBrush(XColors.MediumOrchid, true); }
        }

        public static XSolidBrush MediumPurple
        {
            get { return new XSolidBrush(XColors.MediumPurple, true); }
        }

        public static XSolidBrush MediumSeaGreen
        {
            get { return new XSolidBrush(XColors.MediumSeaGreen, true); }
        }

        public static XSolidBrush MediumSlateBlue
        {
            get { return new XSolidBrush(XColors.MediumSlateBlue, true); }
        }

        public static XSolidBrush MediumSpringGreen
        {
            get { return new XSolidBrush(XColors.MediumSpringGreen, true); }
        }

        public static XSolidBrush MediumTurquoise
        {
            get { return new XSolidBrush(XColors.MediumTurquoise, true); }
        }

        public static XSolidBrush MediumVioletRed
        {
            get { return new XSolidBrush(XColors.MediumVioletRed, true); }
        }

        public static XSolidBrush MidnightBlue
        {
            get { return new XSolidBrush(XColors.MidnightBlue, true); }
        }

        public static XSolidBrush MintCream
        {
            get { return new XSolidBrush(XColors.MintCream, true); }
        }

        public static XSolidBrush MistyRose
        {
            get { return new XSolidBrush(XColors.MistyRose, true); }
        }

        public static XSolidBrush Moccasin
        {
            get { return new XSolidBrush(XColors.Moccasin, true); }
        }

        public static XSolidBrush NavajoWhite
        {
            get { return new XSolidBrush(XColors.NavajoWhite, true); }
        }

        public static XSolidBrush Navy
        {
            get { return new XSolidBrush(XColors.Navy, true); }
        }

        public static XSolidBrush OldLace
        {
            get { return new XSolidBrush(XColors.OldLace, true); }
        }

        public static XSolidBrush Olive
        {
            get { return new XSolidBrush(XColors.Olive, true); }
        }

        public static XSolidBrush OliveDrab
        {
            get { return new XSolidBrush(XColors.OliveDrab, true); }
        }

        public static XSolidBrush Orange
        {
            get { return new XSolidBrush(XColors.Orange, true); }
        }

        public static XSolidBrush OrangeRed
        {
            get { return new XSolidBrush(XColors.OrangeRed, true); }
        }

        public static XSolidBrush Orchid
        {
            get { return new XSolidBrush(XColors.Orchid, true); }
        }

        public static XSolidBrush PaleGoldenrod
        {
            get { return new XSolidBrush(XColors.PaleGoldenrod, true); }
        }

        public static XSolidBrush PaleGreen
        {
            get { return new XSolidBrush(XColors.PaleGreen, true); }
        }

        public static XSolidBrush PaleTurquoise
        {
            get { return new XSolidBrush(XColors.PaleTurquoise, true); }
        }

        public static XSolidBrush PaleVioletRed
        {
            get { return new XSolidBrush(XColors.PaleVioletRed, true); }
        }

        public static XSolidBrush PapayaWhip
        {
            get { return new XSolidBrush(XColors.PapayaWhip, true); }
        }

        public static XSolidBrush PeachPuff
        {
            get { return new XSolidBrush(XColors.PeachPuff, true); }
        }

        public static XSolidBrush Peru
        {
            get { return new XSolidBrush(XColors.Peru, true); }
        }

        public static XSolidBrush Pink
        {
            get { return new XSolidBrush(XColors.Pink, true); }
        }

        public static XSolidBrush Plum
        {
            get { return new XSolidBrush(XColors.Plum, true); }
        }

        public static XSolidBrush PowderBlue
        {
            get { return new XSolidBrush(XColors.PowderBlue, true); }
        }

        public static XSolidBrush Purple
        {
            get { return new XSolidBrush(XColors.Purple, true); }
        }

        public static XSolidBrush Red
        {
            get { return new XSolidBrush(XColors.Red, true); }
        }

        public static XSolidBrush RosyBrown
        {
            get { return new XSolidBrush(XColors.RosyBrown, true); }
        }

        public static XSolidBrush RoyalBlue
        {
            get { return new XSolidBrush(XColors.RoyalBlue, true); }
        }

        public static XSolidBrush SaddleBrown
        {
            get { return new XSolidBrush(XColors.SaddleBrown, true); }
        }

        public static XSolidBrush Salmon
        {
            get { return new XSolidBrush(XColors.Salmon, true); }
        }

        public static XSolidBrush SandyBrown
        {
            get { return new XSolidBrush(XColors.SandyBrown, true); }
        }

        public static XSolidBrush SeaGreen
        {
            get { return new XSolidBrush(XColors.SeaGreen, true); }
        }

        public static XSolidBrush SeaShell
        {
            get { return new XSolidBrush(XColors.SeaShell, true); }
        }

        public static XSolidBrush Sienna
        {
            get { return new XSolidBrush(XColors.Sienna, true); }
        }

        public static XSolidBrush Silver
        {
            get { return new XSolidBrush(XColors.Silver, true); }
        }

        public static XSolidBrush SkyBlue
        {
            get { return new XSolidBrush(XColors.SkyBlue, true); }
        }

        public static XSolidBrush SlateBlue
        {
            get { return new XSolidBrush(XColors.SlateBlue, true); }
        }

        public static XSolidBrush SlateGray
        {
            get { return new XSolidBrush(XColors.SlateGray, true); }
        }

        public static XSolidBrush Snow
        {
            get { return new XSolidBrush(XColors.Snow, true); }
        }

        public static XSolidBrush SpringGreen
        {
            get { return new XSolidBrush(XColors.SpringGreen, true); }
        }

        public static XSolidBrush SteelBlue
        {
            get { return new XSolidBrush(XColors.SteelBlue, true); }
        }

        public static XSolidBrush Tan
        {
            get { return new XSolidBrush(XColors.Tan, true); }
        }

        public static XSolidBrush Teal
        {
            get { return new XSolidBrush(XColors.Teal, true); }
        }

        public static XSolidBrush Thistle
        {
            get { return new XSolidBrush(XColors.Thistle, true); }
        }

        public static XSolidBrush Tomato
        {
            get { return new XSolidBrush(XColors.Tomato, true); }
        }

        public static XSolidBrush Transparent
        {
            get { return new XSolidBrush(XColors.Transparent, true); }
        }

        public static XSolidBrush Turquoise
        {
            get { return new XSolidBrush(XColors.Turquoise, true); }
        }

        public static XSolidBrush Violet
        {
            get { return new XSolidBrush(XColors.Violet, true); }
        }

        public static XSolidBrush Wheat
        {
            get { return new XSolidBrush(XColors.Wheat, true); }
        }

        public static XSolidBrush White
        {
            get { return new XSolidBrush(XColors.White, true); }
        }

        public static XSolidBrush WhiteSmoke
        {
            get { return new XSolidBrush(XColors.WhiteSmoke, true); }
        }

        public static XSolidBrush Yellow
        {
            get { return new XSolidBrush(XColors.Yellow, true); }
        }

        public static XSolidBrush YellowGreen
        {
            get { return new XSolidBrush(XColors.YellowGreen, true); }
        }
    }
    public struct XColor
    {
        XColor(uint argb)
        {
            _cs = XColorSpace.Rgb;
            _a = (byte)((argb >> 24) & 0xff) / 255f;
            _r = (byte)((argb >> 16) & 0xff);
            _g = (byte)((argb >> 8) & 0xff);
            _b = (byte)(argb & 0xff);
            _c = 0;
            _m = 0;
            _y = 0;
            _k = 0;
            _gs = 0;
            RgbChanged();
        }

        XColor(byte alpha, byte red, byte green, byte blue)
        {
            _cs = XColorSpace.Rgb;
            _a = alpha / 255f;
            _r = red;
            _g = green;
            _b = blue;
            _c = 0;
            _m = 0;
            _y = 0;
            _k = 0;
            _gs = 0;
            RgbChanged();
        }

        XColor(double alpha, double cyan, double magenta, double yellow, double black)
        {
            _cs = XColorSpace.Cmyk;
            _a = (float)(alpha > 1 ? 1 : (alpha < 0 ? 0 : alpha));
            _c = (float)(cyan > 1 ? 1 : (cyan < 0 ? 0 : cyan));
            _m = (float)(magenta > 1 ? 1 : (magenta < 0 ? 0 : magenta));
            _y = (float)(yellow > 1 ? 1 : (yellow < 0 ? 0 : yellow));
            _k = (float)(black > 1 ? 1 : (black < 0 ? 0 : black));
            _r = 0;
            _g = 0;
            _b = 0;
            _gs = 0f;
            CmykChanged();
        }

        XColor(double cyan, double magenta, double yellow, double black)
            : this(1.0, cyan, magenta, yellow, black)
        { }

        XColor(double gray)
        {
            _cs = XColorSpace.GrayScale;
            if (gray < 0)
                _gs = 0;
            else if (gray > 1)
                _gs = 1;
            else
                _gs = (float)gray;

            _a = 1;
            _r = 0;
            _g = 0;
            _b = 0;
            _c = 0;
            _m = 0;
            _y = 0;
            _k = 0;
            GrayChanged();
        }

        internal XColor(XKnownColor knownColor)
            : this(XKnownColorTable.KnownColorToArgb(knownColor))
        { }

        public static XColor FromArgb(int argb)
        {
            return new XColor((byte)(argb >> 24), (byte)(argb >> 16), (byte)(argb >> 8), (byte)(argb));
        }

        public static XColor FromArgb(uint argb)
        {
            return new XColor((byte)(argb >> 24), (byte)(argb >> 16), (byte)(argb >> 8), (byte)(argb));
        }

        public static XColor FromArgb(int red, int green, int blue)
        {
            CheckByte(red, "red");
            CheckByte(green, "green");
            CheckByte(blue, "blue");
            return new XColor(255, (byte)red, (byte)green, (byte)blue);
        }

        public static XColor FromArgb(int alpha, int red, int green, int blue)
        {
            CheckByte(alpha, "alpha");
            CheckByte(red, "red");
            CheckByte(green, "green");
            CheckByte(blue, "blue");
            return new XColor((byte)alpha, (byte)red, (byte)green, (byte)blue);
        }

        public static XColor FromArgb(int alpha, XColor color)
        {
            color.A = ((byte)alpha) / 255.0;
            return color;
        }


        public static XColor FromCmyk(double cyan, double magenta, double yellow, double black)
        {
            return new XColor(cyan, magenta, yellow, black);
        }

        public static XColor FromCmyk(double alpha, double cyan, double magenta, double yellow, double black)
        {
            return new XColor(alpha, cyan, magenta, yellow, black);
        }

        public static XColor FromGrayScale(double grayScale)
        {
            return new XColor(grayScale);
        }

        public static XColor FromKnownColor(XKnownColor color)
        {
            return new XColor(color);
        }

        public static XColor FromName(string name)
        {
            return Empty;
        }

        public XColorSpace ColorSpace
        {
            get { return _cs; }
            set
            {
                if (!Enum.IsDefined(typeof(XColorSpace), value))
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(XColorSpace));
                _cs = value;
            }
        }

        public bool IsEmpty
        {
            get { return this == Empty; }
        }

        public override bool Equals(object obj)
        {
            if (obj is XColor)
            {
                XColor color = (XColor)obj;
                if (_r == color._r && _g == color._g && _b == color._b &&
                  _c == color._c && _m == color._m && _y == color._y && _k == color._k &&
                  _gs == color._gs)
                {
                    return _a == color._a;
                }
            }
            return false;
        }

        public override int GetHashCode()
        {
            return ((byte)(_a * 255)) ^ _r ^ _g ^ _b;
        }

        public static bool operator ==(XColor left, XColor right)
        {
            if (left._r == right._r && left._g == right._g && left._b == right._b &&
                left._c == right._c && left._m == right._m && left._y == right._y && left._k == right._k &&
                left._gs == right._gs)
            {
                return left._a == right._a;
            }
            return false;
        }

        public static bool operator !=(XColor left, XColor right)
        {
            return !(left == right);
        }

        public bool IsKnownColor
        {
            get { return XKnownColorTable.IsKnownColor(Argb); }
        }

        public double GetHue()
        {
            if ((_r == _g) && (_g == _b))
                return 0;

            double value1 = _r / 255.0;
            double value2 = _g / 255.0;
            double value3 = _b / 255.0;
            double value7 = 0;
            double value4 = value1;
            double value5 = value1;
            if (value2 > value4)
                value4 = value2;

            if (value3 > value4)
                value4 = value3;

            if (value2 < value5)
                value5 = value2;

            if (value3 < value5)
                value5 = value3;

            double value6 = value4 - value5;
            if (value1 == value4)
                value7 = (value2 - value3) / value6;
            else if (value2 == value4)
                value7 = 2f + ((value3 - value1) / value6);
            else if (value3 == value4)
                value7 = 4f + ((value1 - value2) / value6);

            value7 *= 60;
            if (value7 < 0)
                value7 += 360;
            return value7;
        }

        public double GetSaturation()
        {
            double value1 = _r / 255.0;
            double value2 = _g / 255.0;
            double value3 = _b / 255.0;
            double value7 = 0;
            double value4 = value1;
            double value5 = value1;
            if (value2 > value4)
                value4 = value2;

            if (value3 > value4)
                value4 = value3;

            if (value2 < value5)
                value5 = value2;

            if (value3 < value5)
                value5 = value3;

            if (value4 == value5)
                return value7;

            double value6 = (value4 + value5) / 2;
            if (value6 <= 0.5)
                return (value4 - value5) / (value4 + value5);
            return (value4 - value5) / ((2f - value4) - value5);
        }

        public double GetBrightness()
        {
            double value1 = _r / 255.0;
            double value2 = _g / 255.0;
            double value3 = _b / 255.0;
            double value4 = value1;
            double value5 = value1;
            if (value2 > value4)
                value4 = value2;

            if (value3 > value4)
                value4 = value3;

            if (value2 < value5)
                value5 = value2;

            if (value3 < value5)
                value5 = value3;

            return (value4 + value5) / 2;
        }

        void RgbChanged()
        {
            _cs = XColorSpace.Rgb;
            int c = 255 - _r;
            int m = 255 - _g;
            int y = 255 - _b;
            int k = Math.Min(c, Math.Min(m, y));
            if (k == 255)
                _c = _m = _y = 0;
            else
            {
                float black = 255f - k;
                _c = (c - k) / black;
                _m = (m - k) / black;
                _y = (y - k) / black;
            }
            _k = _gs = k / 255f;
        }

        void CmykChanged()
        {
            _cs = XColorSpace.Cmyk;
            float black = _k * 255;
            float factor = 255f - black;
            _r = (byte)(255 - Math.Min(255f, _c * factor + black));
            _g = (byte)(255 - Math.Min(255f, _m * factor + black));
            _b = (byte)(255 - Math.Min(255f, _y * factor + black));
            _gs = (float)(1 - Math.Min(1.0, 0.3f * _c + 0.59f * _m + 0.11 * _y + _k));
        }

        void GrayChanged()
        {
            _cs = XColorSpace.GrayScale;
            _r = (byte)(_gs * 255);
            _g = (byte)(_gs * 255);
            _b = (byte)(_gs * 255);
            _c = 0;
            _m = 0;
            _y = 0;
            _k = 1 - _gs;
        }

        public double A
        {
            get { return _a; }
            set
            {
                if (value < 0)
                    _a = 0;
                else if (value > 1)
                    _a = 1;
                else
                    _a = (float)value;
            }
        }

        public byte R
        {
            get { return _r; }
            set { _r = value; RgbChanged(); }
        }

        public byte G
        {
            get { return _g; }
            set { _g = value; RgbChanged(); }
        }

        public byte B
        {
            get { return _b; }
            set { _b = value; RgbChanged(); }
        }

        internal uint Rgb
        {
            get { return ((uint)_r << 16) | ((uint)_g << 8) | _b; }
        }

        internal uint Argb
        {
            get { return ((uint)(_a * 255) << 24) | ((uint)_r << 16) | ((uint)_g << 8) | _b; }
        }

        public double C
        {
            get { return _c; }
            set
            {
                if (value < 0)
                    _c = 0;
                else if (value > 1)
                    _c = 1;
                else
                    _c = (float)value;
                CmykChanged();
            }
        }

        public double M
        {
            get { return _m; }
            set
            {
                if (value < 0)
                    _m = 0;
                else if (value > 1)
                    _m = 1;
                else
                    _m = (float)value;
                CmykChanged();
            }
        }

        public double Y
        {
            get { return _y; }
            set
            {
                if (value < 0)
                    _y = 0;
                else if (value > 1)
                    _y = 1;
                else
                    _y = (float)value;
                CmykChanged();
            }
        }

        public double K
        {
            get { return _k; }
            set
            {
                if (value < 0)
                    _k = 0;
                else if (value > 1)
                    _k = 1;
                else
                    _k = (float)value;
                CmykChanged();
            }
        }

        public double GS
        {
            get { return _gs; }
            set
            {
                if (value < 0)
                    _gs = 0;
                else if (value > 1)
                    _gs = 1;
                else
                    _gs = (float)value;
                GrayChanged();
            }
        }

        public static XColor Empty;

        public string RgbCmykG
        {
            get
            {
                return String.Format(CultureInfo.InvariantCulture,
                  "{0};{1};{2};{3};{4};{5};{6};{7};{8}", _r, _g, _b, _c, _m, _y, _k, _gs, _a);
            }
            set
            {
                string[] values = value.Split(';');
                _r = byte.Parse(values[0], CultureInfo.InvariantCulture);
                _g = byte.Parse(values[1], CultureInfo.InvariantCulture);
                _b = byte.Parse(values[2], CultureInfo.InvariantCulture);
                _c = float.Parse(values[3], CultureInfo.InvariantCulture);
                _m = float.Parse(values[4], CultureInfo.InvariantCulture);
                _y = float.Parse(values[5], CultureInfo.InvariantCulture);
                _k = float.Parse(values[6], CultureInfo.InvariantCulture);
                _gs = float.Parse(values[7], CultureInfo.InvariantCulture);
                _a = float.Parse(values[8], CultureInfo.InvariantCulture);
            }
        }

        static void CheckByte(int val, string name)
        {
            if (val < 0 || val > 0xFF)
                throw new ArgumentException(PSSR.InvalidValue(val, name, 0, 255));
        }

        XColorSpace _cs;

        float _a;

        byte _r;
        byte _g;
        byte _b;

        float _c;
        float _m;
        float _y;
        float _k;

        float _gs;
    }
    public class XColorResourceManager
    {
        public XColorResourceManager()
#if !NETFX_CORE && !UWP
            : this(Thread.CurrentThread.CurrentUICulture)
#endif
        { }

        public XColorResourceManager(CultureInfo cultureInfo)
        {
            _cultureInfo = cultureInfo;
        }

        readonly CultureInfo _cultureInfo;


        public static XKnownColor GetKnownColor(uint argb)
        {
            XKnownColor knownColor = XKnownColorTable.GetKnownColor(argb);
            if ((int)knownColor == -1)
                throw new ArgumentException("The argument is not a known color", "argb");
            return knownColor;
        }

        public static XKnownColor[] GetKnownColors(bool includeTransparent)
        {
            int count = colorInfos.Length;
            XKnownColor[] knownColor = new XKnownColor[count - (includeTransparent ? 0 : 1)];
            for (int idxIn = includeTransparent ? 0 : 1, idxOut = 0; idxIn < count; idxIn++, idxOut++)
                knownColor[idxOut] = colorInfos[idxIn].KnownColor;
            return knownColor;
        }

        public string ToColorName(XKnownColor knownColor)
        {
            ColorResourceInfo colorInfo = GetColorInfo(knownColor);

            if (_cultureInfo.TwoLetterISOLanguageName == "de")
                return colorInfo.NameDE;

            return colorInfo.Name;
        }

        public string ToColorName(XColor color)
        {
            string name;
            if (color.IsKnownColor)
                name = ToColorName(XKnownColorTable.GetKnownColor(color.Argb));
            else
                name = String.Format("{0}, {1}, {2}, {3}", (int)(255 * color.A), color.R, color.G, color.B);
            return name;
        }

        static ColorResourceInfo GetColorInfo(XKnownColor knownColor)
        {
            for (int idx = 0; idx < colorInfos.Length; idx++)
            {
                ColorResourceInfo colorInfo = colorInfos[idx];
                if (colorInfo.KnownColor == knownColor)
                    return colorInfo;
            }
            throw new InvalidEnumArgumentException("Enum is not an XKnownColor.");
        }

        internal static ColorResourceInfo[] colorInfos = new ColorResourceInfo[]
            {
              new ColorResourceInfo(XKnownColor.Transparent, XColors.Transparent, 0x00FFFFFF, "Transparent", "Transparent"),
              new ColorResourceInfo(XKnownColor.Black, XColors.Black, 0xFF000000, "Black", "Schwarz"),
              new ColorResourceInfo(XKnownColor.DarkSlateGray, XColors.DarkSlateGray, 0xFF8FBC8F, "Darkslategray", "Dunkles Schiefergrau"),
              new ColorResourceInfo(XKnownColor.SlateGray, XColors.SlateGray, 0xFF708090, "Slategray", "Schiefergrau"),
              new ColorResourceInfo(XKnownColor.LightSlateGray, XColors.LightSlateGray, 0xFF778899, "Lightslategray", "Helles Schiefergrau"),
              new ColorResourceInfo(XKnownColor.LightSteelBlue, XColors.LightSteelBlue, 0xFFB0C4DE, "Lightsteelblue", "Helles Stahlblau"),
              new ColorResourceInfo(XKnownColor.DimGray, XColors.DimGray, 0xFF696969, "Dimgray", "Gedecktes Grau"),
              new ColorResourceInfo(XKnownColor.Gray, XColors.Gray, 0xFF808080, "Gray", "Grau"),
              new ColorResourceInfo(XKnownColor.DarkGray, XColors.DarkGray, 0xFFA9A9A9, "Darkgray", "Dunkelgrau"),
              new ColorResourceInfo(XKnownColor.Silver, XColors.Silver, 0xFFC0C0C0, "Silver", "Silber"),
              new ColorResourceInfo(XKnownColor.Gainsboro, XColors.Gainsboro, 0xFFDCDCDC, "Gainsboro", "Helles Blaugrau"),
              new ColorResourceInfo(XKnownColor.WhiteSmoke, XColors.WhiteSmoke, 0xFFF5F5F5, "Whitesmoke", "Rauchweiß"),
              new ColorResourceInfo(XKnownColor.GhostWhite, XColors.GhostWhite, 0xFFF8F8FF, "Ghostwhite", "Schattenweiß"),
              new ColorResourceInfo(XKnownColor.White, XColors.White, 0xFFFFFFFF, "White", "Weiß"),
              new ColorResourceInfo(XKnownColor.Snow, XColors.Snow, 0xFFFFFAFA, "Snow", "Schneeweiß"),
              new ColorResourceInfo(XKnownColor.Ivory, XColors.Ivory, 0xFFFFFFF0, "Ivory", "Elfenbein"),
              new ColorResourceInfo(XKnownColor.FloralWhite, XColors.FloralWhite, 0xFFFFFAF0, "Floralwhite", "Blütenweiß"),
              new ColorResourceInfo(XKnownColor.SeaShell, XColors.SeaShell, 0xFFFFF5EE, "Seashell", "Muschel"),
              new ColorResourceInfo(XKnownColor.OldLace, XColors.OldLace, 0xFFFDF5E6, "Oldlace", "Altweiß"),
              new ColorResourceInfo(XKnownColor.Linen, XColors.Linen, 0xFFFAF0E6, "Linen", "Leinen"),
              new ColorResourceInfo(XKnownColor.AntiqueWhite, XColors.AntiqueWhite, 0xFFFAEBD7, "Antiquewhite", "Antikes Weiß"),
              new ColorResourceInfo(XKnownColor.BlanchedAlmond, XColors.BlanchedAlmond, 0xFFFFEBCD, "Blanchedalmond", "Mandelweiß"),
              new ColorResourceInfo(XKnownColor.PapayaWhip, XColors.PapayaWhip, 0xFFFFEFD5, "Papayawhip", "Papayacreme"),
              new ColorResourceInfo(XKnownColor.Beige, XColors.Beige, 0xFFF5F5DC, "Beige", "Beige"),
              new ColorResourceInfo(XKnownColor.Cornsilk, XColors.Cornsilk, 0xFFFFF8DC, "Cornsilk", "Mais"),
              new ColorResourceInfo(XKnownColor.LightGoldenrodYellow, XColors.LightGoldenrodYellow, 0xFFFAFAD2, "Lightgoldenrodyellow", "Helles Goldgelb"),
              new ColorResourceInfo(XKnownColor.LightYellow, XColors.LightYellow, 0xFFFFFFE0, "Lightyellow", "Hellgelb"),
              new ColorResourceInfo(XKnownColor.LemonChiffon, XColors.LemonChiffon, 0xFFFFFACD, "Lemonchiffon", "Pastellgelb"),
              new ColorResourceInfo(XKnownColor.PaleGoldenrod, XColors.PaleGoldenrod, 0xFFEEE8AA, "Palegoldenrod", "Blasses Goldgelb"),
              new ColorResourceInfo(XKnownColor.Khaki, XColors.Khaki, 0xFFF0E68C, "Khaki", "Khaki"),
              new ColorResourceInfo(XKnownColor.Yellow, XColors.Yellow, 0xFFFFFF00, "Yellow", "Gelb"),
              new ColorResourceInfo(XKnownColor.Gold, XColors.Gold, 0xFFFFD700, "Gold", "Gold"),
              new ColorResourceInfo(XKnownColor.Orange, XColors.Orange, 0xFFFFA500, "Orange", "Orange"),
              new ColorResourceInfo(XKnownColor.DarkOrange, XColors.DarkOrange, 0xFFFF8C00, "Darkorange", "Dunkles Orange"),
              new ColorResourceInfo(XKnownColor.Goldenrod, XColors.Goldenrod, 0xFFDAA520, "Goldenrod", "Goldgelb"),
              new ColorResourceInfo(XKnownColor.DarkGoldenrod, XColors.DarkGoldenrod, 0xFFB8860B, "Darkgoldenrod", "Dunkles Goldgelb"),
              new ColorResourceInfo(XKnownColor.Peru, XColors.Peru, 0xFFCD853F, "Peru", "Peru"),
              new ColorResourceInfo(XKnownColor.Chocolate, XColors.Chocolate, 0xFFD2691E, "Chocolate", "Schokolade"),
              new ColorResourceInfo(XKnownColor.SaddleBrown, XColors.SaddleBrown, 0xFF8B4513, "Saddlebrown", "Sattelbraun"),
              new ColorResourceInfo(XKnownColor.Sienna, XColors.Sienna, 0xFFA0522D, "Sienna", "Ocker"),
              new ColorResourceInfo(XKnownColor.Brown, XColors.Brown, 0xFFA52A2A, "Brown", "Braun"),
              new ColorResourceInfo(XKnownColor.DarkRed, XColors.DarkRed, 0xFF8B0000, "Darkred", "Dunkelrot"),
              new ColorResourceInfo(XKnownColor.Maroon, XColors.Maroon, 0xFF800000, "Maroon", "Kastanienbraun"),
              new ColorResourceInfo(XKnownColor.PaleTurquoise, XColors.PaleTurquoise, 0xFFAFEEEE, "Paleturquoise", "Blasses Türkis"),
              new ColorResourceInfo(XKnownColor.Firebrick, XColors.Firebrick, 0xFFB22222, "Firebrick", "Ziegel"),
              new ColorResourceInfo(XKnownColor.IndianRed, XColors.IndianRed, 0xFFCD5C5C, "Indianred", "Indischrot"),
              new ColorResourceInfo(XKnownColor.Crimson, XColors.Crimson, 0xFFDC143C, "Crimson", "Karmesinrot"),
              new ColorResourceInfo(XKnownColor.Red, XColors.Red, 0xFFFF0000, "Red", "Rot"),
              new ColorResourceInfo(XKnownColor.OrangeRed, XColors.OrangeRed, 0xFFFF4500, "Orangered", "Orangerot"),
              new ColorResourceInfo(XKnownColor.Tomato, XColors.Tomato, 0xFFFF6347, "Tomato", "Tomate"),
              new ColorResourceInfo(XKnownColor.Coral, XColors.Coral, 0xFFFF7F50, "Coral", "Koralle"),
              new ColorResourceInfo(XKnownColor.Salmon, XColors.Salmon, 0xFFFA8072, "Salmon", "Lachs"),
              new ColorResourceInfo(XKnownColor.LightCoral, XColors.LightCoral, 0xFFF08080, "Lightcoral", "Helles Korallenrot"),
              new ColorResourceInfo(XKnownColor.DarkSalmon, XColors.DarkSalmon, 0xFFE9967A, "Darksalmon", "Dunkles Lachs"),
              new ColorResourceInfo(XKnownColor.LightSalmon, XColors.LightSalmon, 0xFFFFA07A, "Lightsalmon", "Helles Lachs"),
              new ColorResourceInfo(XKnownColor.SandyBrown, XColors.SandyBrown, 0xFFF4A460, "Sandybrown", "Sandbraun"),
              new ColorResourceInfo(XKnownColor.RosyBrown, XColors.RosyBrown, 0xFFBC8F8F, "Rosybrown", "Rotbraun"),
              new ColorResourceInfo(XKnownColor.Tan, XColors.Tan, 0xFFD2B48C, "Tan", "Gelbbraun"),
              new ColorResourceInfo(XKnownColor.BurlyWood, XColors.BurlyWood, 0xFFDEB887, "Burlywood", "Kräftiges Sandbraun"),
              new ColorResourceInfo(XKnownColor.Wheat, XColors.Wheat, 0xFFF5DEB3, "Wheat", "Weizen"),
              new ColorResourceInfo(XKnownColor.PeachPuff, XColors.PeachPuff, 0xFFFFDAB9, "Peachpuff", "Pfirsich"),
              new ColorResourceInfo(XKnownColor.NavajoWhite, XColors.NavajoWhite, 0xFFFFDEAD, "Navajowhite", "Orangeweiß"),
              new ColorResourceInfo(XKnownColor.Bisque, XColors.Bisque, 0xFFFFE4C4, "Bisque", "Blasses Rotbraun"),
              new ColorResourceInfo(XKnownColor.Moccasin, XColors.Moccasin, 0xFFFFE4B5, "Moccasin", "Mokassin"),
              new ColorResourceInfo(XKnownColor.LavenderBlush, XColors.LavenderBlush, 0xFFFFF0F5, "Lavenderblush", "Roter Lavendel"),
              new ColorResourceInfo(XKnownColor.MistyRose, XColors.MistyRose, 0xFFFFE4E1, "Mistyrose", "Altrosa"),
              new ColorResourceInfo(XKnownColor.Pink, XColors.Pink, 0xFFFFC0CB, "Pink", "Rosa"),
              new ColorResourceInfo(XKnownColor.LightPink, XColors.LightPink, 0xFFFFB6C1, "Lightpink", "Hellrosa"),
              new ColorResourceInfo(XKnownColor.HotPink, XColors.HotPink, 0xFFFF69B4, "Hotpink", "Leuchtendes Rosa"),
              new ColorResourceInfo(XKnownColor.Magenta, XColors.Magenta, 0xFFFF00FF, "Magenta", "Magentarot"),
              new ColorResourceInfo(XKnownColor.DeepPink, XColors.DeepPink, 0xFFFF1493, "Deeppink", "Tiefrosa"),
              new ColorResourceInfo(XKnownColor.MediumVioletRed, XColors.MediumVioletRed, 0xFFC71585, "Mediumvioletred", "Mittleres Violettrot"),
              new ColorResourceInfo(XKnownColor.PaleVioletRed, XColors.PaleVioletRed, 0xFFDB7093, "Palevioletred", "Blasses Violettrot"),
              new ColorResourceInfo(XKnownColor.Plum, XColors.Plum, 0xFFDDA0DD, "Plum", "Pflaume"),
              new ColorResourceInfo(XKnownColor.Thistle, XColors.Thistle, 0xFFD8BFD8, "Thistle", "Distel"),
              new ColorResourceInfo(XKnownColor.Lavender, XColors.Lavender, 0xFFE6E6FA, "Lavender", "Lavendel"),
              new ColorResourceInfo(XKnownColor.Violet, XColors.Violet, 0xFFEE82EE, "Violet", "Violett"),
              new ColorResourceInfo(XKnownColor.Orchid, XColors.Orchid, 0xFFDA70D6, "Orchid", "Orchidee"),
              new ColorResourceInfo(XKnownColor.DarkMagenta, XColors.DarkMagenta, 0xFF8B008B, "Darkmagenta", "Dunkles Magentarot"),
              new ColorResourceInfo(XKnownColor.Purple, XColors.Purple, 0xFF800080, "Purple", "Violett"),
              new ColorResourceInfo(XKnownColor.Indigo, XColors.Indigo, 0xFF4B0082, "Indigo", "Indigo"),
              new ColorResourceInfo(XKnownColor.BlueViolet, XColors.BlueViolet, 0xFF8A2BE2, "Blueviolet", "Blauviolett"),
              new ColorResourceInfo(XKnownColor.DarkViolet, XColors.DarkViolet, 0xFF9400D3, "Darkviolet", "Dunkles Violett"),
              new ColorResourceInfo(XKnownColor.DarkOrchid, XColors.DarkOrchid, 0xFF9932CC, "Darkorchid", "Dunkle Orchidee"),
              new ColorResourceInfo(XKnownColor.MediumPurple, XColors.MediumPurple, 0xFF9370DB, "Mediumpurple", "Mittleres Violett"),
              new ColorResourceInfo(XKnownColor.MediumOrchid, XColors.MediumOrchid, 0xFFBA55D3, "Mediumorchid", "Mittlere Orchidee"),
              new ColorResourceInfo(XKnownColor.MediumSlateBlue, XColors.MediumSlateBlue, 0xFF7B68EE, "Mediumslateblue", "Mittleres Schieferblau"),
              new ColorResourceInfo(XKnownColor.SlateBlue, XColors.SlateBlue, 0xFF6A5ACD, "Slateblue", "Schieferblau"),
              new ColorResourceInfo(XKnownColor.DarkSlateBlue, XColors.DarkSlateBlue, 0xFF483D8B, "Darkslateblue", "Dunkles Schiefergrau"),
              new ColorResourceInfo(XKnownColor.MidnightBlue, XColors.MidnightBlue, 0xFF191970, "Midnightblue", "Mitternachtsblau"),
              new ColorResourceInfo(XKnownColor.Navy, XColors.Navy, 0xFF000080, "Navy", "Marineblau"),
              new ColorResourceInfo(XKnownColor.DarkBlue, XColors.DarkBlue, 0xFF00008B, "Darkblue", "Dunkelblau"),
              new ColorResourceInfo(XKnownColor.LightGray, XColors.LightGray, 0xFFD3D3D3, "Lightgray", "Hellgrau"),
              new ColorResourceInfo(XKnownColor.MediumBlue, XColors.MediumBlue, 0xFF0000CD, "Mediumblue", "Mittelblau"),
              new ColorResourceInfo(XKnownColor.Blue, XColors.Blue, 0xFF0000FF, "Blue", "Blau"),
              new ColorResourceInfo(XKnownColor.RoyalBlue, XColors.RoyalBlue, 0xFF4169E1, "Royalblue", "Königsblau"),
              new ColorResourceInfo(XKnownColor.SteelBlue, XColors.SteelBlue, 0xFF4682B4, "Steelblue", "Stahlblau"),
              new ColorResourceInfo(XKnownColor.CornflowerBlue, XColors.CornflowerBlue, 0xFF6495ED, "Cornflowerblue", "Kornblumenblau"),
              new ColorResourceInfo(XKnownColor.DodgerBlue, XColors.DodgerBlue, 0xFF1E90FF, "Dodgerblue", "Dodger-Blau"),
              new ColorResourceInfo(XKnownColor.DeepSkyBlue, XColors.DeepSkyBlue, 0xFF00BFFF, "Deepskyblue", "Tiefes Himmelblau"),
              new ColorResourceInfo(XKnownColor.LightSkyBlue, XColors.LightSkyBlue, 0xFF87CEFA, "Lightskyblue", "Helles Himmelblau"),
              new ColorResourceInfo(XKnownColor.SkyBlue, XColors.SkyBlue, 0xFF87CEEB, "Skyblue", "Himmelblau"),
              new ColorResourceInfo(XKnownColor.LightBlue, XColors.LightBlue, 0xFFADD8E6, "Lightblue", "Hellblau"),
              new ColorResourceInfo(XKnownColor.Cyan, XColors.Cyan, 0xFF00FFFF, "Cyan", "Zyan"),
              new ColorResourceInfo(XKnownColor.PowderBlue, XColors.PowderBlue, 0xFFB0E0E6, "Powderblue", "Taubenblau"),
              new ColorResourceInfo(XKnownColor.LightCyan, XColors.LightCyan, 0xFFE0FFFF, "Lightcyan", "Helles Cyanblau"),
              new ColorResourceInfo(XKnownColor.AliceBlue, XColors.AliceBlue, 0xFFA0CE00, "Aliceblue", "Aliceblau"),
              new ColorResourceInfo(XKnownColor.Azure, XColors.Azure, 0xFFF0FFFF, "Azure", "Himmelblau"),
              new ColorResourceInfo(XKnownColor.MintCream, XColors.MintCream, 0xFFF5FFFA, "Mintcream", "Helles Pfefferminzgrün"),
              new ColorResourceInfo(XKnownColor.Honeydew, XColors.Honeydew, 0xFFF0FFF0, "Honeydew", "Honigmelone"),
              new ColorResourceInfo(XKnownColor.Aquamarine, XColors.Aquamarine, 0xFF7FFFD4, "Aquamarine", "Aquamarinblau"),
              new ColorResourceInfo(XKnownColor.Turquoise, XColors.Turquoise, 0xFF40E0D0, "Turquoise", "Türkis"),
              new ColorResourceInfo(XKnownColor.MediumTurquoise, XColors.MediumTurquoise, 0xFF48D1CC, "Mediumturqoise", "Mittleres Türkis"),
              new ColorResourceInfo(XKnownColor.DarkTurquoise, XColors.DarkTurquoise, 0xFF00CED1, "Darkturquoise", "Dunkles Türkis"),
              new ColorResourceInfo(XKnownColor.MediumAquamarine, XColors.MediumAquamarine, 0xFF66CDAA, "Mediumaquamarine", "Mittleres Aquamarinblau"),
              new ColorResourceInfo(XKnownColor.LightSeaGreen, XColors.LightSeaGreen, 0xFF20B2AA, "Lightseagreen", "Helles Seegrün"),
              new ColorResourceInfo(XKnownColor.DarkCyan, XColors.DarkCyan, 0xFF008B8B, "Darkcyan", "Dunkles Zyanblau"),
              new ColorResourceInfo(XKnownColor.Teal, XColors.Teal, 0xFF008080, "Teal", "Entenblau"),
              new ColorResourceInfo(XKnownColor.CadetBlue, XColors.CadetBlue, 0xFF5F9EA0, "Cadetblue", "Kadettblau"),
              new ColorResourceInfo(XKnownColor.MediumSeaGreen, XColors.MediumSeaGreen, 0xFF3CB371, "Mediumseagreen", "Mittleres Seegrün"),
              new ColorResourceInfo(XKnownColor.DarkSeaGreen, XColors.DarkSeaGreen, 0xFF8FBC8F, "Darkseagreen", "Dunkles Seegrün"),
              new ColorResourceInfo(XKnownColor.LightGreen, XColors.LightGreen, 0xFF90EE90, "Lightgreen", "Hellgrün"),
              new ColorResourceInfo(XKnownColor.PaleGreen, XColors.PaleGreen, 0xFF98FB98, "Palegreen", "Blassgrün"),
              new ColorResourceInfo(XKnownColor.MediumSpringGreen, XColors.MediumSpringGreen, 0xFF00FA9A, "Mediumspringgreen", "Mittleres Frühlingsgrün"),
              new ColorResourceInfo(XKnownColor.SpringGreen, XColors.SpringGreen, 0xFF00FF7F, "Springgreen", "Frühlingsgrün"),
              new ColorResourceInfo(XKnownColor.Lime, XColors.Lime, 0xFF00FF00, "Lime", "Zitronengrün"),
              new ColorResourceInfo(XKnownColor.LimeGreen, XColors.LimeGreen, 0xFF32CD32, "Limegreen", "Gelbgrün"),
              new ColorResourceInfo(XKnownColor.SeaGreen, XColors.SeaGreen, 0xFF2E8B57, "Seagreen", "Seegrün"),
              new ColorResourceInfo(XKnownColor.ForestGreen, XColors.ForestGreen, 0xFF228B22, "Forestgreen", "Waldgrün"),
              new ColorResourceInfo(XKnownColor.Green, XColors.Green, 0xFF008000, "Green", "Grün"),
              new ColorResourceInfo(XKnownColor.LawnGreen, XColors.LawnGreen, 0xFF008000, "LawnGreen", "Grasgrün"),
              new ColorResourceInfo(XKnownColor.DarkGreen, XColors.DarkGreen, 0xFF006400, "Darkgreen", "Dunkelgrün"),
              new ColorResourceInfo(XKnownColor.OliveDrab, XColors.OliveDrab, 0xFF6B8E23, "Olivedrab", "Reife Olive"),
              new ColorResourceInfo(XKnownColor.DarkOliveGreen, XColors.DarkOliveGreen, 0xFF556B2F, "Darkolivegreen", "Dunkles Olivgrün"),
              new ColorResourceInfo(XKnownColor.Olive, XColors.Olive, 0xFF808000, "Olive", "Olivgrün"),
              new ColorResourceInfo(XKnownColor.DarkKhaki, XColors.DarkKhaki, 0xFFBDB76B, "Darkkhaki", "Dunkles Khaki"),
              new ColorResourceInfo(XKnownColor.YellowGreen, XColors.YellowGreen, 0xFF9ACD32, "Yellowgreen", "Gelbgrün"),
              new ColorResourceInfo(XKnownColor.Chartreuse, XColors.Chartreuse, 0xFF7FFF00, "Chartreuse", "Hellgrün"),
              new ColorResourceInfo(XKnownColor.GreenYellow, XColors.GreenYellow, 0xFFADFF2F, "Greenyellow", "Grüngelb"),
            };

        internal struct ColorResourceInfo
        {
            public ColorResourceInfo(XKnownColor knownColor, XColor color, uint argb, string name, string nameDE)
            {
                KnownColor = knownColor;
                Color = color;
                Argb = argb;
                Name = name;
                NameDE = nameDE;
            }
            public XKnownColor KnownColor;
            public XColor Color;
            public uint Argb;
            public string Name;
            public string NameDE;
        }
    }
    public static class XColors
    {
        public static XColor AliceBlue { get { return new XColor(XKnownColor.AliceBlue); } }

        public static XColor AntiqueWhite { get { return new XColor(XKnownColor.AntiqueWhite); } }

        public static XColor Aqua { get { return new XColor(XKnownColor.Aqua); } }

        public static XColor Aquamarine { get { return new XColor(XKnownColor.Aquamarine); } }

        public static XColor Azure { get { return new XColor(XKnownColor.Azure); } }

        public static XColor Beige { get { return new XColor(XKnownColor.Beige); } }

        public static XColor Bisque { get { return new XColor(XKnownColor.Bisque); } }

        public static XColor Black { get { return new XColor(XKnownColor.Black); } }

        public static XColor BlanchedAlmond { get { return new XColor(XKnownColor.BlanchedAlmond); } }

        public static XColor Blue { get { return new XColor(XKnownColor.Blue); } }

        public static XColor BlueViolet { get { return new XColor(XKnownColor.BlueViolet); } }

        public static XColor Brown { get { return new XColor(XKnownColor.Brown); } }

        public static XColor BurlyWood { get { return new XColor(XKnownColor.BurlyWood); } }

        public static XColor CadetBlue { get { return new XColor(XKnownColor.CadetBlue); } }

        public static XColor Chartreuse { get { return new XColor(XKnownColor.Chartreuse); } }

        public static XColor Chocolate { get { return new XColor(XKnownColor.Chocolate); } }

        public static XColor Coral { get { return new XColor(XKnownColor.Coral); } }

        public static XColor CornflowerBlue { get { return new XColor(XKnownColor.CornflowerBlue); } }

        public static XColor Cornsilk { get { return new XColor(XKnownColor.Cornsilk); } }

        public static XColor Crimson { get { return new XColor(XKnownColor.Crimson); } }

        public static XColor Cyan { get { return new XColor(XKnownColor.Cyan); } }

        public static XColor DarkBlue { get { return new XColor(XKnownColor.DarkBlue); } }

        public static XColor DarkCyan { get { return new XColor(XKnownColor.DarkCyan); } }

        public static XColor DarkGoldenrod { get { return new XColor(XKnownColor.DarkGoldenrod); } }

        public static XColor DarkGray { get { return new XColor(XKnownColor.DarkGray); } }

        public static XColor DarkGreen { get { return new XColor(XKnownColor.DarkGreen); } }

        public static XColor DarkKhaki { get { return new XColor(XKnownColor.DarkKhaki); } }

        public static XColor DarkMagenta { get { return new XColor(XKnownColor.DarkMagenta); } }

        public static XColor DarkOliveGreen { get { return new XColor(XKnownColor.DarkOliveGreen); } }

        public static XColor DarkOrange { get { return new XColor(XKnownColor.DarkOrange); } }

        public static XColor DarkOrchid { get { return new XColor(XKnownColor.DarkOrchid); } }

        public static XColor DarkRed { get { return new XColor(XKnownColor.DarkRed); } }

        public static XColor DarkSalmon { get { return new XColor(XKnownColor.DarkSalmon); } }

        public static XColor DarkSeaGreen { get { return new XColor(XKnownColor.DarkSeaGreen); } }

        public static XColor DarkSlateBlue { get { return new XColor(XKnownColor.DarkSlateBlue); } }

        public static XColor DarkSlateGray { get { return new XColor(XKnownColor.DarkSlateGray); } }

        public static XColor DarkTurquoise { get { return new XColor(XKnownColor.DarkTurquoise); } }

        public static XColor DarkViolet { get { return new XColor(XKnownColor.DarkViolet); } }

        public static XColor DeepPink { get { return new XColor(XKnownColor.DeepPink); } }

        public static XColor DeepSkyBlue { get { return new XColor(XKnownColor.DeepSkyBlue); } }

        public static XColor DimGray { get { return new XColor(XKnownColor.DimGray); } }

        public static XColor DodgerBlue { get { return new XColor(XKnownColor.DodgerBlue); } }

        public static XColor Firebrick { get { return new XColor(XKnownColor.Firebrick); } }

        public static XColor FloralWhite { get { return new XColor(XKnownColor.FloralWhite); } }

        public static XColor ForestGreen { get { return new XColor(XKnownColor.ForestGreen); } }

        public static XColor Fuchsia { get { return new XColor(XKnownColor.Fuchsia); } }

        public static XColor Gainsboro { get { return new XColor(XKnownColor.Gainsboro); } }

        public static XColor GhostWhite { get { return new XColor(XKnownColor.GhostWhite); } }

        public static XColor Gold { get { return new XColor(XKnownColor.Gold); } }

        public static XColor Goldenrod { get { return new XColor(XKnownColor.Goldenrod); } }

        public static XColor Gray { get { return new XColor(XKnownColor.Gray); } }

        public static XColor Green { get { return new XColor(XKnownColor.Green); } }

        public static XColor GreenYellow { get { return new XColor(XKnownColor.GreenYellow); } }

        public static XColor Honeydew { get { return new XColor(XKnownColor.Honeydew); } }

        public static XColor HotPink { get { return new XColor(XKnownColor.HotPink); } }

        public static XColor IndianRed { get { return new XColor(XKnownColor.IndianRed); } }

        public static XColor Indigo { get { return new XColor(XKnownColor.Indigo); } }

        public static XColor Ivory { get { return new XColor(XKnownColor.Ivory); } }

        public static XColor Khaki { get { return new XColor(XKnownColor.Khaki); } }

        public static XColor Lavender { get { return new XColor(XKnownColor.Lavender); } }

        public static XColor LavenderBlush { get { return new XColor(XKnownColor.LavenderBlush); } }

        public static XColor LawnGreen { get { return new XColor(XKnownColor.LawnGreen); } }

        public static XColor LemonChiffon { get { return new XColor(XKnownColor.LemonChiffon); } }

        public static XColor LightBlue { get { return new XColor(XKnownColor.LightBlue); } }

        public static XColor LightCoral { get { return new XColor(XKnownColor.LightCoral); } }

        public static XColor LightCyan { get { return new XColor(XKnownColor.LightCyan); } }

        public static XColor LightGoldenrodYellow { get { return new XColor(XKnownColor.LightGoldenrodYellow); } }

        public static XColor LightGray { get { return new XColor(XKnownColor.LightGray); } }

        public static XColor LightGreen { get { return new XColor(XKnownColor.LightGreen); } }

        public static XColor LightPink { get { return new XColor(XKnownColor.LightPink); } }

        public static XColor LightSalmon { get { return new XColor(XKnownColor.LightSalmon); } }

        public static XColor LightSeaGreen { get { return new XColor(XKnownColor.LightSeaGreen); } }

        public static XColor LightSkyBlue { get { return new XColor(XKnownColor.LightSkyBlue); } }

        public static XColor LightSlateGray { get { return new XColor(XKnownColor.LightSlateGray); } }

        public static XColor LightSteelBlue { get { return new XColor(XKnownColor.LightSteelBlue); } }

        public static XColor LightYellow { get { return new XColor(XKnownColor.LightYellow); } }

        public static XColor Lime { get { return new XColor(XKnownColor.Lime); } }

        public static XColor LimeGreen { get { return new XColor(XKnownColor.LimeGreen); } }

        public static XColor Linen { get { return new XColor(XKnownColor.Linen); } }

        public static XColor Magenta { get { return new XColor(XKnownColor.Magenta); } }

        public static XColor Maroon { get { return new XColor(XKnownColor.Maroon); } }

        public static XColor MediumAquamarine { get { return new XColor(XKnownColor.MediumAquamarine); } }

        public static XColor MediumBlue { get { return new XColor(XKnownColor.MediumBlue); } }

        public static XColor MediumOrchid { get { return new XColor(XKnownColor.MediumOrchid); } }

        public static XColor MediumPurple { get { return new XColor(XKnownColor.MediumPurple); } }

        public static XColor MediumSeaGreen { get { return new XColor(XKnownColor.MediumSeaGreen); } }

        public static XColor MediumSlateBlue { get { return new XColor(XKnownColor.MediumSlateBlue); } }

        public static XColor MediumSpringGreen { get { return new XColor(XKnownColor.MediumSpringGreen); } }

        public static XColor MediumTurquoise { get { return new XColor(XKnownColor.MediumTurquoise); } }

        public static XColor MediumVioletRed { get { return new XColor(XKnownColor.MediumVioletRed); } }

        public static XColor MidnightBlue { get { return new XColor(XKnownColor.MidnightBlue); } }

        public static XColor MintCream { get { return new XColor(XKnownColor.MintCream); } }

        public static XColor MistyRose { get { return new XColor(XKnownColor.MistyRose); } }

        public static XColor Moccasin { get { return new XColor(XKnownColor.Moccasin); } }

        public static XColor NavajoWhite { get { return new XColor(XKnownColor.NavajoWhite); } }

        public static XColor Navy { get { return new XColor(XKnownColor.Navy); } }

        public static XColor OldLace { get { return new XColor(XKnownColor.OldLace); } }

        public static XColor Olive { get { return new XColor(XKnownColor.Olive); } }

        public static XColor OliveDrab { get { return new XColor(XKnownColor.OliveDrab); } }

        public static XColor Orange { get { return new XColor(XKnownColor.Orange); } }

        public static XColor OrangeRed { get { return new XColor(XKnownColor.OrangeRed); } }

        public static XColor Orchid { get { return new XColor(XKnownColor.Orchid); } }

        public static XColor PaleGoldenrod { get { return new XColor(XKnownColor.PaleGoldenrod); } }

        public static XColor PaleGreen { get { return new XColor(XKnownColor.PaleGreen); } }

        public static XColor PaleTurquoise { get { return new XColor(XKnownColor.PaleTurquoise); } }

        public static XColor PaleVioletRed { get { return new XColor(XKnownColor.PaleVioletRed); } }

        public static XColor PapayaWhip { get { return new XColor(XKnownColor.PapayaWhip); } }

        public static XColor PeachPuff { get { return new XColor(XKnownColor.PeachPuff); } }

        public static XColor Peru { get { return new XColor(XKnownColor.Peru); } }

        public static XColor Pink { get { return new XColor(XKnownColor.Pink); } }

        public static XColor Plum { get { return new XColor(XKnownColor.Plum); } }

        public static XColor PowderBlue { get { return new XColor(XKnownColor.PowderBlue); } }

        public static XColor Purple { get { return new XColor(XKnownColor.Purple); } }

        public static XColor Red { get { return new XColor(XKnownColor.Red); } }

        public static XColor RosyBrown { get { return new XColor(XKnownColor.RosyBrown); } }

        public static XColor RoyalBlue { get { return new XColor(XKnownColor.RoyalBlue); } }

        public static XColor SaddleBrown { get { return new XColor(XKnownColor.SaddleBrown); } }

        public static XColor Salmon { get { return new XColor(XKnownColor.Salmon); } }

        public static XColor SandyBrown { get { return new XColor(XKnownColor.SandyBrown); } }

        public static XColor SeaGreen { get { return new XColor(XKnownColor.SeaGreen); } }

        public static XColor SeaShell { get { return new XColor(XKnownColor.SeaShell); } }

        public static XColor Sienna { get { return new XColor(XKnownColor.Sienna); } }

        public static XColor Silver { get { return new XColor(XKnownColor.Silver); } }

        public static XColor SkyBlue { get { return new XColor(XKnownColor.SkyBlue); } }

        public static XColor SlateBlue { get { return new XColor(XKnownColor.SlateBlue); } }

        public static XColor SlateGray { get { return new XColor(XKnownColor.SlateGray); } }

        public static XColor Snow { get { return new XColor(XKnownColor.Snow); } }

        public static XColor SpringGreen { get { return new XColor(XKnownColor.SpringGreen); } }

        public static XColor SteelBlue { get { return new XColor(XKnownColor.SteelBlue); } }

        public static XColor Tan { get { return new XColor(XKnownColor.Tan); } }

        public static XColor Teal { get { return new XColor(XKnownColor.Teal); } }

        public static XColor Thistle { get { return new XColor(XKnownColor.Thistle); } }

        public static XColor Tomato { get { return new XColor(XKnownColor.Tomato); } }

        public static XColor Transparent { get { return new XColor(XKnownColor.Transparent); } }

        public static XColor Turquoise { get { return new XColor(XKnownColor.Turquoise); } }

        public static XColor Violet { get { return new XColor(XKnownColor.Violet); } }

        public static XColor Wheat { get { return new XColor(XKnownColor.Wheat); } }

        public static XColor White { get { return new XColor(XKnownColor.White); } }

        public static XColor WhiteSmoke { get { return new XColor(XKnownColor.WhiteSmoke); } }

        public static XColor Yellow { get { return new XColor(XKnownColor.Yellow); } }

        public static XColor YellowGreen { get { return new XColor(XKnownColor.YellowGreen); } }
    }
    public sealed class XFont
    {
        public XFont(string familyName, double emSize)
            : this(familyName, emSize, XFontStyle.Regular, new XPdfFontOptions(GlobalFontSettings.DefaultFontEncoding))
        { }

        public XFont(string familyName, double emSize, XFontStyle style)
            : this(familyName, emSize, style, new XPdfFontOptions(GlobalFontSettings.DefaultFontEncoding))
        { }

        public XFont(string familyName, double emSize, XFontStyle style, XPdfFontOptions pdfOptions)
        {
            _familyName = familyName;
            _emSize = emSize;
            _style = style;
            _pdfOptions = pdfOptions;
            Initialize();
        }

        internal XFont(string familyName, double emSize, XFontStyle style, XPdfFontOptions pdfOptions, XStyleSimulations styleSimulations)
        {
            _familyName = familyName;
            _emSize = emSize;
            _style = style;
            _pdfOptions = pdfOptions;
            OverrideStyleSimulations = true;
            StyleSimulations = styleSimulations;
            Initialize();
        }

#if CORE || GDI
        public XFont(GdiFontFamily fontFamily, double emSize, XFontStyle style)
            : this(fontFamily, emSize, style, new XPdfFontOptions(GlobalFontSettings.DefaultFontEncoding))
        { }

        public XFont(GdiFontFamily fontFamily, double emSize, XFontStyle style, XPdfFontOptions pdfOptions)
        {
            _familyName = fontFamily.Name;
            _gdiFontFamily = fontFamily;
            _emSize = emSize;
            _style = style;
            _pdfOptions = pdfOptions;
            InitializeFromGdi();
        }

        public XFont(GdiFont font)
            : this(font, new XPdfFontOptions(GlobalFontSettings.DefaultFontEncoding))
        { }

        public XFont(GdiFont font, XPdfFontOptions pdfOptions)
        {
            if (font.Unit != GraphicsUnit.World)
                throw new ArgumentException("Font must use GraphicsUnit.World.");
            _gdiFont = font;
            Debug.Assert(font.Name == font.FontFamily.Name);
            _familyName = font.Name;
            _emSize = font.Size;
            _style = FontStyleFrom(font);
            _pdfOptions = pdfOptions;
            InitializeFromGdi();
        }
#endif

        void Initialize()
        {
            FontResolvingOptions fontResolvingOptions = OverrideStyleSimulations
                ? new FontResolvingOptions(_style, StyleSimulations)
                : new FontResolvingOptions(_style);

            if (StringComparer.OrdinalIgnoreCase.Compare(_familyName, GlobalFontSettings.DefaultFontName) == 0)
            {
#if CORE || GDI || WPF
                _familyName = "Calibri";
#endif
            }

            _glyphTypeface = XGlyphTypeface.GetOrCreateFrom(_familyName, fontResolvingOptions);

            CreateDescriptorAndInitializeFontMetrics();
        }

#if CORE || GDI
        void InitializeFromGdi()
        {
            try
            {
                Lock.EnterFontFactory();
                if (_gdiFontFamily != null)
                {
                    _gdiFont = new Font(_gdiFontFamily, (float)_emSize, (GdiFontStyle)_style, GraphicsUnit.World);
                }

                if (_gdiFont != null)
                {

                    _familyName = _gdiFont.FontFamily.Name;
                }
                else
                {
                    Debug.Assert(false);
                }

                if (_glyphTypeface == null)
                    _glyphTypeface = XGlyphTypeface.GetOrCreateFromGdi(_gdiFont);

                CreateDescriptorAndInitializeFontMetrics();
            }
            finally { Lock.ExitFontFactory(); }
        }
#endif

        void CreateDescriptorAndInitializeFontMetrics()
        {
            Debug.Assert(_fontMetrics == null, "InitializeFontMetrics() was already called.");
            _descriptor = (OpenTypeDescriptor)FontDescriptorCache.GetOrCreateDescriptorFor(this);
            _fontMetrics = new XFontMetrics(_descriptor.FontName, _descriptor.UnitsPerEm, _descriptor.Ascender, _descriptor.Descender,
                _descriptor.Leading, _descriptor.LineSpacing, _descriptor.CapHeight, _descriptor.XHeight, _descriptor.StemV, 0, 0, 0,
                _descriptor.UnderlinePosition, _descriptor.UnderlineThickness, _descriptor.StrikeoutPosition, _descriptor.StrikeoutSize);

            XFontMetrics fm = Metrics;

            UnitsPerEm = _descriptor.UnitsPerEm;
            CellAscent = _descriptor.Ascender;
            CellDescent = _descriptor.Descender;
            CellSpace = _descriptor.LineSpacing;

            Debug.Assert(fm.UnitsPerEm == _descriptor.UnitsPerEm);
        }




        [Browsable(false)]
        public XFontFamily FontFamily
        {
            get { return _glyphTypeface.FontFamily; }
        }

        public string Name
        {
            get { return _glyphTypeface.FontFamily.Name; }
        }

        internal string FaceName
        {
            get { return _glyphTypeface.FaceName; }
        }

        public double Size
        {
            get { return _emSize; }
        }
        readonly double _emSize;

        [Browsable(false)]
        public XFontStyle Style
        {
            get { return _style; }
        }
        readonly XFontStyle _style;

        public bool Bold
        {
            get { return (_style & XFontStyle.Bold) == XFontStyle.Bold; }
        }

        public bool Italic
        {
            get { return (_style & XFontStyle.Italic) == XFontStyle.Italic; }
        }

        public bool Strikeout
        {
            get { return (_style & XFontStyle.Strikeout) == XFontStyle.Strikeout; }
        }

        public bool Underline
        {
            get { return (_style & XFontStyle.Underline) == XFontStyle.Underline; }
        }

        internal bool IsVertical
        {
            get { return _isVertical; }
            set { _isVertical = value; }
        }
        bool _isVertical;


        public XPdfFontOptions PdfOptions
        {
            get { return _pdfOptions ?? (_pdfOptions = new XPdfFontOptions()); }
        }
        XPdfFontOptions _pdfOptions;

        internal bool Unicode
        {
            get { return _pdfOptions != null && _pdfOptions.FontEncoding == PdfFontEncoding.Unicode; }
        }

        public int CellSpace
        {
            get { return _cellSpace; }
            internal set { _cellSpace = value; }
        }
        int _cellSpace;

        public int CellAscent
        {
            get { return _cellAscent; }
            internal set { _cellAscent = value; }
        }
        int _cellAscent;

        public int CellDescent
        {
            get { return _cellDescent; }
            internal set { _cellDescent = value; }
        }
        int _cellDescent;

        public XFontMetrics Metrics
        {
            get
            {
                Debug.Assert(_fontMetrics != null, "InitializeFontMetrics() not yet called.");
                return _fontMetrics;
            }
        }
        XFontMetrics _fontMetrics;

        public double GetHeight()
        {
            double value = CellSpace * _emSize / UnitsPerEm;
#if CORE || NETFX_CORE || UWP
            return value;
#endif
        }

        [Obsolete("Use GetHeight() without parameter.")]
        public double GetHeight(XGraphics graphics)
        {
#if true
            throw new InvalidOperationException("Honestly: Use GetHeight() without parameter!");
#else

#endif
        }

        [Browsable(false)]
        public int Height
        {
            get { return (int)Math.Ceiling(GetHeight()); }
        }

        internal XGlyphTypeface GlyphTypeface
        {
            get { return _glyphTypeface; }
        }
        XGlyphTypeface _glyphTypeface;


        internal OpenTypeDescriptor Descriptor
        {
            get { return _descriptor; }
            private set { _descriptor = value; }
        }
        OpenTypeDescriptor _descriptor;


        internal string FamilyName
        {
            get { return _familyName; }
        }
        string _familyName;


        internal int UnitsPerEm
        {
            get { return _unitsPerEm; }
            private set { _unitsPerEm = value; }
        }
        internal int _unitsPerEm;

        internal bool OverrideStyleSimulations;

        internal XStyleSimulations StyleSimulations;


#if CORE || GDI
        public GdiFontFamily GdiFontFamily
        {
            get { return _gdiFontFamily; }
        }
        readonly GdiFontFamily _gdiFontFamily;

        internal GdiFont GdiFont
        {
            get { return _gdiFont; }
        }
        Font _gdiFont;

        internal static XFontStyle FontStyleFrom(GdiFont font)
        {
            return
              (font.Bold ? XFontStyle.Bold : 0) |
              (font.Italic ? XFontStyle.Italic : 0) |
              (font.Strikeout ? XFontStyle.Strikeout : 0) |
              (font.Underline ? XFontStyle.Underline : 0);
        }

#if true || UseGdiObjects
        public static implicit operator XFont(GdiFont font)
        {
            return new XFont(font);
        }
#endif
#endif
        internal string Selector
        {
            get { return _selector; }
            set { _selector = value; }
        }
        string _selector;

        string DebuggerDisplay
        {
            get { return String.Format(CultureInfo.InvariantCulture, "font=('{0}' {1:0.##})", Name, Size); }
        }
    }
    public sealed class XFontFamily
    {
        public XFontFamily(string familyName)
        {
            FamilyInternal = FontFamilyInternal.GetOrCreateFromName(familyName, true);
        }

        internal XFontFamily(string familyName, bool createPlatformObjects)
        {
            FamilyInternal = FontFamilyInternal.GetOrCreateFromName(familyName, createPlatformObjects);
        }

        XFontFamily(FontFamilyInternal fontFamilyInternal)
        {
            FamilyInternal = fontFamilyInternal;
        }


        internal static XFontFamily CreateFromName_not_used(string name, bool createPlatformFamily)
        {
            XFontFamily fontFamily = new XFontFamily(name);
            if (createPlatformFamily)
            {

            }
            return fontFamily;
        }

        internal static XFontFamily GetOrCreateFontFamily(string name)
        {
            FontFamilyInternal fontFamilyInternal = FontFamilyCache.GetFamilyByName(name);
            if (fontFamilyInternal == null)
            {
                fontFamilyInternal = FontFamilyInternal.GetOrCreateFromName(name, false);
                fontFamilyInternal = FontFamilyCache.CacheOrGetFontFamily(fontFamilyInternal);
            }

            return new XFontFamily(fontFamilyInternal);
        }

#if CORE || GDI
        internal static XFontFamily GetOrCreateFromGdi(GdiFont font)
        {
            FontFamilyInternal fontFamilyInternal = FontFamilyInternal.GetOrCreateFromGdi(font.FontFamily);
            return new XFontFamily(fontFamilyInternal);
        }
#endif


        public string Name
        {
            get { return FamilyInternal.Name; }
        }

        public int GetCellAscent(XFontStyle style)
        {
            OpenTypeDescriptor descriptor = (OpenTypeDescriptor)FontDescriptorCache.GetOrCreateDescriptor(Name, style);
            int result = descriptor.Ascender;
            return result;
        }

        public int GetCellDescent(XFontStyle style)
        {
            OpenTypeDescriptor descriptor = (OpenTypeDescriptor)FontDescriptorCache.GetOrCreateDescriptor(Name, style);
            int result = descriptor.Descender;
            return result;
        }

        public int GetEmHeight(XFontStyle style)
        {
            OpenTypeDescriptor descriptor = (OpenTypeDescriptor)FontDescriptorCache.GetOrCreateDescriptor(Name, style);
            int result = descriptor.UnitsPerEm;
            return result;
        }

        public int GetLineSpacing(XFontStyle style)
        {
            OpenTypeDescriptor descriptor = (OpenTypeDescriptor)FontDescriptorCache.GetOrCreateDescriptor(Name, style);
            int result = descriptor.LineSpacing;
            return result;
        }

        public bool IsStyleAvailable(XFontStyle style)
        {
            XGdiFontStyle xStyle = ((XGdiFontStyle)style) & XGdiFontStyle.BoldItalic;
#if CORE
            throw new InvalidOperationException("In CORE build it is the responsibility of the developer to provide all required font faces.");
#endif
        }

        [Obsolete("Use platform API directly.")]
        public static XFontFamily[] Families
        {
            get
            {
                throw new InvalidOperationException("Obsolete and not implemted any more.");
            }
        }

        [Obsolete("Use platform API directly.")]
        public static XFontFamily[] GetFamilies(XGraphics graphics)
        {
            throw new InvalidOperationException("Obsolete and not implemted any more.");
        }
        internal FontFamilyInternal FamilyInternal;
    }
    public sealed class XFontMetrics
    {
        internal XFontMetrics(string name, int unitsPerEm, int ascent, int descent, int leading, int lineSpacing,
            int capHeight, int xHeight, int stemV, int stemH, int averageWidth, int maxWidth,
            int underlinePosition, int underlineThickness, int strikethroughPosition, int strikethroughThickness)
        {
            _name = name;
            _unitsPerEm = unitsPerEm;
            _ascent = ascent;
            _descent = descent;
            _leading = leading;
            _lineSpacing = lineSpacing;
            _capHeight = capHeight;
            _xHeight = xHeight;
            _stemV = stemV;
            _stemH = stemH;
            _averageWidth = averageWidth;
            _maxWidth = maxWidth;
            _underlinePosition = underlinePosition;
            _underlineThickness = underlineThickness;
            _strikethroughPosition = strikethroughPosition;
            _strikethroughThickness = strikethroughThickness;
        }

        public string Name
        {
            get { return _name; }
        }
        readonly string _name;

        public int UnitsPerEm
        {
            get { return _unitsPerEm; }
        }
        readonly int _unitsPerEm;

        public int Ascent
        {
            get { return _ascent; }
        }
        readonly int _ascent;

        public int Descent
        {
            get { return _descent; }
        }
        readonly int _descent;

        public int AverageWidth
        {
            get { return _averageWidth; }
        }
        readonly int _averageWidth;

        public int CapHeight
        {
            get { return _capHeight; }
        }
        readonly int _capHeight;

        public int Leading
        {
            get { return _leading; }
        }
        readonly int _leading;

        public int LineSpacing
        {
            get { return _lineSpacing; }
        }
        readonly int _lineSpacing;

        public int MaxWidth
        {
            get { return _maxWidth; }
        }
        readonly int _maxWidth;

        public int StemH
        {
            get { return _stemH; }
        }
        readonly int _stemH;

        public int StemV
        {
            get { return _stemV; }
        }
        readonly int _stemV;

        public int XHeight
        {
            get { return _xHeight; }
        }
        readonly int _xHeight;

        public int UnderlinePosition
        {
            get { return _underlinePosition; }
        }
        readonly int _underlinePosition;

        public int UnderlineThickness
        {
            get { return _underlineThickness; }
        }
        readonly int _underlineThickness;

        public int StrikethroughPosition
        {
            get { return _strikethroughPosition; }
        }
        readonly int _strikethroughPosition;

        public int StrikethroughThickness
        {
            get { return _strikethroughThickness; }
        }
        readonly int _strikethroughThickness;
    }
    internal class XFontSource
    {
        const uint ttcf = 0x66637474;

        XFontSource(byte[] bytes, ulong key)
        {
            _fontName = null;
            _bytes = bytes;
            _key = key;
        }

        public static XFontSource GetOrCreateFrom(byte[] bytes)
        {
            ulong key = FontHelper.CalcChecksum(bytes);
            XFontSource fontSource;
            if (!FontFactory.TryGetFontSourceByKey(key, out fontSource))
            {
                fontSource = new XFontSource(bytes, key);
                fontSource = FontFactory.CacheFontSource(fontSource);
            }
            return fontSource;
        }

#if CORE || GDI
        internal static XFontSource GetOrCreateFromGdi(string typefaceKey, GdiFont gdiFont)
        {
            byte[] bytes = ReadFontBytesFromGdi(gdiFont);
            XFontSource fontSource = GetOrCreateFrom(typefaceKey, bytes);
            return fontSource;
        }

        static byte[] ReadFontBytesFromGdi(GdiFont gdiFont)
        {
            int error = Marshal.GetLastWin32Error();
            error = Marshal.GetLastWin32Error();
            IntPtr hfont = gdiFont.ToHfont();
#if true
            IntPtr hdc = NativeMethods.GetDC(IntPtr.Zero);
#endif
            error = Marshal.GetLastWin32Error();
            IntPtr oldFont = NativeMethods.SelectObject(hdc, hfont);
            error = Marshal.GetLastWin32Error();
            bool isTtcf = false;
            int size = NativeMethods.GetFontData(hdc, 0, 0, null, 0);

            if ((uint)size == 0xc0000022)
                throw new InvalidOperationException("Microsoft Azure returns STATUS_ACCESS_DENIED ((NTSTATUS)0xC0000022L) from GetFontData. This is a bug in Azure. You must implement a FontResolver to circumvent this issue.");

            if (size == NativeMethods.GDI_ERROR)
            {
                size = NativeMethods.GetFontData(hdc, ttcf, 0, null, 0);
                isTtcf = true;
            }
            error = Marshal.GetLastWin32Error();
            if (size == 0)
                throw new InvalidOperationException("Cannot retrieve font data.");

            byte[] bytes = new byte[size];
            int effectiveSize = NativeMethods.GetFontData(hdc, isTtcf ? ttcf : 0, 0, bytes, size);
            Debug.Assert(size == effectiveSize);
            NativeMethods.SelectObject(hdc, oldFont);
            NativeMethods.ReleaseDC(IntPtr.Zero, hdc);

            return bytes;
        }
#endif
        static XFontSource GetOrCreateFrom(string typefaceKey, byte[] fontBytes)
        {
            XFontSource fontSource;
            ulong key = FontHelper.CalcChecksum(fontBytes);
            if (FontFactory.TryGetFontSourceByKey(key, out fontSource))
            {
                FontFactory.CacheExistingFontSourceWithNewTypefaceKey(typefaceKey, fontSource);
            }
            else
            {
                fontSource = new XFontSource(fontBytes, key);
                FontFactory.CacheNewFontSource(typefaceKey, fontSource);
            }
            return fontSource;
        }

        public static XFontSource CreateCompiledFont(byte[] bytes)
        {
            XFontSource fontSource = new XFontSource(bytes, 0);
            return fontSource;
        }

        internal OpenTypeFontface Fontface
        {
            get { return _fontface; }
            set
            {
                _fontface = value;
                _fontName = value.name.FullFontName;
            }
        }
        OpenTypeFontface _fontface;

        internal ulong Key
        {
            get
            {
                if (_key == 0)
                    _key = FontHelper.CalcChecksum(Bytes);
                return _key;
            }
        }
        ulong _key;

        public void IncrementKey()
        {
            _key += 1ul << 32;
        }

        public string FontName
        {
            get { return _fontName; }
        }
        string _fontName;

        public byte[] Bytes
        {
            get { return _bytes; }
        }
        readonly byte[] _bytes;

        public override int GetHashCode()
        {
            return (int)((Key >> 32) ^ Key);
        }

        public override bool Equals(object obj)
        {
            XFontSource fontSource = obj as XFontSource;
            if (fontSource == null)
                return false;
            return Key == fontSource.Key;
        }

        internal string DebuggerDisplay
        {
            get { return String.Format(CultureInfo.InvariantCulture, "XFontSource: '{0}', keyhash={1}", FontName, Key % 99991); }
        }
    }
    enum FontWeightValues
    {
        Thin = 100,
        ExtraLight = 200,
        Light = 300,
        Normal = 400,
        Medium = 500,
        SemiBold = 600,
        Bold = 700,
        ExtraBold = 800,
        Black = 900,
        ExtraBlack = 950,
    }
    public class XForm : XImage, IContentStream
    {
        internal enum FormState
        {
            NotATemplate,

            Created,

            UnderConstruction,

            Finished,
        }

        protected XForm()
        { }


        public XForm(PdfDocument document, XRect viewBox)
        {
            if (viewBox.Width < 1 || viewBox.Height < 1)
                throw new ArgumentNullException("viewBox", "The size of the XPdfForm is to small.");
            if (document == null)
                throw new ArgumentNullException("document", "An XPdfForm template must be associated with a document at creation time.");

            _formState = FormState.Created;
            _document = document;
            _pdfForm = new PdfFormXObject(document, this);
            _viewBox = viewBox;
            PdfRectangle rect = new PdfRectangle(viewBox);
            _pdfForm.Elements.SetRectangle(PdfFormXObject.Keys.BBox, rect);
        }

        public XForm(PdfDocument document, XSize size)
            : this(document, new XRect(0, 0, size.Width, size.Height))
        {
        }

        public XForm(PdfDocument document, XUnit width, XUnit height)
            : this(document, new XRect(0, 0, width, height))
        { }

        public void DrawingFinished()
        {
            if (_formState == FormState.Finished)
                return;

            if (_formState == FormState.NotATemplate)
                throw new InvalidOperationException("This object is an imported PDF page and you cannot finish drawing on it because you must not draw on it at all.");

            Finish();
        }

        internal void AssociateGraphics(XGraphics gfx)
        {
            if (_formState == FormState.NotATemplate)
                throw new NotImplementedException("The current version of PDFsharp cannot draw on an imported page.");

            if (_formState == FormState.UnderConstruction)
                throw new InvalidOperationException("An XGraphics object already exists for this form.");

            if (_formState == FormState.Finished)
                throw new InvalidOperationException("After drawing a form it cannot be modified anymore.");

            Debug.Assert(_formState == FormState.Created);
            _formState = FormState.UnderConstruction;
            Gfx = gfx;
        }
        internal XGraphics Gfx;

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
        }

        internal virtual void Finish()
        {
        }

        internal PdfDocument Owner
        {
            get { return _document; }
        }
        PdfDocument _document;

        internal PdfColorMode ColorMode
        {
            get
            {
                if (_document == null)
                    return PdfColorMode.Undefined;
                return _document.Options.ColorMode;
            }
        }

        internal bool IsTemplate
        {
            get { return _formState != FormState.NotATemplate; }
        }
        internal FormState _formState;

        [Obsolete("Use either PixelWidth or PointWidth. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelWidth, but will become PointWidth in future releases of PDFsharp.")]
        public override double Width
        {
            get { return _viewBox.Width; }
        }

        [Obsolete("Use either PixelHeight or PointHeight. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelHeight, but will become PointHeight in future releases of PDFsharp.")]
        public override double Height
        {
            get { return _viewBox.Height; }
        }

        public override double PointWidth
        {
            get { return _viewBox.Width; }
        }

        public override double PointHeight
        {
            get { return _viewBox.Height; }
        }

        public override int PixelWidth
        {
            get { return (int)_viewBox.Width; }
        }

        public override int PixelHeight
        {
            get { return (int)_viewBox.Height; }
        }

        public override XSize Size
        {
            get { return _viewBox.Size; }
        }
        public XRect ViewBox
        {
            get { return _viewBox; }
        }
        XRect _viewBox;

        public override double HorizontalResolution
        {
            get { return 72; }
        }

        public override double VerticalResolution
        {
            get { return 72; }
        }

        public XRect BoundingBox
        {
            get { return _boundingBox; }
            set { _boundingBox = value; }
        }
        XRect _boundingBox;

        public virtual XMatrix Transform
        {
            get { return _transform; }
            set
            {
                if (_formState == FormState.Finished)
                    throw new InvalidOperationException("After a XPdfForm was once drawn it must not be modified.");
                _transform = value;
            }
        }
        internal XMatrix _transform;

        internal PdfResources Resources
        {
            get
            {
                Debug.Assert(IsTemplate, "This function is for form templates only.");
                return PdfForm.Resources;
            }
        }
        PdfResources IContentStream.Resources
        {
            get { return Resources; }
        }

        internal string GetFontName(XFont font, out PdfFont pdfFont)
        {
            Debug.Assert(IsTemplate, "This function is for form templates only.");
            pdfFont = _document.FontTable.GetFont(font);
            Debug.Assert(pdfFont != null);
            string name = Resources.AddFont(pdfFont);
            return name;
        }

        string IContentStream.GetFontName(XFont font, out PdfFont pdfFont)
        {
            return GetFontName(font, out pdfFont);
        }

        internal string TryGetFontName(string idName, out PdfFont pdfFont)
        {
            Debug.Assert(IsTemplate, "This function is for form templates only.");
            pdfFont = _document.FontTable.TryGetFont(idName);
            string name = null;
            if (pdfFont != null)
                name = Resources.AddFont(pdfFont);
            return name;
        }

        internal string GetFontName(string idName, byte[] fontData, out PdfFont pdfFont)
        {
            Debug.Assert(IsTemplate, "This function is for form templates only.");
            pdfFont = _document.FontTable.GetFont(idName, fontData);
            Debug.Assert(pdfFont != null);
            string name = Resources.AddFont(pdfFont);
            return name;
        }

        string IContentStream.GetFontName(string idName, byte[] fontData, out PdfFont pdfFont)
        {
            return GetFontName(idName, fontData, out pdfFont);
        }

        internal string GetImageName(XImage image)
        {
            Debug.Assert(IsTemplate, "This function is for form templates only.");
            PdfImage pdfImage = _document.ImageTable.GetImage(image);
            Debug.Assert(pdfImage != null);
            string name = Resources.AddImage(pdfImage);
            return name;
        }

        string IContentStream.GetImageName(XImage image)
        {
            return GetImageName(image);
        }

        internal PdfFormXObject PdfForm
        {
            get
            {
                Debug.Assert(IsTemplate, "This function is for form templates only.");
                if (_pdfForm.Reference == null)
                    _document._irefTable.Add(_pdfForm);
                return _pdfForm;
            }
        }

        internal string GetFormName(XForm form)
        {
            Debug.Assert(IsTemplate, "This function is for form templates only.");
            PdfFormXObject pdfForm = _document.FormTable.GetForm(form);
            Debug.Assert(pdfForm != null);
            string name = Resources.AddForm(pdfForm);
            return name;
        }

        string IContentStream.GetFormName(XForm form)
        {
            return GetFormName(form);
        }

        internal PdfFormXObject _pdfForm;

        internal XGraphicsPdfRenderer PdfRenderer;

    }
    internal sealed class XGlyphTypeface
    {
        const string KeyPrefix = "tk:";

#if CORE || GDI
        XGlyphTypeface(string key, XFontFamily fontFamily, XFontSource fontSource, XStyleSimulations styleSimulations, GdiFont gdiFont)
        {
            _key = key;
            _fontFamily = fontFamily;
            _fontSource = fontSource;

            _fontface = OpenTypeFontface.CetOrCreateFrom(fontSource);
            Debug.Assert(ReferenceEquals(_fontSource.Fontface, _fontface));

            _gdiFont = gdiFont;

            _styleSimulations = styleSimulations;
            Initialize();
        }
#endif
        public static XGlyphTypeface GetOrCreateFrom(string familyName, FontResolvingOptions fontResolvingOptions)
        {
            string typefaceKey = ComputeKey(familyName, fontResolvingOptions);
            XGlyphTypeface glyphTypeface;
            try
            {
                Lock.EnterFontFactory();
                if (GlyphTypefaceCache.TryGetGlyphTypeface(typefaceKey, out glyphTypeface))
                {
                    return glyphTypeface;
                }

                FontResolverInfo fontResolverInfo = FontFactory.ResolveTypeface(familyName, fontResolvingOptions, typefaceKey);
                if (fontResolverInfo == null)
                {
                    throw new InvalidOperationException("No appropriate font found.");
                }

#if CORE || GDI
                GdiFont gdiFont = null;
#endif
                XFontFamily fontFamily;
                PlatformFontResolverInfo platformFontResolverInfo = fontResolverInfo as PlatformFontResolverInfo;
                if (platformFontResolverInfo != null)
                {
#if CORE || GDI
                    gdiFont = platformFontResolverInfo.GdiFont;
                    fontFamily = XFontFamily.GetOrCreateFromGdi(gdiFont);
#endif
                }
                else
                {
                    fontFamily = XFontFamily.GetOrCreateFontFamily(familyName);
                }

                XFontSource fontSource = FontFactory.GetFontSourceByFontName(fontResolverInfo.FaceName);
                Debug.Assert(fontSource != null);

#if CORE || GDI
                glyphTypeface = new XGlyphTypeface(typefaceKey, fontFamily, fontSource, fontResolverInfo.StyleSimulations, gdiFont);
#endif
                GlyphTypefaceCache.AddGlyphTypeface(glyphTypeface);
            }
            finally { Lock.ExitFontFactory(); }
            return glyphTypeface;
        }

#if CORE || GDI
        public static XGlyphTypeface GetOrCreateFromGdi(GdiFont gdiFont)
        {
            string typefaceKey = ComputeKey(gdiFont);
            XGlyphTypeface glyphTypeface;
            if (GlyphTypefaceCache.TryGetGlyphTypeface(typefaceKey, out glyphTypeface))
            {
                return glyphTypeface;
            }

            XFontFamily fontFamily = XFontFamily.GetOrCreateFromGdi(gdiFont);
            XFontSource fontSource = XFontSource.GetOrCreateFromGdi(typefaceKey, gdiFont);

            XStyleSimulations styleSimulations = XStyleSimulations.None;
            if (gdiFont.Bold && !fontSource.Fontface.os2.IsBold)
                styleSimulations |= XStyleSimulations.BoldSimulation;
            if (gdiFont.Italic && !fontSource.Fontface.os2.IsItalic)
                styleSimulations |= XStyleSimulations.ItalicSimulation;

            glyphTypeface = new XGlyphTypeface(typefaceKey, fontFamily, fontSource, styleSimulations, gdiFont);
            GlyphTypefaceCache.AddGlyphTypeface(glyphTypeface);

            return glyphTypeface;
        }
#endif

        public XFontFamily FontFamily
        {
            get { return _fontFamily; }
        }
        readonly XFontFamily _fontFamily;

        internal OpenTypeFontface Fontface
        {
            get { return _fontface; }
        }
        readonly OpenTypeFontface _fontface;

        public XFontSource FontSource
        {
            get { return _fontSource; }
        }
        readonly XFontSource _fontSource;

        void Initialize()
        {
            _familyName = _fontface.name.Name;
            if (string.IsNullOrEmpty(_faceName) || _faceName.StartsWith("?"))
                _faceName = _familyName;
            _styleName = _fontface.name.Style;
            _displayName = _fontface.name.FullFontName;
            if (string.IsNullOrEmpty(_displayName))
            {
                _displayName = _familyName;
                if (string.IsNullOrEmpty(_styleName))
                    _displayName += " (" + _styleName + ")";
            }

            _isBold = _fontface.os2.IsBold;
            _isItalic = _fontface.os2.IsItalic;
        }

        internal string FaceName
        {
            get { return _faceName; }
        }
        string _faceName;

        public string FamilyName
        {
            get { return _familyName; }
        }
        string _familyName;

        public string StyleName
        {
            get { return _styleName; }
        }
        string _styleName;

        public string DisplayName
        {
            get { return _displayName; }
        }
        string _displayName;

        public bool IsBold
        {
            get { return _isBold; }
        }
        bool _isBold;

        public bool IsItalic
        {
            get { return _isItalic; }
        }
        bool _isItalic;

        public XStyleSimulations StyleSimulations
        {
            get { return _styleSimulations; }
        }
        XStyleSimulations _styleSimulations;

        string GetFaceNameSuffix()
        {
            if (IsBold)
                return IsItalic ? ",BoldItalic" : ",Bold";
            return IsItalic ? ",Italic" : "";
        }

        internal string GetBaseName()
        {
            string name = DisplayName;
            int ich = name.IndexOf("bold", StringComparison.OrdinalIgnoreCase);
            if (ich > 0)
                name = name.Substring(0, ich) + name.Substring(ich + 4, name.Length - ich - 4);
            ich = name.IndexOf("italic", StringComparison.OrdinalIgnoreCase);
            if (ich > 0)
                name = name.Substring(0, ich) + name.Substring(ich + 6, name.Length - ich - 6);
            name = name.Trim();
            name += GetFaceNameSuffix();
            return name;
        }

        internal static string ComputeKey(string familyName, FontResolvingOptions fontResolvingOptions)
        {
            string simulationSuffix = "";
            if (fontResolvingOptions.OverrideStyleSimulations)
            {
                switch (fontResolvingOptions.StyleSimulations)
                {
                    case XStyleSimulations.BoldSimulation: simulationSuffix = "|b+/i-"; break;
                    case XStyleSimulations.ItalicSimulation: simulationSuffix = "|b-/i+"; break;
                    case XStyleSimulations.BoldItalicSimulation: simulationSuffix = "|b+/i+"; break;
                    case XStyleSimulations.None: break;
                    default: throw new ArgumentOutOfRangeException("fontResolvingOptions");
                }
            }
            string key = KeyPrefix + familyName.ToLowerInvariant()
                + (fontResolvingOptions.IsItalic ? "/i" : "/n")
                + (fontResolvingOptions.IsBold ? "/700" : "/400") + "/5"
                + simulationSuffix;
            return key;
        }

        internal static string ComputeKey(string familyName, bool isBold, bool isItalic)
        {
            return ComputeKey(familyName, new FontResolvingOptions(FontHelper.CreateStyle(isBold, isItalic)));
        }

#if CORE || GDI
        internal static string ComputeKey(GdiFont gdiFont)
        {
            string name1 = gdiFont.Name;
            string name2 = gdiFont.OriginalFontName;
            string name3 = gdiFont.SystemFontName;

            string name = name1;
            GdiFontStyle style = gdiFont.Style;

            string key = KeyPrefix + name.ToLowerInvariant() + ((style & GdiFontStyle.Italic) == GdiFontStyle.Italic ? "/i" : "/n") + ((style & GdiFontStyle.Bold) == GdiFontStyle.Bold ? "/700" : "/400") + "/5";  
            return key;
        }
#endif


        public string Key
        {
            get { return _key; }
        }
        readonly string _key;

#if CORE || GDI
        internal GdiFont GdiFont
        {
            get { return _gdiFont; }
        }

        private readonly GdiFont _gdiFont;
#endif
        internal string DebuggerDisplay
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0} - {1} ({2})", FamilyName, StyleName, FaceName); }
        }
    }
    enum InternalGraphicsMode
    {
        DrawingGdiGraphics,
        DrawingPdfContent,
        DrawingBitmap,
    }
    public sealed class XGraphics : IDisposable
    {
        XGraphics(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit pageUnit, XPageDirection pageDirection)
        {
            if (page == null)
                throw new ArgumentNullException("page");

            if (page.Owner == null)
                throw new ArgumentException("You cannot draw on a page that is not owned by a PdfDocument object.", "page");

            if (page.RenderContent != null)
                throw new InvalidOperationException("An XGraphics object already exists for this page and must be disposed before a new one can be created.");

            if (page.Owner.IsReadOnly)
                throw new InvalidOperationException("Cannot create XGraphics for a page of a document that cannot be modified. Use PdfDocumentOpenMode.Modify.");

            _gsStack = new GraphicsStateStack(this);
            PdfContent content = null;
            switch (options)
            {
                case XGraphicsPdfPageOptions.Replace:
                    page.Contents.Elements.Clear();
                    goto case XGraphicsPdfPageOptions.Append;

                case XGraphicsPdfPageOptions.Prepend:
                    content = page.Contents.PrependContent();
                    break;

                case XGraphicsPdfPageOptions.Append:
                    content = page.Contents.AppendContent();
                    break;
            }
            page.RenderContent = content;

#if CORE
            TargetContext = XGraphicTargetContext.CORE;
#endif
            _renderer = new PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer(page, this, options);
            _pageSizePoints = new XSize(page.Width, page.Height);
            switch (pageUnit)
            {
                case XGraphicsUnit.Point:
                    _pageSize = new XSize(page.Width, page.Height);
                    break;

                case XGraphicsUnit.Inch:
                    _pageSize = new XSize(XUnit.FromPoint(page.Width).Inch, XUnit.FromPoint(page.Height).Inch);
                    break;

                case XGraphicsUnit.Millimeter:
                    _pageSize = new XSize(XUnit.FromPoint(page.Width).Millimeter, XUnit.FromPoint(page.Height).Millimeter);
                    break;

                case XGraphicsUnit.Centimeter:
                    _pageSize = new XSize(XUnit.FromPoint(page.Width).Centimeter, XUnit.FromPoint(page.Height).Centimeter);
                    break;

                case XGraphicsUnit.Presentation:
                    _pageSize = new XSize(XUnit.FromPoint(page.Width).Presentation, XUnit.FromPoint(page.Height).Presentation);
                    break;

                default:
                    throw new NotImplementedException("unit");
            }
            _pageUnit = pageUnit;
            _pageDirection = pageDirection;

            Initialize();
        }

        XGraphics(XForm form)
        {
            if (form == null)
                throw new ArgumentNullException("form");

            _form = form;
            form.AssociateGraphics(this);

            _gsStack = new GraphicsStateStack(this);
#if CORE
            TargetContext = XGraphicTargetContext.CORE;
            _drawGraphics = false;
            if (form.Owner != null)
                _renderer = new XGraphicsPdfRenderer(form, this);
            _pageSize = form.Size;
            Initialize();
#endif

        }

        public static XGraphics CreateMeasureContext(XSize size, XGraphicsUnit pageUnit, XPageDirection pageDirection)
        {
#if CORE
            PdfDocument dummy = new PdfDocument();
            PdfPage page = dummy.AddPage();
            XGraphics gfx = XGraphics.FromPdfPage(page, XGraphicsPdfPageOptions.Append, pageUnit, pageDirection);
            return gfx;
#endif

        }



        public static XGraphics FromPdfPage(PdfPage page)
        {
            return new XGraphics(page, XGraphicsPdfPageOptions.Append, XGraphicsUnit.Point, XPageDirection.Downwards);
        }

        public static XGraphics FromPdfPage(PdfPage page, XGraphicsUnit unit)
        {
            return new XGraphics(page, XGraphicsPdfPageOptions.Append, unit, XPageDirection.Downwards);
        }

        public static XGraphics FromPdfPage(PdfPage page, XPageDirection pageDirection)
        {
            return new XGraphics(page, XGraphicsPdfPageOptions.Append, XGraphicsUnit.Point, pageDirection);
        }

        public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options)
        {
            return new XGraphics(page, options, XGraphicsUnit.Point, XPageDirection.Downwards);
        }

        public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XPageDirection pageDirection)
        {
            return new XGraphics(page, options, XGraphicsUnit.Point, pageDirection);
        }

        public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit unit)
        {
            return new XGraphics(page, options, unit, XPageDirection.Downwards);
        }

        public static XGraphics FromPdfPage(PdfPage page, XGraphicsPdfPageOptions options, XGraphicsUnit unit, XPageDirection pageDirection)
        {
            return new XGraphics(page, options, unit, pageDirection);
        }

        public static XGraphics FromPdfForm(XPdfForm form)
        {
            if (form.Gfx != null)
                return form.Gfx;

            return new XGraphics(form);
        }

        public static XGraphics FromForm(XForm form)
        {
            if (form.Gfx != null)
                return form.Gfx;

            return new XGraphics(form);
        }

        public static XGraphics FromImage(XImage image)
        {
            return FromImage(image, XGraphicsUnit.Point);
        }

        public static XGraphics FromImage(XImage image, XGraphicsUnit unit)
        {
            if (image == null)
                throw new ArgumentNullException("image");

            XBitmapImage bmImage = image as XBitmapImage;
            if (bmImage != null)
            {
#if CORE
                return null;
#endif
            }
            return null;
        }

        void Initialize()
        {
            _pageOrigin = new XPoint();

            double pageHeight = _pageSize.Height;
            PdfPage targetPage = PdfPage;
            XPoint trimOffset = new XPoint();
            if (targetPage != null && targetPage.TrimMargins.AreSet)
            {
                pageHeight += targetPage.TrimMargins.Top.Point + targetPage.TrimMargins.Bottom.Point;
                trimOffset = new XPoint(targetPage.TrimMargins.Left.Point, targetPage.TrimMargins.Top.Point);
            }

            XMatrix matrix = new XMatrix();
#if CORE
            Debug.Assert(TargetContext == XGraphicTargetContext.CORE);
#endif
            if (_pageDirection != XPageDirection.Downwards)
                matrix.Prepend(new XMatrix(1, 0, 0, -1, 0, pageHeight));

            if (trimOffset != new XPoint())
                matrix.TranslatePrepend(trimOffset.X, -trimOffset.Y);

            DefaultViewMatrix = matrix;
            _transform = new XMatrix();
        }

        public void Dispose()
        {
            Dispose(true);
        }

        void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                _disposed = true;
                if (disposing)
                {
                    if (_associatedImage != null)
                    {
                        _associatedImage.DisassociateWithGraphics(this);
                        _associatedImage = null;
                    }
                }

                if (_form != null)
                    _form.Finish();
                _drawGraphics = false;

                if (_renderer != null)
                {
                    _renderer.Close();
                    _renderer = null;
                }
            }
        }
        bool _disposed;

        public PdfFontEncoding MUH
        {
            get { return _muh; }
            set { _muh = value; }
        }
        PdfFontEncoding _muh;

        internal XGraphicTargetContext TargetContext;

        public XGraphicsUnit PageUnit
        {
            get { return _pageUnit; }
        }
        readonly XGraphicsUnit _pageUnit;

        public XPageDirection PageDirection
        {
            get { return _pageDirection; }
            set
            {
                if (value != XPageDirection.Downwards)
                    throw new NotImplementedException("PageDirection must be XPageDirection.Downwards in current implementation.");
            }
        }
        readonly XPageDirection _pageDirection;

        public XPoint PageOrigin
        {
            get { return _pageOrigin; }
            set
            {
                if (value != new XPoint())
                    throw new NotImplementedException("PageOrigin cannot be modified in current implementation.");
            }
        }
        XPoint _pageOrigin;

        public XSize PageSize
        {
            get { return _pageSize; }
        }
        XSize _pageSize;
        XSize _pageSizePoints;


        public void DrawLine(XPen pen, XPoint pt1, XPoint pt2)
        {
            DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
        }

        public void DrawLine(XPen pen, double x1, double y1, double x2, double y2)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawLines(pen, new[] { new XPoint(x1, y1), new XPoint(x2, y2) });
        }

        public void DrawLines(XPen pen, XPoint[] points)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");
            if (points.Length < 2)
                throw new ArgumentException(PSSR.PointArrayAtLeast(2), "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawLines(pen, points);
        }

        public void DrawLines(XPen pen, double x, double y, params double[] value)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (value == null)
                throw new ArgumentNullException("value");

            int length = value.Length;
            XPoint[] points = new XPoint[length / 2 + 1];
            points[0].X = x;
            points[0].Y = y;
            for (int idx = 0; idx < length / 2; idx++)
            {
                points[idx + 1].X = value[2 * idx];
                points[idx + 1].Y = value[2 * idx + 1];
            }
            DrawLines(pen, points);
        }



        public void DrawBezier(XPen pen, XPoint pt1, XPoint pt2, XPoint pt3, XPoint pt4)
        {
            DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }

        public void DrawBezier(XPen pen, double x1, double y1, double x2, double y2,
          double x3, double y3, double x4, double y4)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawBeziers(pen,
                  new XPoint[] { new XPoint(x1, y1), new XPoint(x2, y2), new XPoint(x3, y3), new XPoint(x4, y4) });
        }


        public void DrawBeziers(XPen pen, XPoint[] points)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int count = points.Length;
            if (count == 0)
                return;

            if ((count - 1) % 3 != 0)
                throw new ArgumentException("Invalid number of points for bezier curves. Number must fulfill 4+3n.", "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawBeziers(pen, points);
        }



        public void DrawCurve(XPen pen, XPoint[] points)
        {
            DrawCurve(pen, points, 0.5);
        }


        public void DrawCurve(XPen pen, XPoint[] points, int offset, int numberOfSegments, double tension)
        {
            XPoint[] points2 = new XPoint[numberOfSegments];
            Array.Copy(points, offset, points2, 0, numberOfSegments);
            DrawCurve(pen, points2, tension);
        }

        public void DrawCurve(XPen pen, XPoint[] points, double tension)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            int count = points.Length;
            if (count < 2)
                throw new ArgumentException("DrawCurve requires two or more points.", "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawCurve(pen, points, tension);
        }



        public void DrawArc(XPen pen, XRect rect, double startAngle, double sweepAngle)
        {
            DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        public void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            if (Math.Abs(sweepAngle) >= 360)
            {
                DrawEllipse(pen, x, y, width, height);
            }
            else
            {
                if (_drawGraphics)
                {

                }

                if (_renderer != null)
                    _renderer.DrawArc(pen, x, y, width, height, startAngle, sweepAngle);
            }
        }


        public void DrawRectangle(XPen pen, XRect rect)
        {
            DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawRectangle(XPen pen, double x, double y, double width, double height)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawRectangle(pen, null, x, y, width, height);
        }


        public void DrawRectangle(XBrush brush, XRect rect)
        {
            DrawRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawRectangle(XBrush brush, double x, double y, double width, double height)
        {
            if (brush == null)
                throw new ArgumentNullException("brush");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawRectangle(null, brush, x, y, width, height);
        }


        public void DrawRectangle(XPen pen, XBrush brush, XRect rect)
        {
            DrawRectangle(pen, brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawRectangle(pen, brush, x, y, width, height);
        }

        public void DrawRectangles(XPen pen, XRect[] rectangles)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (rectangles == null)
                throw new ArgumentNullException("rectangles");

            DrawRectangles(pen, null, rectangles);
        }


        public void DrawRectangles(XBrush brush, XRect[] rectangles)
        {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (rectangles == null)
                throw new ArgumentNullException("rectangles");

            DrawRectangles(null, brush, rectangles);
        }

        public void DrawRectangles(XPen pen, XBrush brush, XRect[] rectangles)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);
            if (rectangles == null)
                throw new ArgumentNullException("rectangles");

            int count = rectangles.Length;
            if (_drawGraphics)
            {

            }

            if (_renderer != null)
            {
                for (int idx = 0; idx < count; idx++)
                {
                    XRect rect = rectangles[idx];
                    _renderer.DrawRectangle(pen, brush, rect.X, rect.Y, rect.Width, rect.Height);
                }
            }
        }



        public void DrawRoundedRectangle(XPen pen, XRect rect, XSize ellipseSize)
        {
            DrawRoundedRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height, ellipseSize.Width, ellipseSize.Height);
        }

        public void DrawRoundedRectangle(XPen pen, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            DrawRoundedRectangle(pen, null, x, y, width, height, ellipseWidth, ellipseHeight);
        }



        public void DrawRoundedRectangle(XBrush brush, XRect rect, XSize ellipseSize)
        {
            DrawRoundedRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height, ellipseSize.Width, ellipseSize.Height);
        }

        public void DrawRoundedRectangle(XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight)
        {
            if (brush == null)
                throw new ArgumentNullException("brush");

            DrawRoundedRectangle(null, brush, x, y, width, height, ellipseWidth, ellipseHeight);
        }

        public void DrawRoundedRectangle(XPen pen, XBrush brush, XRect rect, XSize ellipseSize)
        {
            DrawRoundedRectangle(pen, brush, rect.X, rect.Y, rect.Width, rect.Height, ellipseSize.Width, ellipseSize.Height);
        }

        public void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height,
            double ellipseWidth, double ellipseHeight)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawRoundedRectangle(pen, brush, x, y, width, height, ellipseWidth, ellipseHeight);
        }


        public void DrawEllipse(XPen pen, XRect rect)
        {
            DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawEllipse(XPen pen, double x, double y, double width, double height)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawEllipse(pen, null, x, y, width, height);
        }


        public void DrawEllipse(XBrush brush, XRect rect)
        {
            DrawEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawEllipse(XBrush brush, double x, double y, double width, double height)
        {
            if (brush == null)
                throw new ArgumentNullException("brush");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawEllipse(null, brush, x, y, width, height);
        }


        public void DrawEllipse(XPen pen, XBrush brush, XRect rect)
        {
            DrawEllipse(pen, brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawEllipse(pen, brush, x, y, width, height);
        }


        public void DrawPolygon(XPen pen, XPoint[] points)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");
            if (points.Length < 2)
                throw new ArgumentException(PSSR.PointArrayAtLeast(2), "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPolygon(pen, null, points, XFillMode.Alternate);
        }


        public void DrawPolygon(XBrush brush, XPoint[] points, XFillMode fillmode)
        {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");
            if (points.Length < 2)
                throw new ArgumentException(PSSR.PointArrayAtLeast(2), "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPolygon(null, brush, points, fillmode);
        }



        public void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);
            if (points == null)
                throw new ArgumentNullException("points");
            if (points.Length < 2)
                throw new ArgumentException(PSSR.PointArrayAtLeast(2), "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPolygon(pen, brush, points, fillmode);
        }



        public void DrawPie(XPen pen, XRect rect, double startAngle, double sweepAngle)
        {
            DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        public void DrawPie(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
            if (pen == null)
                throw new ArgumentNullException("pen", PSSR.NeedPenOrBrush);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPie(pen, null, x, y, width, height, startAngle, sweepAngle);
        }



        public void DrawPie(XBrush brush, XRect rect, double startAngle, double sweepAngle)
        {
            DrawPie(brush, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        public void DrawPie(XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
            if (brush == null)
                throw new ArgumentNullException("brush", PSSR.NeedPenOrBrush);

            if (_drawGraphics)
            {


            }

            if (_renderer != null)
                _renderer.DrawPie(null, brush, x, y, width, height, startAngle, sweepAngle);
        }


        public void DrawPie(XPen pen, XBrush brush, XRect rect, double startAngle, double sweepAngle)
        {
            DrawPie(pen, brush, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        public void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen", PSSR.NeedPenOrBrush);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPie(pen, brush, x, y, width, height, startAngle, sweepAngle);
        }



        public void DrawClosedCurve(XPen pen, XPoint[] points)
        {
            DrawClosedCurve(pen, null, points, XFillMode.Alternate, 0.5);
        }



        public void DrawClosedCurve(XPen pen, XPoint[] points, double tension)
        {
            DrawClosedCurve(pen, null, points, XFillMode.Alternate, tension);
        }


        public void DrawClosedCurve(XBrush brush, XPoint[] points)
        {
            DrawClosedCurve(null, brush, points, XFillMode.Alternate, 0.5);
        }


        public void DrawClosedCurve(XBrush brush, XPoint[] points, XFillMode fillmode)
        {
            DrawClosedCurve(null, brush, points, fillmode, 0.5);
        }



        public void DrawClosedCurve(XBrush brush, XPoint[] points, XFillMode fillmode, double tension)
        {
            DrawClosedCurve(null, brush, points, fillmode, tension);
        }


        public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points)
        {
            DrawClosedCurve(pen, brush, points, XFillMode.Alternate, 0.5);
        }


        public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode)
        {
            DrawClosedCurve(pen, brush, points, fillmode, 0.5);
        }


        public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode, double tension)
        {
            if (pen == null && brush == null)
            {
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);
            }

            int count = points.Length;
            if (count == 0)
                return;
            if (count < 2)
                throw new ArgumentException("Not enough points.", "points");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawClosedCurve(pen, brush, points, tension, fillmode);
        }

        public void DrawPath(XPen pen, XGraphicsPath path)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (path == null)
                throw new ArgumentNullException("path");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPath(pen, null, path);
        }

        public void DrawPath(XBrush brush, XGraphicsPath path)
        {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (path == null)
                throw new ArgumentNullException("path");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPath(null, brush, path);
        }

        public void DrawPath(XPen pen, XBrush brush, XGraphicsPath path)
        {
            if (pen == null && brush == null)
            {
                throw new ArgumentNullException("pen and brush", PSSR.NeedPenOrBrush);
            }
            if (path == null)
                throw new ArgumentNullException("path");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawPath(pen, brush, path);
        }

        public void DrawString(string s, XFont font, XBrush brush, XPoint point)
        {
            DrawString(s, font, brush, new XRect(point.X, point.Y, 0, 0), XStringFormats.Default);
        }

        public void DrawString(string s, XFont font, XBrush brush, XPoint point, XStringFormat format)
        {
            DrawString(s, font, brush, new XRect(point.X, point.Y, 0, 0), format);
        }

        public void DrawString(string s, XFont font, XBrush brush, double x, double y)
        {
            DrawString(s, font, brush, new XRect(x, y, 0, 0), XStringFormats.Default);
        }

        public void DrawString(string s, XFont font, XBrush brush, double x, double y, XStringFormat format)
        {
            DrawString(s, font, brush, new XRect(x, y, 0, 0), format);
        }


        public void DrawString(string s, XFont font, XBrush brush, XRect layoutRectangle)
        {
            DrawString(s, font, brush, layoutRectangle, XStringFormats.Default);
        }

        public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format)
        {
            if (text == null)
                throw new ArgumentNullException("text");
            if (font == null)
                throw new ArgumentNullException("font");
            if (brush == null)
                throw new ArgumentNullException("brush");

            if (format != null && format.LineAlignment == XLineAlignment.BaseLine && layoutRectangle.Height != 0)
                throw new InvalidOperationException("DrawString: With XLineAlignment.BaseLine the height of the layout rectangle must be 0.");

            if (text.Length == 0)
                return;

            if (format == null)
                format = XStringFormats.Default;
            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawString(text, font, brush, layoutRectangle, format);
        }

        public XSize MeasureString(string text, XFont font, XStringFormat stringFormat)
        {
            if (text == null)
                throw new ArgumentNullException("text");
            if (font == null)
                throw new ArgumentNullException("font");
            if (stringFormat == null)
                throw new ArgumentNullException("stringFormat");
#if true
            return FontHelper.MeasureString(text, font, stringFormat);
#else

#endif
#if CORE || NETFX_CORE || UWP
            XSize size = FontHelper.MeasureString(text, font, XStringFormats.Default);
            return size;
#endif

        }

        public XSize MeasureString(string text, XFont font)
        {
            return MeasureString(text, font, XStringFormats.Default);
        }


        public void DrawImage(XImage image, XPoint point)
        {
            DrawImage(image, point.X, point.Y);
        }

        public void DrawImage(XImage image, double x, double y)
        {
            if (image == null)
                throw new ArgumentNullException("image");

            CheckXPdfFormConsistence(image);

            double width = image.PointWidth;
            double height = image.PointHeight;

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawImage(image, x, y, image.PointWidth, image.PointHeight);
        }


        public void DrawImage(XImage image, XRect rect)
        {
            DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void DrawImage(XImage image, double x, double y, double width, double height)
        {
            if (image == null)
                throw new ArgumentNullException("image");

            CheckXPdfFormConsistence(image);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawImage(image, x, y, width, height);
        }


        public void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit)
        {
            if (image == null)
                throw new ArgumentNullException("image");

            CheckXPdfFormConsistence(image);

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.DrawImage(image, destRect, srcRect, srcUnit);
        }

        void DrawMissingImageRect(XRect rect)
        {


        }

        void CheckXPdfFormConsistence(XImage image)
        {
            XForm xForm = image as XForm;
            if (xForm != null)
            {
                xForm.Finish();

                if (_renderer != null && (_renderer as XGraphicsPdfRenderer) != null)
                {
                    if (xForm.Owner != null && xForm.Owner != ((XGraphicsPdfRenderer)_renderer).Owner)
                        throw new InvalidOperationException(
                            "A XPdfForm object is always bound to the document it was created for and cannot be drawn in the context of another document.");

                    if (xForm == ((XGraphicsPdfRenderer)_renderer)._form)
                        throw new InvalidOperationException(
                            "A XPdfForm cannot be drawn on itself.");
                }
            }
        }

        public void DrawBarCode(BarCodes.BarCode barcode, XPoint position)
        {
            barcode.Render(this, XBrushes.Black, null, position);
        }

        public void DrawBarCode(BarCodes.BarCode barcode, XBrush brush, XPoint position)
        {
            barcode.Render(this, brush, null, position);
        }

        public void DrawBarCode(BarCodes.BarCode barcode, XBrush brush, XFont font, XPoint position)
        {
            barcode.Render(this, brush, font, position);
        }

        public void DrawMatrixCode(BarCodes.MatrixCode matrixcode, XPoint position)
        {
            matrixcode.Render(this, XBrushes.Black, position);
        }

        public void DrawMatrixCode(BarCodes.MatrixCode matrixcode, XBrush brush, XPoint position)
        {
            matrixcode.Render(this, brush, position);
        }

        public XGraphicsState Save()
        {
            XGraphicsState xState = null;
#if CORE || NETFX_CORE
            if (TargetContext == XGraphicTargetContext.CORE || TargetContext == XGraphicTargetContext.NONE)
            {
                xState = new XGraphicsState();
                InternalGraphicsState iState = new InternalGraphicsState(this, xState);
                iState.Transform = _transform;
                _gsStack.Push(iState);
            }
            else
            {
                Debug.Assert(false, "XGraphicTargetContext must be XGraphicTargetContext.CORE.");
            }
#endif

            if (_renderer != null)
                _renderer.Save(xState);

            return xState;
        }

        public void Restore(XGraphicsState state)
        {
            if (state == null)
                throw new ArgumentNullException("state");

#if CORE
            if (TargetContext == XGraphicTargetContext.CORE)
            {
                _gsStack.Restore(state.InternalState);
                _transform = state.InternalState.Transform;
            }
#endif


            if (_renderer != null)
                _renderer.Restore(state);
        }

        public void Restore()
        {
            if (_gsStack.Count == 0)
                throw new InvalidOperationException("Cannot restore without preceding save operation.");
            Restore(_gsStack.Current.State);
        }

        public XGraphicsContainer BeginContainer()
        {
            return BeginContainer(new XRect(0, 0, 1, 1), new XRect(0, 0, 1, 1), XGraphicsUnit.Point);
        }


        public XGraphicsContainer BeginContainer(XRect dstrect, XRect srcrect, XGraphicsUnit unit)
        {
            if (unit != XGraphicsUnit.Point)
                throw new ArgumentException("The current implementation supports XGraphicsUnit.Point only.", "unit");

            XGraphicsContainer xContainer = null;
#if CORE
            if (TargetContext == XGraphicTargetContext.CORE)
                xContainer = new XGraphicsContainer();
#endif

            InternalGraphicsState iState = new InternalGraphicsState(this, xContainer);
            iState.Transform = _transform;

            _gsStack.Push(iState);

            if (_renderer != null)
                _renderer.BeginContainer(xContainer, dstrect, srcrect, unit);

            XMatrix matrix = new XMatrix();
            double scaleX = dstrect.Width / srcrect.Width;
            double scaleY = dstrect.Height / srcrect.Height;
            matrix.TranslatePrepend(-srcrect.X, -srcrect.Y);
            matrix.ScalePrepend(scaleX, scaleY);
            matrix.TranslatePrepend(dstrect.X / scaleX, dstrect.Y / scaleY);
            AddTransform(matrix, XMatrixOrder.Prepend);

            return xContainer;
        }

        public void EndContainer(XGraphicsContainer container)
        {
            if (container == null)
                throw new ArgumentNullException("container");

            _gsStack.Restore(container.InternalState);

            _transform = container.InternalState.Transform;

            if (_renderer != null)
                _renderer.EndContainer(container);
        }

        public int GraphicsStateLevel
        {
            get { return _gsStack.Count; }
        }

        public XSmoothingMode SmoothingMode
        {
            get
            {
                return _smoothingMode;
            }
            set
            {
                _smoothingMode = value;

            }
        }
        XSmoothingMode _smoothingMode;

        public void TranslateTransform(double dx, double dy)
        {
            AddTransform(XMatrix.CreateTranslation(dx, dy), XMatrixOrder.Prepend);
        }

        public void TranslateTransform(double dx, double dy, XMatrixOrder order)
        {
            XMatrix matrix = new XMatrix();
            matrix.TranslatePrepend(dx, dy);
            AddTransform(matrix, order);
        }

        public void ScaleTransform(double scaleX, double scaleY)
        {
            AddTransform(XMatrix.CreateScaling(scaleX, scaleY), XMatrixOrder.Prepend);
        }

        public void ScaleTransform(double scaleX, double scaleY, XMatrixOrder order)
        {
            XMatrix matrix = new XMatrix();
            matrix.ScalePrepend(scaleX, scaleY);
            AddTransform(matrix, order);
        }

        public void ScaleTransform(double scaleXY)
        {
            ScaleTransform(scaleXY, scaleXY);
        }

        public void ScaleTransform(double scaleXY, XMatrixOrder order)
        {
            ScaleTransform(scaleXY, scaleXY, order);
        }

        public void ScaleAtTransform(double scaleX, double scaleY, double centerX, double centerY)
        {
            AddTransform(XMatrix.CreateScaling(scaleX, scaleY, centerX, centerY), XMatrixOrder.Prepend);
        }

        public void ScaleAtTransform(double scaleX, double scaleY, XPoint center)
        {
            AddTransform(XMatrix.CreateScaling(scaleX, scaleY, center.X, center.Y), XMatrixOrder.Prepend);
        }

        public void RotateTransform(double angle)
        {
            AddTransform(XMatrix.CreateRotationRadians(angle * Const.Deg2Rad), XMatrixOrder.Prepend);
        }

        public void RotateTransform(double angle, XMatrixOrder order)
        {
            XMatrix matrix = new XMatrix();
            matrix.RotatePrepend(angle);
            AddTransform(matrix, order);
        }

        public void RotateAtTransform(double angle, XPoint point)
        {
            AddTransform(XMatrix.CreateRotationRadians(angle * Const.Deg2Rad, point.X, point.Y), XMatrixOrder.Prepend);
        }

        public void RotateAtTransform(double angle, XPoint point, XMatrixOrder order)
        {
            AddTransform(XMatrix.CreateRotationRadians(angle * Const.Deg2Rad, point.X, point.Y), order);
        }

        public void ShearTransform(double shearX, double shearY)
        {
            AddTransform(XMatrix.CreateSkewRadians(shearX * Const.Deg2Rad, shearY * Const.Deg2Rad), XMatrixOrder.Prepend);
        }

        public void ShearTransform(double shearX, double shearY, XMatrixOrder order)
        {
            AddTransform(XMatrix.CreateSkewRadians(shearX * Const.Deg2Rad, shearY * Const.Deg2Rad), order);
        }

        public void SkewAtTransform(double shearX, double shearY, double centerX, double centerY)
        {
            AddTransform(XMatrix.CreateSkewRadians(shearX * Const.Deg2Rad, shearY * Const.Deg2Rad, centerX, centerY), XMatrixOrder.Prepend);
        }

        public void SkewAtTransform(double shearX, double shearY, XPoint center)
        {
            AddTransform(XMatrix.CreateSkewRadians(shearX * Const.Deg2Rad, shearY * Const.Deg2Rad, center.X, center.Y), XMatrixOrder.Prepend);
        }

        public void MultiplyTransform(XMatrix matrix)
        {
            AddTransform(matrix, XMatrixOrder.Prepend);
        }

        public void MultiplyTransform(XMatrix matrix, XMatrixOrder order)
        {
            AddTransform(matrix, order);
        }

        public XMatrix Transform
        {
            get { return _transform; }
        }

        void AddTransform(XMatrix transform, XMatrixOrder order)
        {
            XMatrix matrix = _transform;
            matrix.Multiply(transform, order);
            _transform = matrix;
            matrix = DefaultViewMatrix;
            matrix.Multiply(_transform, XMatrixOrder.Prepend);
#if CORE
            if (TargetContext == XGraphicTargetContext.CORE)
            {
                GetType();
            }
#endif

            if (_renderer != null)
                _renderer.AddTransform(transform, XMatrixOrder.Prepend);
        }


        public void IntersectClip(XRect rect)
        {
            XGraphicsPath path = new XGraphicsPath();
            path.AddRectangle(rect);
            IntersectClip(path);
        }

        public void IntersectClip(XGraphicsPath path)
        {
            if (path == null)
                throw new ArgumentNullException("path");

            if (_drawGraphics)
            {

            }

            if (_renderer != null)
                _renderer.SetClip(path, XCombineMode.Intersect);
        }

        public void WriteComment(string comment)
        {
            if (comment == null)
                throw new ArgumentNullException("comment");

            if (_drawGraphics)
            {
            }

            if (_renderer != null)
                _renderer.WriteComment(comment);
        }

        public XGraphicsInternals Internals
        {
            get { return _internals ?? (_internals = new XGraphicsInternals(this)); }
        }
        XGraphicsInternals _internals;

        public SpaceTransformer Transformer
        {
            get { return _transformer ?? (_transformer = new SpaceTransformer(this)); }
        }
        SpaceTransformer _transformer;

        internal void DisassociateImage()
        {
            if (_associatedImage == null)
                throw new InvalidOperationException("No image associated.");

            Dispose();
        }

        internal InternalGraphicsMode InternalGraphicsMode
        {
            get { return _internalGraphicsMode; }
            set { _internalGraphicsMode = value; }
        }
        InternalGraphicsMode _internalGraphicsMode;

        internal XImage AssociatedImage
        {
            get { return _associatedImage; }
            set { _associatedImage = value; }
        }
        XImage _associatedImage;

        internal XMatrix DefaultViewMatrix;

        bool _drawGraphics;

        readonly XForm _form;


        IXGraphicsRenderer _renderer;

        XMatrix _transform;

        readonly GraphicsStateStack _gsStack;

        public PdfPage PdfPage
        {
            get
            {
                XGraphicsPdfRenderer renderer = _renderer as PdfSharp.Drawing.Pdf.XGraphicsPdfRenderer;
                return renderer != null ? renderer._page : null;
            }
        }


        public class XGraphicsInternals
        {
            internal XGraphicsInternals(XGraphics gfx)
            {
                _gfx = gfx;
            }
            readonly XGraphics _gfx;

        }

        public class SpaceTransformer
        {
            internal SpaceTransformer(XGraphics gfx)
            {
                _gfx = gfx;
            }
            readonly XGraphics _gfx;

            public XRect WorldToDefaultPage(XRect rect)
            {
                XPoint[] points = new XPoint[4];
                points[0] = new XPoint(rect.X, rect.Y);
                points[1] = new XPoint(rect.X + rect.Width, rect.Y);
                points[2] = new XPoint(rect.X, rect.Y + rect.Height);
                points[3] = new XPoint(rect.X + rect.Width, rect.Y + rect.Height);

                XMatrix matrix = _gfx.Transform;
                matrix.TransformPoints(points);

                double height = _gfx.PageSize.Height;
                points[0].Y = height - points[0].Y;
                points[1].Y = height - points[1].Y;
                points[2].Y = height - points[2].Y;
                points[3].Y = height - points[3].Y;

                double xmin = Math.Min(Math.Min(points[0].X, points[1].X), Math.Min(points[2].X, points[3].X));
                double xmax = Math.Max(Math.Max(points[0].X, points[1].X), Math.Max(points[2].X, points[3].X));
                double ymin = Math.Min(Math.Min(points[0].Y, points[1].Y), Math.Min(points[2].Y, points[3].Y));
                double ymax = Math.Max(Math.Max(points[0].Y, points[1].Y), Math.Max(points[2].Y, points[3].Y));

                return new XRect(xmin, ymin, xmax - xmin, ymax - ymin);
            }
        }
    }
    public sealed class XGraphicsContainer
    {

        internal InternalGraphicsState InternalState;
    }
    public sealed class XGraphicsPath
    {
        public XGraphicsPath()
        {

        }


        public XGraphicsPath Clone()
        {
            XGraphicsPath path = (XGraphicsPath)MemberwiseClone();
            return path;
        }

        public void AddLine(XPoint pt1, XPoint pt2)
        {
            AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
        }

        public void AddLine(double x1, double y1, double x2, double y2)
        {
#if CORE
            _corePath.MoveOrLineTo(x1, y1);
            _corePath.LineTo(x2, y2, false);
#endif
        }

        public void AddLines(XPoint[] points)
        {
            if (points == null)
                throw new ArgumentNullException("points");

            int count = points.Length;
            if (count == 0)
                return;
#if CORE
            _corePath.MoveOrLineTo(points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx++)
                _corePath.LineTo(points[idx].X, points[idx].Y, false);
#endif
        }


        public void AddBezier(XPoint pt1, XPoint pt2, XPoint pt3, XPoint pt4)
        {
            AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }

        public void AddBezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
#if CORE
            _corePath.MoveOrLineTo(x1, y1);
            _corePath.BezierTo(x2, y2, x3, y3, x4, y4, false);
#endif
        }

        public void AddBeziers(XPoint[] points)
        {
            if (points == null)
                throw new ArgumentNullException("points");

            int count = points.Length;
            if (count < 4)
                throw new ArgumentException("At least four points required for bezier curve.", "points");

            if ((count - 1) % 3 != 0)
                throw new ArgumentException("Invalid number of points for bezier curve. Number must fulfil 4+3n.",
                    "points");

#if CORE
            _corePath.MoveOrLineTo(points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx += 3)
            {
                _corePath.BezierTo(points[idx].X, points[idx].Y, points[idx + 1].X, points[idx + 1].Y,
                    points[idx + 2].X, points[idx + 2].Y, false);
            }
#endif
        }


        public void AddCurve(XPoint[] points)
        {
            AddCurve(points, 0.5);
        }

        public void AddCurve(XPoint[] points, double tension)
        {
            int count = points.Length;
            if (count < 2)
                throw new ArgumentException("AddCurve requires two or more points.", "points");
#if CORE
            _corePath.AddCurve(points, tension);
#endif

        }


        public void AddCurve(XPoint[] points, int offset, int numberOfSegments, double tension)
        {
#if CORE
            throw new NotImplementedException("AddCurve not yet implemented.");
#endif
        }

        public void AddArc(XRect rect, double startAngle, double sweepAngle)
        {
            AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        public void AddArc(double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
#if CORE
            _corePath.AddArc(x, y, width, height, startAngle, sweepAngle);
#endif
        }

        public void AddArc(XPoint point1, XPoint point2, XSize size, double rotationAngle, bool isLargeArg, XSweepDirection sweepDirection)
        {
        }
        public void AddRectangle(XRect rect)
        {
#if CORE
            _corePath.MoveTo(rect.X, rect.Y);
            _corePath.LineTo(rect.X + rect.Width, rect.Y, false);
            _corePath.LineTo(rect.X + rect.Width, rect.Y + rect.Height, false);
            _corePath.LineTo(rect.X, rect.Y + rect.Height, true);
            _corePath.CloseSubpath();
#endif
        }

        public void AddRectangle(double x, double y, double width, double height)
        {
            AddRectangle(new XRect(x, y, width, height));
        }

        public void AddRectangles(XRect[] rects)
        {
            int count = rects.Length;
            for (int idx = 0; idx < count; idx++)
            {
#if CORE
                AddRectangle(rects[idx]);
#endif
            }
        }


        public void AddRoundedRectangle(double x, double y, double width, double height, double ellipseWidth, double ellipseHeight)
        {
#if CORE
#if true
            double arcWidth = ellipseWidth / 2;
            double arcHeight = ellipseHeight / 2;
#if true   
            _corePath.MoveTo(x + width - arcWidth, y);
            _corePath.QuadrantArcTo(x + width - arcWidth, y + arcHeight, arcWidth, arcHeight, 1, true);

            _corePath.LineTo(x + width, y + height - arcHeight, false);
            _corePath.QuadrantArcTo(x + width - arcWidth, y + height - arcHeight, arcWidth, arcHeight, 4, true);

            _corePath.LineTo(x + arcWidth, y + height, false);
            _corePath.QuadrantArcTo(x + arcWidth, y + height - arcHeight, arcWidth, arcHeight, 3, true);

            _corePath.LineTo(x, y + arcHeight, false);
            _corePath.QuadrantArcTo(x + arcWidth, y + arcHeight, arcWidth, arcHeight, 2, true);

            _corePath.CloseSubpath();
 
#endif
#endif
#endif

        }

        public void AddEllipse(XRect rect)
        {
            AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
        }

        public void AddEllipse(double x, double y, double width, double height)
        {
#if CORE
            double w = width / 2;
            double h = height / 2;
            double xc = x + w;
            double yc = y + h;
            _corePath.MoveTo(x + w, y);
            _corePath.QuadrantArcTo(xc, yc, w, h, 1, true);
            _corePath.QuadrantArcTo(xc, yc, w, h, 4, true);
            _corePath.QuadrantArcTo(xc, yc, w, h, 3, true);
            _corePath.QuadrantArcTo(xc, yc, w, h, 2, true);
            _corePath.CloseSubpath();
#endif
        }

        public void AddPolygon(XPoint[] points)
        {
#if CORE
            int count = points.Length;
            if (count == 0)
                return;

            _corePath.MoveTo(points[0].X, points[0].Y);
            for (int idx = 0; idx < count - 1; idx++)
                _corePath.LineTo(points[idx].X, points[idx].Y, false);
            _corePath.LineTo(points[count - 1].X, points[count - 1].Y, true);
            _corePath.CloseSubpath();
#endif

        }

        public void AddPie(XRect rect, double startAngle, double sweepAngle)
        {
            AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        public void AddPie(double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
#if CORE
            DiagnosticsHelper.HandleNotImplemented("XGraphicsPath.AddPie");
#endif

        }

        public void AddClosedCurve(XPoint[] points)
        {
            AddClosedCurve(points, 0.5);
        }

        public void AddClosedCurve(XPoint[] points, double tension)
        {
            if (points == null)
                throw new ArgumentNullException("points");
            int count = points.Length;
            if (count == 0)
                return;
            if (count < 2)
                throw new ArgumentException("Not enough points.", "points");

#if CORE
            DiagnosticsHelper.HandleNotImplemented("XGraphicsPath.AddClosedCurve");
#endif

        }

        public void AddPath(XGraphicsPath path, bool connect)
        {
#if CORE
            DiagnosticsHelper.HandleNotImplemented("XGraphicsPath.AddPath");
#endif

        }


        public void AddString(string s, XFontFamily family, XFontStyle style, double emSize, XPoint origin,
            XStringFormat format)
        {
            try
            {
#if CORE
                DiagnosticsHelper.HandleNotImplemented("XGraphicsPath.AddString");
#endif

            }
            catch
            {
                throw;
            }
        }


        public void AddString(string s, XFontFamily family, XFontStyle style, double emSize, XRect layoutRect,
            XStringFormat format)
        {
            if (s == null)
                throw new ArgumentNullException("s");

            if (family == null)
                throw new ArgumentNullException("family");

            if (format == null)
                format = XStringFormats.Default;

            if (format.LineAlignment == XLineAlignment.BaseLine && layoutRect.Height != 0)
                throw new InvalidOperationException(
                    "DrawString: With XLineAlignment.BaseLine the height of the layout rectangle must be 0.");

            if (s.Length == 0)
                return;

            XFont font = new XFont(family.Name, emSize, style);
#if CORE
            DiagnosticsHelper.HandleNotImplemented("XGraphicsPath.AddString");
#endif

        }

        public void CloseFigure()
        {
#if CORE
            _corePath.CloseSubpath();
#endif

        }

        public void StartFigure()
        {

        }

        public XFillMode FillMode
        {
            get { return _fillMode; }
            set
            {
                _fillMode = value;

            }
        }

        private XFillMode _fillMode;

        public void Flatten()
        {

        }

        public void Flatten(XMatrix matrix)
        {

        }

        public void Flatten(XMatrix matrix, double flatness)
        {

        }

        public void Widen(XPen pen)
        {

        }

        public void Widen(XPen pen, XMatrix matrix)
        {

        }

        public void Widen(XPen pen, XMatrix matrix, double flatness)
        {


        }

        public XGraphicsPathInternals Internals
        {
            get { return new XGraphicsPathInternals(this); }
        }

#if CORE
        internal CoreGraphicsPath _corePath;
#endif
    }
    public sealed class XGraphicsPathInternals
    {
        internal XGraphicsPathInternals(XGraphicsPath path)
        {
            _path = path;
        }
        XGraphicsPath _path;
    }
    public sealed class XGraphicsState
    {
#if CORE
        internal XGraphicsState()
        { }
#endif
        internal InternalGraphicsState InternalState;
    }
    internal enum XImageState
    {
        UsedInDrawingContext = 0x00000001,

        StateMask = 0x0000FFFF,
    }
    public class XImage : IDisposable
    {

        protected XImage()
        { }

#if GDI || CORE || WPF
        XImage(ImportedImage image)
        {
            if (image == null)
                throw new ArgumentNullException("image");

            _importedImage = image;
            Initialize();
        }
#endif

        XImage(string path)
        {
#if !NETFX_CORE && !UWP
            path = Path.GetFullPath(path);
            if (!File.Exists(path))
                throw new FileNotFoundException(PSSR.FileNotFound(path));
#endif
            _path = path;

#if CORE_WITH_GDI || GDI
            try
            {
                Lock.EnterGdiPlus();
                _gdiImage = Image.FromFile(path);
            }
            finally { Lock.ExitGdiPlus(); }
#endif

            Initialize();
        }

        XImage(Stream stream)
        {
            _path = "*" + Guid.NewGuid().ToString("B");

#if CORE_WITH_GDI
            try
            {
                Lock.EnterGdiPlus();
                _gdiImage = Image.FromStream(stream);
            }
            finally { Lock.ExitGdiPlus(); }
#endif

            _stream = stream;
            Initialize();
        }


        public static XImage FromFile(string path)
        {
            if (PdfReader.TestPdfFile(path) > 0)
                return new XPdfForm(path);
            return new XImage(path);
        }

        public static XImage FromStream(Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException("stream");

            if (PdfReader.TestPdfFile(stream) > 0)
                return new XPdfForm(stream);
            return new XImage(stream);
        }

        public static bool ExistsFile(string path)
        {
            if (PdfReader.TestPdfFile(path) > 0)
                return true;
#if !NETFX_CORE && !UWP
            return File.Exists(path);
#endif
        }

        internal XImageState XImageState
        {
            get { return _xImageState; }
            set { _xImageState = value; }
        }
        XImageState _xImageState;

        internal void Initialize()
        {
#if CORE || GDI || WPF
            if (_importedImage != null)
            {
                ImportedImageJpeg iiJpeg = _importedImage as ImportedImageJpeg;
                if (iiJpeg != null)
                    _format = XImageFormat.Jpeg;
                else
                    _format = XImageFormat.Png;
                return;
            }
#endif

#if CORE_WITH_GDI
            if (_gdiImage != null)
            {
                string guid;
                try
                {
                    Lock.EnterGdiPlus();
                    guid = _gdiImage.RawFormat.Guid.ToString("B").ToUpper();
                }
                finally
                {
                    Lock.ExitGdiPlus();
                }

                switch (guid)
                {
                    case "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}":   
                    case "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}":   
                    case "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}":   
                        _format = XImageFormat.Png;
                        break;

                    case "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}":   
                        _format = XImageFormat.Jpeg;
                        break;

                    case "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}":   
                        _format = XImageFormat.Gif;
                        break;

                    case "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}":   
                        _format = XImageFormat.Tiff;
                        break;

                    case "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}":   
                        _format = XImageFormat.Icon;
                        break;

                    case "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}":   
                    case "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}":   
                    case "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}":   
                    case "{B96B3CB3-0728-11D3-9D7B-0000F81EF32E}":   
                    case "{B96B3CB4-0728-11D3-9D7B-0000F81EF32E}":   

                    default:
                        throw new InvalidOperationException("Unsupported image format.");
                }
                return;
            }
#endif

        }
        public void Dispose()
        {
            Dispose(true);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
                _disposed = true;

#if CORE || GDI || WPF
            {
                _importedImage = null;
            }
#endif

#if CORE_WITH_GDI || GDI
            if (_gdiImage != null)
            {
                try
                {
                    Lock.EnterGdiPlus();
                    _gdiImage.Dispose();
                    _gdiImage = null;
                }
                finally { Lock.ExitGdiPlus(); }
            }
#endif
#if WPF
            _wpfImage = null;
#endif
        }
        bool _disposed;

        [Obsolete("Use either PixelWidth or PointWidth. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelWidth, but will become PointWidth in future releases of PDFsharp.")]
        public virtual double Width
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                {
                    return _importedImage.Information.Width;
                }
#endif

#if (CORE_WITH_GDI || GDI)  && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Width;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

        [Obsolete("Use either PixelHeight or PointHeight. Temporarily obsolete because of rearrangements for WPF. Currently same as PixelHeight, but will become PointHeight in future releases of PDFsharp.")]
        public virtual double Height
        {
            get
            {
#if CORE_WITH_GDI || GDI || WPF
                if (_importedImage != null)
                {
                    return _importedImage.Information.Height;
                }
#endif

#if (CORE_WITH_GDI || GDI) && !WPF && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Height;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

#if CORE || GDI || WPF
        private const decimal FactorDPM72 = 72000 / 25.4m;

        private const decimal FactorDPM = 1000 / 25.4m;
#endif

        public virtual double PointWidth
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                {
                    if (_importedImage.Information.HorizontalDPM > 0)
                        return (double)(_importedImage.Information.Width * FactorDPM72 / _importedImage.Information.HorizontalDPM);
                    if (_importedImage.Information.HorizontalDPI > 0)
                        return (double)(_importedImage.Information.Width * 72 / _importedImage.Information.HorizontalDPI);
                    return _importedImage.Information.Width;
                }
#endif

#if (CORE_WITH_GDI || GDI) && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Width * 72 / _gdiImage.HorizontalResolution;
                }
                finally { Lock.ExitGdiPlus(); }
#endif

            }
        }

        public virtual double PointHeight
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                {
                    if (_importedImage.Information.VerticalDPM > 0)
                        return (double)(_importedImage.Information.Height * FactorDPM72 / _importedImage.Information.VerticalDPM);
                    if (_importedImage.Information.VerticalDPI > 0)
                        return (double)(_importedImage.Information.Height * 72 / _importedImage.Information.VerticalDPI);
                    return _importedImage.Information.Width;
                }
#endif

#if (CORE_WITH_GDI || GDI) && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Height * 72 / _gdiImage.HorizontalResolution;
                }
                finally { Lock.ExitGdiPlus(); }
#endif

            }
        }

        public virtual int PixelWidth
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                    return (int)_importedImage.Information.Width;
#endif

#if CORE_WITH_GDI
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Width;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

        public virtual int PixelHeight
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                    return (int)_importedImage.Information.Height;
#endif

#if CORE_WITH_GDI
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.Height;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

        public virtual XSize Size
        {
            get { return new XSize(PointWidth, PointHeight); }
        }

        public virtual double HorizontalResolution
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                {
                    if (_importedImage.Information.HorizontalDPI > 0)
                        return (double)_importedImage.Information.HorizontalDPI;
                    if (_importedImage.Information.HorizontalDPM > 0)
                        return (double)(_importedImage.Information.HorizontalDPM / FactorDPM);
                    return 72;
                }
#endif

#if (CORE_WITH_GDI || GDI) && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.HorizontalResolution;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

        public virtual double VerticalResolution
        {
            get
            {
#if CORE || GDI || WPF
                if (_importedImage != null)
                {
                    if (_importedImage.Information.VerticalDPI > 0)
                        return (double)_importedImage.Information.VerticalDPI;
                    if (_importedImage.Information.VerticalDPM > 0)
                        return (double)(_importedImage.Information.VerticalDPM / FactorDPM);
                    return 72;
                }
#endif

#if (CORE_WITH_GDI || GDI) && !WPF
                try
                {
                    Lock.EnterGdiPlus();
                    return _gdiImage.VerticalResolution;
                }
                finally { Lock.ExitGdiPlus(); }
#endif
            }
        }

        public virtual bool Interpolate
        {
            get { return _interpolate; }
            set { _interpolate = value; }
        }
        bool _interpolate = true;

        public XImageFormat Format
        {
            get { return _format; }
        }
        XImageFormat _format;


        internal void AssociateWithGraphics(XGraphics gfx)
        {
            if (_associatedGraphics != null)
                throw new InvalidOperationException("XImage already associated with XGraphics.");
            _associatedGraphics = null;
        }

        internal void DisassociateWithGraphics()
        {
            if (_associatedGraphics == null)
                throw new InvalidOperationException("XImage not associated with XGraphics.");
            _associatedGraphics.DisassociateImage();

            Debug.Assert(_associatedGraphics == null);
        }

        internal void DisassociateWithGraphics(XGraphics gfx)
        {
            if (_associatedGraphics != gfx)
                throw new InvalidOperationException("XImage not associated with XGraphics.");
            _associatedGraphics = null;
        }

        internal XGraphics AssociatedGraphics
        {
            get { return _associatedGraphics; }
            set { _associatedGraphics = value; }
        }
        XGraphics _associatedGraphics;

#if CORE || GDI || WPF
        internal ImportedImage _importedImage;
#endif

#if CORE_WITH_GDI || GDI
        internal Image _gdiImage;
#endif
#if WPF
        internal BitmapSource _wpfImage;
#if SILVERLIGHT
        //internal byte[] _bytes;
#endif
#endif
#if NETFX_CORE  || UWP
        internal BitmapSource _wrtImage;
#endif

        internal string _path;

        internal Stream _stream;

        internal PdfImageTable.ImageSelector _selector;
    }
    public sealed class XImageFormat
    {
        XImageFormat(Guid guid)
        {
            _guid = guid;
        }

        internal Guid Guid
        {
            get { return _guid; }
        }

        public override bool Equals(object obj)
        {
            XImageFormat format = obj as XImageFormat;
            if (format == null)
                return false;
            return _guid == format._guid;
        }

        public override int GetHashCode()
        {
            return _guid.GetHashCode();
        }

        public static XImageFormat Png
        {
            get { return _png; }
        }

        public static XImageFormat Gif
        {
            get { return _gif; }
        }

        public static XImageFormat Jpeg
        {
            get { return _jpeg; }
        }

        public static XImageFormat Tiff
        {
            get { return _tiff; }
        }

        public static XImageFormat Pdf
        {
            get { return _pdf; }
        }

        public static XImageFormat Icon
        {
            get { return _icon; }
        }

        readonly Guid _guid;

        private static readonly XImageFormat _png = new XImageFormat(new Guid("{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"));
        private static readonly XImageFormat _gif = new XImageFormat(new Guid("{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"));
        private static readonly XImageFormat _jpeg = new XImageFormat(new Guid("{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"));
        private static readonly XImageFormat _tiff = new XImageFormat(new Guid("{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"));
        private static readonly XImageFormat _icon = new XImageFormat(new Guid("{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"));
        private static readonly XImageFormat _pdf = new XImageFormat(new Guid("{84570158-DBF0-4C6B-8368-62D6A3CA76E0}"));
    }
    internal class XKnownColorTable
    {
        internal static uint[] ColorTable;

        public static uint KnownColorToArgb(XKnownColor color)
        {
            if (ColorTable == null)
                InitColorTable();
            if (color <= XKnownColor.YellowGreen)
                return ColorTable[(int)color];
            return 0;
        }

        public static bool IsKnownColor(uint argb)
        {
            for (int idx = 0; idx < ColorTable.Length; idx++)
            {
                if (ColorTable[idx] == argb)
                    return true;
            }
            return false;
        }

        public static XKnownColor GetKnownColor(uint argb)
        {
            for (int idx = 0; idx < ColorTable.Length; idx++)
            {
                if (ColorTable[idx] == argb)
                    return (XKnownColor)idx;
            }
            return (XKnownColor)(-1);
        }

        private static void InitColorTable()
        {
            uint[] colors = new uint[141];
            colors[0] = 0xFFF0F8FF;
            colors[1] = 0xFFFAEBD7;
            colors[2] = 0xFF00FFFF;
            colors[3] = 0xFF7FFFD4;
            colors[4] = 0xFFF0FFFF;
            colors[5] = 0xFFF5F5DC;
            colors[6] = 0xFFFFE4C4;
            colors[7] = 0xFF000000;
            colors[8] = 0xFFFFEBCD;
            colors[9] = 0xFF0000FF;
            colors[10] = 0xFF8A2BE2;
            colors[11] = 0xFFA52A2A;
            colors[12] = 0xFFDEB887;
            colors[13] = 0xFF5F9EA0;
            colors[14] = 0xFF7FFF00;
            colors[15] = 0xFFD2691E;
            colors[16] = 0xFFFF7F50;
            colors[17] = 0xFF6495ED;
            colors[18] = 0xFFFFF8DC;
            colors[19] = 0xFFDC143C;
            colors[20] = 0xFF00FFFF;
            colors[21] = 0xFF00008B;
            colors[22] = 0xFF008B8B;
            colors[23] = 0xFFB8860B;
            colors[24] = 0xFFA9A9A9;
            colors[25] = 0xFF006400;
            colors[26] = 0xFFBDB76B;
            colors[27] = 0xFF8B008B;
            colors[28] = 0xFF556B2F;
            colors[29] = 0xFFFF8C00;
            colors[30] = 0xFF9932CC;
            colors[31] = 0xFF8B0000;
            colors[32] = 0xFFE9967A;
            colors[33] = 0xFF8FBC8B;
            colors[34] = 0xFF483D8B;
            colors[35] = 0xFF2F4F4F;
            colors[36] = 0xFF00CED1;
            colors[37] = 0xFF9400D3;
            colors[38] = 0xFFFF1493;
            colors[39] = 0xFF00BFFF;
            colors[40] = 0xFF696969;
            colors[41] = 0xFF1E90FF;
            colors[42] = 0xFFB22222;
            colors[43] = 0xFFFFFAF0;
            colors[44] = 0xFF228B22;
            colors[45] = 0xFFFF00FF;
            colors[46] = 0xFFDCDCDC;
            colors[47] = 0xFFF8F8FF;
            colors[48] = 0xFFFFD700;
            colors[49] = 0xFFDAA520;
            colors[50] = 0xFF808080;
            colors[51] = 0xFF008000;
            colors[52] = 0xFFADFF2F;
            colors[53] = 0xFFF0FFF0;
            colors[54] = 0xFFFF69B4;
            colors[55] = 0xFFCD5C5C;
            colors[56] = 0xFF4B0082;
            colors[57] = 0xFFFFFFF0;
            colors[58] = 0xFFF0E68C;
            colors[59] = 0xFFE6E6FA;
            colors[60] = 0xFFFFF0F5;
            colors[61] = 0xFF7CFC00;
            colors[62] = 0xFFFFFACD;
            colors[63] = 0xFFADD8E6;
            colors[64] = 0xFFF08080;
            colors[65] = 0xFFE0FFFF;
            colors[66] = 0xFFFAFAD2;
            colors[67] = 0xFFD3D3D3;
            colors[68] = 0xFF90EE90;
            colors[69] = 0xFFFFB6C1;
            colors[70] = 0xFFFFA07A;
            colors[71] = 0xFF20B2AA;
            colors[72] = 0xFF87CEFA;
            colors[73] = 0xFF778899;
            colors[74] = 0xFFB0C4DE;
            colors[75] = 0xFFFFFFE0;
            colors[76] = 0xFF00FF00;
            colors[77] = 0xFF32CD32;
            colors[78] = 0xFFFAF0E6;
            colors[79] = 0xFFFF00FF;
            colors[80] = 0xFF800000;
            colors[81] = 0xFF66CDAA;
            colors[82] = 0xFF0000CD;
            colors[83] = 0xFFBA55D3;
            colors[84] = 0xFF9370DB;
            colors[85] = 0xFF3CB371;
            colors[86] = 0xFF7B68EE;
            colors[87] = 0xFF00FA9A;
            colors[88] = 0xFF48D1CC;
            colors[89] = 0xFFC71585;
            colors[90] = 0xFF191970;
            colors[91] = 0xFFF5FFFA;
            colors[92] = 0xFFFFE4E1;
            colors[93] = 0xFFFFE4B5;
            colors[94] = 0xFFFFDEAD;
            colors[95] = 0xFF000080;
            colors[96] = 0xFFFDF5E6;
            colors[97] = 0xFF808000;
            colors[98] = 0xFF6B8E23;
            colors[99] = 0xFFFFA500;
            colors[100] = 0xFFFF4500;
            colors[101] = 0xFFDA70D6;
            colors[102] = 0xFFEEE8AA;
            colors[103] = 0xFF98FB98;
            colors[104] = 0xFFAFEEEE;
            colors[105] = 0xFFDB7093;
            colors[106] = 0xFFFFEFD5;
            colors[107] = 0xFFFFDAB9;
            colors[108] = 0xFFCD853F;
            colors[109] = 0xFFFFC0CB;
            colors[110] = 0xFFDDA0DD;
            colors[111] = 0xFFB0E0E6;
            colors[112] = 0xFF800080;
            colors[113] = 0xFFFF0000;
            colors[114] = 0xFFBC8F8F;
            colors[115] = 0xFF4169E1;
            colors[116] = 0xFF8B4513;
            colors[117] = 0xFFFA8072;
            colors[118] = 0xFFF4A460;
            colors[119] = 0xFF2E8B57;
            colors[120] = 0xFFFFF5EE;
            colors[121] = 0xFFA0522D;
            colors[122] = 0xFFC0C0C0;
            colors[123] = 0xFF87CEEB;
            colors[124] = 0xFF6A5ACD;
            colors[125] = 0xFF708090;
            colors[126] = 0xFFFFFAFA;
            colors[127] = 0xFF00FF7F;
            colors[128] = 0xFF4682B4;
            colors[129] = 0xFFD2B48C;
            colors[130] = 0xFF008080;
            colors[131] = 0xFFD8BFD8;
            colors[132] = 0xFFFF6347;
            colors[133] = 0x00FFFFFF;
            colors[134] = 0xFF40E0D0;
            colors[135] = 0xFFEE82EE;
            colors[136] = 0xFFF5DEB3;
            colors[137] = 0xFFFFFFFF;
            colors[138] = 0xFFF5F5F5;
            colors[139] = 0xFFFFFF00;
            colors[140] = 0xFF9ACD32;

            ColorTable = colors;
        }
    }
    public sealed class XLinearGradientBrush : XBrush
    {


        public XLinearGradientBrush(XPoint point1, XPoint point2, XColor color1, XColor color2)
        {
            _point1 = point1;
            _point2 = point2;
            _color1 = color1;
            _color2 = color2;
        }


        public XLinearGradientBrush(XRect rect, XColor color1, XColor color2, XLinearGradientMode linearGradientMode)
        {
            if (!Enum.IsDefined(typeof(XLinearGradientMode), linearGradientMode))
                throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(XLinearGradientMode));

            if (rect.Width == 0 || rect.Height == 0)
                throw new ArgumentException("Invalid rectangle.", "rect");

            _useRect = true;
            _color1 = color1;
            _color2 = color2;
            _rect = rect;
            _linearGradientMode = linearGradientMode;
        }

        public XMatrix Transform
        {
            get { return _matrix; }
            set { _matrix = value; }
        }

        public void TranslateTransform(double dx, double dy)
        {
            _matrix.TranslatePrepend(dx, dy);
        }

        public void TranslateTransform(double dx, double dy, XMatrixOrder order)
        {
            _matrix.Translate(dx, dy, order);
        }

        public void ScaleTransform(double sx, double sy)
        {
            _matrix.ScalePrepend(sx, sy);
        }

        public void ScaleTransform(double sx, double sy, XMatrixOrder order)
        {
            _matrix.Scale(sx, sy, order);
        }

        public void RotateTransform(double angle)
        {
            _matrix.RotatePrepend(angle);
        }

        public void RotateTransform(double angle, XMatrixOrder order)
        {
            _matrix.Rotate(angle, order);
        }

        public void MultiplyTransform(XMatrix matrix)
        {
            _matrix.Prepend(matrix);
        }

        public void MultiplyTransform(XMatrix matrix, XMatrixOrder order)
        {
            _matrix.Multiply(matrix, order);
        }

        public void ResetTransform()
        {
            _matrix = new XMatrix();
        }

        internal bool _useRect;
        internal XPoint _point1, _point2;
        internal XColor _color1, _color2;
        internal XRect _rect;
        internal XLinearGradientMode _linearGradientMode;

        internal XMatrix _matrix;
    }
    public struct XMatrix : IFormattable
    {
        [Flags]
        internal enum XMatrixTypes
        {
            Identity = 0,
            Translation = 1,
            Scaling = 2,
            Unknown = 4
        }

        public XMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY)
        {
            _m11 = m11;
            _m12 = m12;
            _m21 = m21;
            _m22 = m22;
            _offsetX = offsetX;
            _offsetY = offsetY;
            _type = XMatrixTypes.Unknown;
            DeriveMatrixType();
        }

        public static XMatrix Identity
        {
            get { return s_identity; }
        }

        public void SetIdentity()
        {
            _type = XMatrixTypes.Identity;
        }

        public bool IsIdentity
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return true;
                if (_m11 == 1.0 && _m12 == 0 && _m21 == 0 && _m22 == 1.0 && _offsetX == 0 && _offsetY == 0)
                {
                    _type = XMatrixTypes.Identity;
                    return true;
                }
                return false;
            }
        }

        public double[] GetElements()
        {
            if (_type == XMatrixTypes.Identity)
                return new double[] { 1, 0, 0, 1, 0, 0 };
            return new double[] { _m11, _m12, _m21, _m22, _offsetX, _offsetY };
        }

        public static XMatrix operator *(XMatrix trans1, XMatrix trans2)
        {
            MatrixHelper.MultiplyMatrix(ref trans1, ref trans2);
            return trans1;
        }

        public static XMatrix Multiply(XMatrix trans1, XMatrix trans2)
        {
            MatrixHelper.MultiplyMatrix(ref trans1, ref trans2);
            return trans1;
        }

        public void Append(XMatrix matrix)
        {
            this *= matrix;
        }

        public void Prepend(XMatrix matrix)
        {
            this = matrix * this;
        }

        [Obsolete("Use Append.")]
        public void Multiply(XMatrix matrix)
        {
            Append(matrix);
        }

        [Obsolete("Use Prepend.")]
        public void MultiplyPrepend(XMatrix matrix)
        {
            Prepend(matrix);
        }

        public void Multiply(XMatrix matrix, XMatrixOrder order)
        {
            if (_type == XMatrixTypes.Identity)
                this = CreateIdentity();

            double t11 = M11;
            double t12 = M12;
            double t21 = M21;
            double t22 = M22;
            double tdx = OffsetX;
            double tdy = OffsetY;

            if (order == XMatrixOrder.Append)
            {
                _m11 = t11 * matrix.M11 + t12 * matrix.M21;
                _m12 = t11 * matrix.M12 + t12 * matrix.M22;
                _m21 = t21 * matrix.M11 + t22 * matrix.M21;
                _m22 = t21 * matrix.M12 + t22 * matrix.M22;
                _offsetX = tdx * matrix.M11 + tdy * matrix.M21 + matrix.OffsetX;
                _offsetY = tdx * matrix.M12 + tdy * matrix.M22 + matrix.OffsetY;
            }
            else
            {
                _m11 = t11 * matrix.M11 + t21 * matrix.M12;
                _m12 = t12 * matrix.M11 + t22 * matrix.M12;
                _m21 = t11 * matrix.M21 + t21 * matrix.M22;
                _m22 = t12 * matrix.M21 + t22 * matrix.M22;
                _offsetX = t11 * matrix.OffsetX + t21 * matrix.OffsetY + tdx;
                _offsetY = t12 * matrix.OffsetX + t22 * matrix.OffsetY + tdy;
            }
            DeriveMatrixType();
        }

        [Obsolete("Use TranslateAppend or TranslatePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void Translate(double offsetX, double offsetY)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void TranslateAppend(double offsetX, double offsetY)
        {
            if (_type == XMatrixTypes.Identity)
            {
                SetMatrix(1, 0, 0, 1, offsetX, offsetY, XMatrixTypes.Translation);
            }
            else if (_type == XMatrixTypes.Unknown)
            {
                _offsetX += offsetX;
                _offsetY += offsetY;
            }
            else
            {
                _offsetX += offsetX;
                _offsetY += offsetY;
                _type |= XMatrixTypes.Translation;
            }
        }

        public void TranslatePrepend(double offsetX, double offsetY)
        {
            this = CreateTranslation(offsetX, offsetY) * this;
        }

        public void Translate(double offsetX, double offsetY, XMatrixOrder order)
        {
            if (_type == XMatrixTypes.Identity)
                this = CreateIdentity();

            if (order == XMatrixOrder.Append)
            {
                _offsetX += offsetX;
                _offsetY += offsetY;
            }
            else
            {
                _offsetX += offsetX * _m11 + offsetY * _m21;
                _offsetY += offsetX * _m12 + offsetY * _m22;
            }
            DeriveMatrixType();
        }

        [Obsolete("Use ScaleAppend or ScalePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void Scale(double scaleX, double scaleY)
        {
            this = CreateScaling(scaleX, scaleY) * this;
        }

        public void ScaleAppend(double scaleX, double scaleY)
        {
            this *= CreateScaling(scaleX, scaleY);
        }

        public void ScalePrepend(double scaleX, double scaleY)
        {
            this = CreateScaling(scaleX, scaleY) * this;
        }

        public void Scale(double scaleX, double scaleY, XMatrixOrder order)
        {
            if (_type == XMatrixTypes.Identity)
                this = CreateIdentity();

            if (order == XMatrixOrder.Append)
            {
                _m11 *= scaleX;
                _m12 *= scaleY;
                _m21 *= scaleX;
                _m22 *= scaleY;
                _offsetX *= scaleX;
                _offsetY *= scaleY;
            }
            else
            {
                _m11 *= scaleX;
                _m12 *= scaleX;
                _m21 *= scaleY;
                _m22 *= scaleY;
            }
            DeriveMatrixType();
        }

        [Obsolete("Use ScaleAppend or ScalePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void Scale(double scaleXY)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void ScaleAppend(double scaleXY)
        {
            Scale(scaleXY, scaleXY, XMatrixOrder.Append);
        }

        public void ScalePrepend(double scaleXY)
        {
            Scale(scaleXY, scaleXY, XMatrixOrder.Prepend);
        }

        public void Scale(double scaleXY, XMatrixOrder order)
        {
            Scale(scaleXY, scaleXY, order);
        }

        [Obsolete("Use ScaleAtAppend or ScaleAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void ScaleAt(double scaleX, double scaleY, double centerX, double centerY)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void ScaleAtAppend(double scaleX, double scaleY, double centerX, double centerY)
        {
            this *= CreateScaling(scaleX, scaleY, centerX, centerY);
        }

        public void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY)
        {
            this = CreateScaling(scaleX, scaleY, centerX, centerY) * this;
        }

        [Obsolete("Use RotateAppend or RotatePrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void Rotate(double angle)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void RotateAppend(double angle)
        {
            angle = angle % 360.0;
            this *= CreateRotationRadians(angle * Const.Deg2Rad);
        }

        public void RotatePrepend(double angle)
        {
            angle = angle % 360.0;
            this = CreateRotationRadians(angle * Const.Deg2Rad) * this;
        }

        public void Rotate(double angle, XMatrixOrder order)
        {
            if (_type == XMatrixTypes.Identity)
                this = CreateIdentity();

            angle = angle * Const.Deg2Rad;
            double cos = Math.Cos(angle);
            double sin = Math.Sin(angle);
            if (order == XMatrixOrder.Append)
            {
                double t11 = _m11;
                double t12 = _m12;
                double t21 = _m21;
                double t22 = _m22;
                double tdx = _offsetX;
                double tdy = _offsetY;
                _m11 = t11 * cos - t12 * sin;
                _m12 = t11 * sin + t12 * cos;
                _m21 = t21 * cos - t22 * sin;
                _m22 = t21 * sin + t22 * cos;
                _offsetX = tdx * cos - tdy * sin;
                _offsetY = tdx * sin + tdy * cos;
            }
            else
            {
                double t11 = _m11;
                double t12 = _m12;
                double t21 = _m21;
                double t22 = _m22;
                _m11 = t11 * cos + t21 * sin;
                _m12 = t12 * cos + t22 * sin;
                _m21 = -t11 * sin + t21 * cos;
                _m22 = -t12 * sin + t22 * cos;
            }
            DeriveMatrixType();
        }

        [Obsolete("Use RotateAtAppend or RotateAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void RotateAt(double angle, double centerX, double centerY)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void RotateAtAppend(double angle, double centerX, double centerY)
        {
            angle = angle % 360.0;
            this *= CreateRotationRadians(angle * Const.Deg2Rad, centerX, centerY);
        }

        public void RotateAtPrepend(double angle, double centerX, double centerY)
        {
            angle = angle % 360.0;
            this = CreateRotationRadians(angle * Const.Deg2Rad, centerX, centerY) * this;
        }

        [Obsolete("Use RotateAtAppend or RotateAtPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void RotateAt(double angle, XPoint point)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void RotateAtAppend(double angle, XPoint point)
        {
            RotateAt(angle, point, XMatrixOrder.Append);
        }

        public void RotateAtPrepend(double angle, XPoint point)
        {
            RotateAt(angle, point, XMatrixOrder.Prepend);
        }

        public void RotateAt(double angle, XPoint point, XMatrixOrder order)
        {
            if (order == XMatrixOrder.Append)
            {
                angle = angle % 360.0;
                this *= CreateRotationRadians(angle * Const.Deg2Rad, point.X, point.Y);

            }
            else
            {
                angle = angle % 360.0;
                this = CreateRotationRadians(angle * Const.Deg2Rad, point.X, point.Y) * this;
            }
            DeriveMatrixType();
        }

        [Obsolete("Use ShearAppend or ShearPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void Shear(double shearX, double shearY)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void ShearAppend(double shearX, double shearY)
        {
            Shear(shearX, shearY, XMatrixOrder.Append);
        }

        public void ShearPrepend(double shearX, double shearY)
        {
            Shear(shearX, shearY, XMatrixOrder.Prepend);
        }

        public void Shear(double shearX, double shearY, XMatrixOrder order)
        {
            if (_type == XMatrixTypes.Identity)
                this = CreateIdentity();

            double t11 = _m11;
            double t12 = _m12;
            double t21 = _m21;
            double t22 = _m22;
            double tdx = _offsetX;
            double tdy = _offsetY;
            if (order == XMatrixOrder.Append)
            {
                _m11 += shearX * t12;
                _m12 += shearY * t11;
                _m21 += shearX * t22;
                _m22 += shearY * t21;
                _offsetX += shearX * tdy;
                _offsetY += shearY * tdx;
            }
            else
            {
                _m11 += shearY * t21;
                _m12 += shearY * t22;
                _m21 += shearX * t11;
                _m22 += shearX * t12;
            }
            DeriveMatrixType();
        }

        [Obsolete("Use SkewAppend or SkewPrepend explicitly, because in GDI+ and WPF the defaults are contrary.", true)]
        public void Skew(double skewX, double skewY)
        {
            throw new InvalidOperationException("Temporarily out of order.");
        }

        public void SkewAppend(double skewX, double skewY)
        {
            skewX = skewX % 360.0;
            skewY = skewY % 360.0;
            this *= CreateSkewRadians(skewX * Const.Deg2Rad, skewY * Const.Deg2Rad);
        }

        public void SkewPrepend(double skewX, double skewY)
        {
            skewX = skewX % 360.0;
            skewY = skewY % 360.0;
            this = CreateSkewRadians(skewX * Const.Deg2Rad, skewY * Const.Deg2Rad) * this;
        }

        public XPoint Transform(XPoint point)
        {
            double x = point.X;
            double y = point.Y;
            MultiplyPoint(ref x, ref y);
            return new XPoint(x, y);
        }

        public void Transform(XPoint[] points)
        {
            if (points != null)
            {
                int count = points.Length;
                for (int idx = 0; idx < count; idx++)
                {
                    double x = points[idx].X;
                    double y = points[idx].Y;
                    MultiplyPoint(ref x, ref y);
                    points[idx].X = x;
                    points[idx].Y = y;
                }
            }
        }

        public void TransformPoints(XPoint[] points)
        {
            if (points == null)
                throw new ArgumentNullException("points");

            if (IsIdentity)
                return;

            int count = points.Length;
            for (int idx = 0; idx < count; idx++)
            {
                double x = points[idx].X;
                double y = points[idx].Y;
                points[idx].X = x * _m11 + y * _m21 + _offsetX;
                points[idx].Y = x * _m12 + y * _m22 + _offsetY;
            }
        }



        public XVector Transform(XVector vector)
        {
            double x = vector.X;
            double y = vector.Y;
            MultiplyVector(ref x, ref y);
            return new XVector(x, y);
        }

        public void Transform(XVector[] vectors)
        {
            if (vectors != null)
            {
                int count = vectors.Length;
                for (int idx = 0; idx < count; idx++)
                {
                    double x = vectors[idx].X;
                    double y = vectors[idx].Y;
                    MultiplyVector(ref x, ref y);
                    vectors[idx].X = x;
                    vectors[idx].Y = y;
                }
            }
        }


        public double Determinant
        {
            get
            {
                switch (_type)
                {
                    case XMatrixTypes.Identity:
                    case XMatrixTypes.Translation:
                        return 1.0;

                    case XMatrixTypes.Scaling:
                    case XMatrixTypes.Scaling | XMatrixTypes.Translation:
                        return _m11 * _m22;
                }
                return (_m11 * _m22) - (_m12 * _m21);
            }
        }

        public bool HasInverse
        {
            get { return !DoubleUtil.IsZero(Determinant); }
        }

        public void Invert()
        {
            double determinant = Determinant;
            if (DoubleUtil.IsZero(determinant))
                throw new InvalidOperationException("NotInvertible");

            switch (_type)
            {
                case XMatrixTypes.Identity:
                    break;

                case XMatrixTypes.Translation:
                    _offsetX = -_offsetX;
                    _offsetY = -_offsetY;
                    return;

                case XMatrixTypes.Scaling:
                    _m11 = 1.0 / _m11;
                    _m22 = 1.0 / _m22;
                    return;

                case XMatrixTypes.Scaling | XMatrixTypes.Translation:
                    _m11 = 1.0 / _m11;
                    _m22 = 1.0 / _m22;
                    _offsetX = -_offsetX * _m11;
                    _offsetY = -_offsetY * _m22;
                    return;

                default:
                    {
                        double detInvers = 1.0 / determinant;
                        SetMatrix(_m22 * detInvers, -_m12 * detInvers, -_m21 * detInvers, _m11 * detInvers, (_m21 * _offsetY - _offsetX * _m22) * detInvers, (_offsetX * _m12 - _m11 * _offsetY) * detInvers, XMatrixTypes.Unknown);
                        break;
                    }
            }
        }

        public double M11
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return 1.0;
                return _m11;
            }
            set
            {
                if (_type == XMatrixTypes.Identity)
                    SetMatrix(value, 0, 0, 1, 0, 0, XMatrixTypes.Scaling);
                else
                {
                    _m11 = value;
                    if (_type != XMatrixTypes.Unknown)
                        _type |= XMatrixTypes.Scaling;
                }
            }
        }

        public double M12
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return 0;
                return _m12;
            }
            set
            {
                if (_type == XMatrixTypes.Identity)
                    SetMatrix(1, value, 0, 1, 0, 0, XMatrixTypes.Unknown);
                else
                {
                    _m12 = value;
                    _type = XMatrixTypes.Unknown;
                }
            }
        }

        public double M21
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return 0;
                return _m21;
            }
            set
            {
                if (_type == XMatrixTypes.Identity)
                    SetMatrix(1, 0, value, 1, 0, 0, XMatrixTypes.Unknown);
                else
                {
                    _m21 = value;
                    _type = XMatrixTypes.Unknown;
                }
            }
        }

        public double M22
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return 1.0;
                return _m22;
            }
            set
            {
                if (_type == XMatrixTypes.Identity)
                    SetMatrix(1, 0, 0, value, 0, 0, XMatrixTypes.Scaling);
                else
                {
                    _m22 = value;
                    if (_type != XMatrixTypes.Unknown)
                        _type |= XMatrixTypes.Scaling;
                }
            }
        }

        public double OffsetX
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return 0;
                return _offsetX;
            }
            set
            {
                if (_type == XMatrixTypes.Identity)
                    SetMatrix(1, 0, 0, 1, value, 0, XMatrixTypes.Translation);
                else
                {
                    _offsetX = value;
                    if (_type != XMatrixTypes.Unknown)
                        _type |= XMatrixTypes.Translation;
                }
            }
        }

        public double OffsetY
        {
            get
            {
                if (_type == XMatrixTypes.Identity)
                    return 0;
                return _offsetY;
            }
            set
            {
                if (_type == XMatrixTypes.Identity)
                    SetMatrix(1, 0, 0, 1, 0, value, XMatrixTypes.Translation);
                else
                {
                    _offsetY = value;
                    if (_type != XMatrixTypes.Unknown)
                        _type |= XMatrixTypes.Translation;
                }
            }
        }


        public static bool operator ==(XMatrix matrix1, XMatrix matrix2)
        {
            if (matrix1.IsDistinguishedIdentity || matrix2.IsDistinguishedIdentity)
                return (matrix1.IsIdentity == matrix2.IsIdentity);

            return matrix1.M11 == matrix2.M11 && matrix1.M12 == matrix2.M12 && matrix1.M21 == matrix2.M21 && matrix1.M22 == matrix2.M22 &&
              matrix1.OffsetX == matrix2.OffsetX && matrix1.OffsetY == matrix2.OffsetY;
        }

        public static bool operator !=(XMatrix matrix1, XMatrix matrix2)
        {
            return !(matrix1 == matrix2);
        }

        public static bool Equals(XMatrix matrix1, XMatrix matrix2)
        {
            if (matrix1.IsDistinguishedIdentity || matrix2.IsDistinguishedIdentity)
                return matrix1.IsIdentity == matrix2.IsIdentity;

            return matrix1.M11.Equals(matrix2.M11) && matrix1.M12.Equals(matrix2.M12) &&
              matrix1.M21.Equals(matrix2.M21) && matrix1.M22.Equals(matrix2.M22) &&
              matrix1.OffsetX.Equals(matrix2.OffsetX) && matrix1.OffsetY.Equals(matrix2.OffsetY);
        }

        public override bool Equals(object o)
        {
            if (!(o is XMatrix))
                return false;
            return Equals(this, (XMatrix)o);
        }

        public bool Equals(XMatrix value)
        {
            return Equals(this, value);
        }

        public override int GetHashCode()
        {
            if (IsDistinguishedIdentity)
                return 0;
            return M11.GetHashCode() ^ M12.GetHashCode() ^ M21.GetHashCode() ^ M22.GetHashCode() ^ OffsetX.GetHashCode() ^ OffsetY.GetHashCode();
        }

        public static XMatrix Parse(string source)
        {
            IFormatProvider cultureInfo = CultureInfo.InvariantCulture;
            TokenizerHelper helper = new TokenizerHelper(source, cultureInfo);
            string str = helper.NextTokenRequired();
            XMatrix identity = str == "Identity" ? Identity : new XMatrix(
                Convert.ToDouble(str, cultureInfo),
                Convert.ToDouble(helper.NextTokenRequired(), cultureInfo),
                Convert.ToDouble(helper.NextTokenRequired(), cultureInfo),
                Convert.ToDouble(helper.NextTokenRequired(), cultureInfo),
                Convert.ToDouble(helper.NextTokenRequired(), cultureInfo),
                Convert.ToDouble(helper.NextTokenRequired(), cultureInfo));
            helper.LastTokenRequired();
            return identity;
        }

        public override string ToString()
        {
            return ConvertToString(null, null);
        }

        public string ToString(IFormatProvider provider)
        {
            return ConvertToString(null, provider);
        }

        string IFormattable.ToString(string format, IFormatProvider provider)
        {
            return ConvertToString(format, provider);
        }

        internal string ConvertToString(string format, IFormatProvider provider)
        {
            if (IsIdentity)
                return "Identity";

            char numericListSeparator = TokenizerHelper.GetNumericListSeparator(provider);
            provider = provider ?? CultureInfo.InvariantCulture;
            return string.Format(provider, "{1:" + format + "}{0}{2:" + format + "}{0}{3:" + format + "}{0}{4:" + format + "}{0}{5:" + format + "}{0}{6:" + format + "}",
                new object[] { numericListSeparator, _m11, _m12, _m21, _m22, _offsetX, _offsetY });
        }

        internal void MultiplyVector(ref double x, ref double y)
        {
            switch (_type)
            {
                case XMatrixTypes.Identity:
                case XMatrixTypes.Translation:
                    return;

                case XMatrixTypes.Scaling:
                case XMatrixTypes.Scaling | XMatrixTypes.Translation:
                    x *= _m11;
                    y *= _m22;
                    return;
            }
            double d1 = y * _m21;
            double d2 = x * _m12;
            x *= _m11;
            x += d1;
            y *= _m22;
            y += d2;
        }

        internal void MultiplyPoint(ref double x, ref double y)
        {
            switch (_type)
            {
                case XMatrixTypes.Identity:
                    return;

                case XMatrixTypes.Translation:
                    x += _offsetX;
                    y += _offsetY;
                    return;

                case XMatrixTypes.Scaling:
                    x *= _m11;
                    y *= _m22;
                    return;

                case (XMatrixTypes.Scaling | XMatrixTypes.Translation):
                    x *= _m11;
                    x += _offsetX;
                    y *= _m22;
                    y += _offsetY;
                    return;
            }
            double d1 = (y * _m21) + _offsetX;
            double d2 = (x * _m12) + _offsetY;
            x *= _m11;
            x += d1;
            y *= _m22;
            y += d2;
        }

        internal static XMatrix CreateTranslation(double offsetX, double offsetY)
        {
            XMatrix matrix = new XMatrix();
            matrix.SetMatrix(1, 0, 0, 1, offsetX, offsetY, XMatrixTypes.Translation);
            return matrix;
        }

        internal static XMatrix CreateRotationRadians(double angle)
        {
            return CreateRotationRadians(angle, 0, 0);
        }

        internal static XMatrix CreateRotationRadians(double angle, double centerX, double centerY)
        {
            XMatrix matrix = new XMatrix();
            double sin = Math.Sin(angle);
            double cos = Math.Cos(angle);
            double offsetX = (centerX * (1.0 - cos)) + (centerY * sin);
            double offsetY = (centerY * (1.0 - cos)) - (centerX * sin);
            matrix.SetMatrix(cos, sin, -sin, cos, offsetX, offsetY, XMatrixTypes.Unknown);
            return matrix;
        }

        internal static XMatrix CreateScaling(double scaleX, double scaleY)
        {
            XMatrix matrix = new XMatrix();
            matrix.SetMatrix(scaleX, 0, 0, scaleY, 0, 0, XMatrixTypes.Scaling);
            return matrix;
        }

        internal static XMatrix CreateScaling(double scaleX, double scaleY, double centerX, double centerY)
        {
            XMatrix matrix = new XMatrix();
            matrix.SetMatrix(scaleX, 0, 0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY, XMatrixTypes.Scaling | XMatrixTypes.Translation);
            return matrix;
        }

        internal static XMatrix CreateSkewRadians(double skewX, double skewY, double centerX, double centerY)
        {
            XMatrix matrix = new XMatrix();
            matrix.Append(CreateTranslation(-centerX, -centerY));
            matrix.Append(new XMatrix(1, Math.Tan(skewY), Math.Tan(skewX), 1, 0, 0));
            matrix.Append(CreateTranslation(centerX, centerY));
            return matrix;
        }

        internal static XMatrix CreateSkewRadians(double skewX, double skewY)
        {
            XMatrix matrix = new XMatrix();
            matrix.SetMatrix(1, Math.Tan(skewY), Math.Tan(skewX), 1, 0, 0, XMatrixTypes.Unknown);
            return matrix;
        }

        static XMatrix CreateIdentity()
        {
            XMatrix matrix = new XMatrix();
            matrix.SetMatrix(1, 0, 0, 1, 0, 0, XMatrixTypes.Identity);
            return matrix;
        }

        void SetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, XMatrixTypes type)
        {
            _m11 = m11;
            _m12 = m12;
            _m21 = m21;
            _m22 = m22;
            _offsetX = offsetX;
            _offsetY = offsetY;
            _type = type;
        }

        void DeriveMatrixType()
        {
            _type = XMatrixTypes.Identity;
            if (_m12 != 0 || _m21 != 0)
            {
                _type = XMatrixTypes.Unknown;
            }
            else
            {
                if (_m11 != 1 || _m22 != 1)
                    _type = XMatrixTypes.Scaling;

                if (_offsetX != 0 || _offsetY != 0)
                    _type |= XMatrixTypes.Translation;

                if ((_type & (XMatrixTypes.Scaling | XMatrixTypes.Translation)) == XMatrixTypes.Identity)
                    _type = XMatrixTypes.Identity;
            }
        }

        bool IsDistinguishedIdentity
        {
            get { return (_type == XMatrixTypes.Identity); }
        }

        double _m11;
        double _m12;
        double _m21;
        double _m22;
        double _offsetX;
        double _offsetY;
        XMatrixTypes _type;
        static readonly XMatrix s_identity = CreateIdentity();

        internal static class MatrixHelper
        {
            internal static void MultiplyMatrix(ref XMatrix matrix1, ref XMatrix matrix2)
            {
                XMatrixTypes type1 = matrix1._type;
                XMatrixTypes type2 = matrix2._type;
                if (type2 != XMatrixTypes.Identity)
                {
                    if (type1 == XMatrixTypes.Identity)
                        matrix1 = matrix2;
                    else if (type2 == XMatrixTypes.Translation)
                    {
                        matrix1._offsetX += matrix2._offsetX;
                        matrix1._offsetY += matrix2._offsetY;
                        if (type1 != XMatrixTypes.Unknown)
                            matrix1._type |= XMatrixTypes.Translation;
                    }
                    else if (type1 == XMatrixTypes.Translation)
                    {
                        double num = matrix1._offsetX;
                        double num2 = matrix1._offsetY;
                        matrix1 = matrix2;
                        matrix1._offsetX = num * matrix2._m11 + num2 * matrix2._m21 + matrix2._offsetX;
                        matrix1._offsetY = num * matrix2._m12 + num2 * matrix2._m22 + matrix2._offsetY;
                        if (type2 == XMatrixTypes.Unknown)
                            matrix1._type = XMatrixTypes.Unknown;
                        else
                            matrix1._type = XMatrixTypes.Scaling | XMatrixTypes.Translation;
                    }
                    else
                    {
                        switch ((((int)type1) << 4) | (int)type2)
                        {
                            case 0x22:
                                matrix1._m11 *= matrix2._m11;
                                matrix1._m22 *= matrix2._m22;
                                return;

                            case 0x23:
                                matrix1._m11 *= matrix2._m11;
                                matrix1._m22 *= matrix2._m22;
                                matrix1._offsetX = matrix2._offsetX;
                                matrix1._offsetY = matrix2._offsetY;
                                matrix1._type = XMatrixTypes.Scaling | XMatrixTypes.Translation;
                                return;

                            case 0x24:
                            case 0x34:
                            case 0x42:
                            case 0x43:
                            case 0x44:
                                matrix1 = new XMatrix(
                                  matrix1._m11 * matrix2._m11 + matrix1._m12 * matrix2._m21,
                                  matrix1._m11 * matrix2._m12 + matrix1._m12 * matrix2._m22,
                                  matrix1._m21 * matrix2._m11 + matrix1._m22 * matrix2._m21,
                                  matrix1._m21 * matrix2._m12 + matrix1._m22 * matrix2._m22,
                                  matrix1._offsetX * matrix2._m11 + matrix1._offsetY * matrix2._m21 + matrix2._offsetX,
                                  matrix1._offsetX * matrix2._m12 + matrix1._offsetY * matrix2._m22 + matrix2._offsetY);
                                return;

                            case 50:
                                matrix1._m11 *= matrix2._m11;
                                matrix1._m22 *= matrix2._m22;
                                matrix1._offsetX *= matrix2._m11;
                                matrix1._offsetY *= matrix2._m22;
                                return;

                            case 0x33:
                                matrix1._m11 *= matrix2._m11;
                                matrix1._m22 *= matrix2._m22;
                                matrix1._offsetX = matrix2._m11 * matrix1._offsetX + matrix2._offsetX;
                                matrix1._offsetY = matrix2._m22 * matrix1._offsetY + matrix2._offsetY;
                                return;
                        }
                    }
                }
            }

            internal static void PrependOffset(ref XMatrix matrix, double offsetX, double offsetY)
            {
                if (matrix._type == XMatrixTypes.Identity)
                {
                    matrix = new XMatrix(1, 0, 0, 1, offsetX, offsetY);
                    matrix._type = XMatrixTypes.Translation;
                }
                else
                {
                    matrix._offsetX += (matrix._m11 * offsetX) + (matrix._m21 * offsetY);
                    matrix._offsetY += (matrix._m12 * offsetX) + (matrix._m22 * offsetY);
                    if (matrix._type != XMatrixTypes.Unknown)
                        matrix._type |= XMatrixTypes.Translation;
                }
            }

            internal static void TransformRect(ref XRect rect, ref XMatrix matrix)
            {
                if (!rect.IsEmpty)
                {
                    XMatrixTypes type = matrix._type;
                    if (type != XMatrixTypes.Identity)
                    {
                        if ((type & XMatrixTypes.Scaling) != XMatrixTypes.Identity)
                        {
                            rect.X *= matrix._m11;
                            rect.Y *= matrix._m22;
                            rect.Width *= matrix._m11;
                            rect.Height *= matrix._m22;
                            if (rect.Width < 0)
                            {
                                rect.X += rect.Width;
                                rect.Width = -rect.Width;
                            }
                            if (rect.Height < 0)
                            {
                                rect.Y += rect.Height;
                                rect.Height = -rect.Height;
                            }
                        }
                        if ((type & XMatrixTypes.Translation) != XMatrixTypes.Identity)
                        {
                            rect.X += matrix._offsetX;
                            rect.Y += matrix._offsetY;
                        }
                        if (type == XMatrixTypes.Unknown)
                        {
                            XPoint point1 = matrix.Transform(rect.TopLeft);
                            XPoint point2 = matrix.Transform(rect.TopRight);
                            XPoint point3 = matrix.Transform(rect.BottomRight);
                            XPoint point4 = matrix.Transform(rect.BottomLeft);
                            rect.X = Math.Min(Math.Min(point1.X, point2.X), Math.Min(point3.X, point4.X));
                            rect.Y = Math.Min(Math.Min(point1.Y, point2.Y), Math.Min(point3.Y, point4.Y));
                            rect.Width = Math.Max(Math.Max(point1.X, point2.X), Math.Max(point3.X, point4.X)) - rect.X;
                            rect.Height = Math.Max(Math.Max(point1.Y, point2.Y), Math.Max(point3.Y, point4.Y)) - rect.Y;
                        }
                    }
                }
            }
        }

        string DebuggerDisplay
        {
            get
            {
                if (IsIdentity)
                    return "matrix=(Identity)";

                const string format = Config.SignificantFigures7;

                XPoint point = new XMatrix(_m11, _m12, _m21, _m22, 0, 0).Transform(new XPoint(1, 0));
                double φ = Math.Atan2(point.Y, point.X) / Const.Deg2Rad;
                return String.Format(CultureInfo.InvariantCulture,
                    "matrix=({0:" + format + "}, {1:" + format + "}, {2:" + format + "}, {3:" + format + "}, {4:" + format + "}, {5:" + format + "}), φ={6:0.0#########}°",
                    _m11, _m12, _m21, _m22, _offsetX, _offsetY, φ);
            }
        }
    }
    public class XPdfForm : XForm
    {
        internal XPdfForm(string path)
        {
            int pageNumber;
            path = ExtractPageNumber(path, out pageNumber);

#if !NETFX_CORE
            path = Path.GetFullPath(path);
            if (!File.Exists(path))
                throw new FileNotFoundException(PSSR.FileNotFound(path));
#endif

            if (PdfReader.TestPdfFile(path) == 0)
                throw new ArgumentException("The specified file has no valid PDF file header.", "path");

            _path = path;
            if (pageNumber != 0)
                PageNumber = pageNumber;
        }

        internal XPdfForm(Stream stream)
        {
            _path = "*" + Guid.NewGuid().ToString("B");

            if (PdfReader.TestPdfFile(stream) == 0)
                throw new ArgumentException("The specified stream has no valid PDF file header.", "stream");

            _externalDocument = PdfReader.Open(stream);
        }

        public static new XPdfForm FromFile(string path)
        {
            return new XPdfForm(path);
        }

        public static new XPdfForm FromStream(Stream stream)
        {
            return new XPdfForm(stream);
        }

        internal override void Finish()
        {
            if (_formState == FormState.NotATemplate || _formState == FormState.Finished)
                return;

            base.Finish();

        }

        protected override void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                _disposed = true;
                try
                {
                    if (disposing)
                    {
                    }
                    if (_externalDocument != null)
                        PdfDocument.Tls.DetachDocument(_externalDocument.Handle);
                }
                finally
                {
                    base.Dispose(disposing);
                }
            }
        }
        bool _disposed;

        public XImage PlaceHolder
        {
            get { return _placeHolder; }
            set { _placeHolder = value; }
        }
        XImage _placeHolder;

        public PdfPage Page
        {
            get
            {
                if (IsTemplate)
                    return null;
                PdfPage page = ExternalDocument.Pages[_pageNumber - 1];
                return page;
            }
        }

        public int PageCount
        {
            get
            {
                if (IsTemplate)
                    return 1;
                if (_pageCount == -1)
                    _pageCount = ExternalDocument.Pages.Count;
                return _pageCount;
            }
        }
        int _pageCount = -1;

        [Obsolete("Use either PixelWidth or PointWidth. Temporarily obsolete because of rearrangements for WPF.")]
        public override double Width
        {
            get
            {
                PdfPage page = ExternalDocument.Pages[_pageNumber - 1];
                return page.Width;
            }
        }

        [Obsolete("Use either PixelHeight or PointHeight. Temporarily obsolete because of rearrangements for WPF.")]
        public override double Height
        {
            get
            {
                PdfPage page = ExternalDocument.Pages[_pageNumber - 1];
                return page.Height;
            }
        }

        public override double PointWidth
        {
            get
            {
                PdfPage page = ExternalDocument.Pages[_pageNumber - 1];
                return page.Width;
            }
        }

        public override double PointHeight
        {
            get
            {
                PdfPage page = ExternalDocument.Pages[_pageNumber - 1];
                return page.Height;
            }
        }

        public override int PixelWidth
        {
            get
            {
                return DoubleUtil.DoubleToInt(PointWidth);
            }
        }

        public override int PixelHeight
        {
            get
            {
                return DoubleUtil.DoubleToInt(PointHeight);
            }
        }

        public override XSize Size
        {
            get
            {
                PdfPage page = ExternalDocument.Pages[_pageNumber - 1];
                return new XSize(page.Width, page.Height);
            }
        }

        public override XMatrix Transform
        {
            get { return _transform; }
            set
            {
                if (_transform != value)
                {
                    _pdfForm = null;
                    _transform = value;
                }
            }
        }

        public int PageNumber
        {
            get { return _pageNumber; }
            set
            {
                if (IsTemplate)
                    throw new InvalidOperationException("The page number of an XPdfForm template cannot be modified.");

                if (_pageNumber != value)
                {
                    _pageNumber = value;
                    _pdfForm = null;
                }
            }
        }
        int _pageNumber = 1;

        public int PageIndex
        {
            get { return PageNumber - 1; }
            set { PageNumber = value + 1; }
        }

        internal PdfDocument ExternalDocument
        {
            get
            {
                if (IsTemplate)
                    throw new InvalidOperationException("This XPdfForm is a template and not an imported PDF page; therefore it has no external document.");

                if (_externalDocument == null)
                    _externalDocument = PdfDocument.Tls.GetDocument(_path);
                return _externalDocument;
            }
        }
        internal PdfDocument _externalDocument;

        public static string ExtractPageNumber(string path, out int pageNumber)
        {
            if (path == null)
                throw new ArgumentNullException("path");

            pageNumber = 0;
            int length = path.Length;
            if (length != 0)
            {
                length--;
                if (char.IsDigit(path, length))
                {
                    while (char.IsDigit(path, length) && length >= 0)
                        length--;
                    if (length > 0 && path[length] == '#')
                    {
                        if (path.IndexOf('.') != -1)
                        {
                            pageNumber = int.Parse(path.Substring(length + 1));
                            path = path.Substring(0, length);
                        }
                    }
                }
            }
            return path;
        }
    }
    public sealed class XPen
    {
        public XPen(XColor color)
            : this(color, 1, false)
        { }

        public XPen(XColor color, double width)
            : this(color, width, false)
        { }

        internal XPen(XColor color, double width, bool immutable)
        {
            _color = color;
            _width = width;
            _lineJoin = XLineJoin.Miter;
            _lineCap = XLineCap.Flat;
            _dashStyle = XDashStyle.Solid;
            _dashOffset = 0f;
            _immutable = immutable;
        }

        public XPen(XPen pen)
        {
            _color = pen._color;
            _width = pen._width;
            _lineJoin = pen._lineJoin;
            _lineCap = pen._lineCap;
            _dashStyle = pen._dashStyle;
            _dashOffset = pen._dashOffset;
            _dashPattern = pen._dashPattern;
            if (_dashPattern != null)
                _dashPattern = (double[])_dashPattern.Clone();
        }

        public XPen Clone()
        {
            return new XPen(this);
        }

        public XColor Color
        {
            get { return _color; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _color != value;
                _color = value;
            }
        }
        internal XColor _color;

        public double Width
        {
            get { return _width; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _width != value;
                _width = value;
            }
        }
        internal double _width;

        public XLineJoin LineJoin
        {
            get { return _lineJoin; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _lineJoin != value;
                _lineJoin = value;
            }
        }
        internal XLineJoin _lineJoin;

        public XLineCap LineCap
        {
            get { return _lineCap; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _lineCap != value;
                _lineCap = value;
            }
        }
        internal XLineCap _lineCap;

        public double MiterLimit
        {
            get { return _miterLimit; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _miterLimit != value;
                _miterLimit = value;
            }
        }
        internal double _miterLimit;

        public XDashStyle DashStyle
        {
            get { return _dashStyle; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _dashStyle != value;
                _dashStyle = value;
            }
        }
        internal XDashStyle _dashStyle;

        public double DashOffset
        {
            get { return _dashOffset; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _dirty = _dirty || _dashOffset != value;
                _dashOffset = value;
            }
        }
        internal double _dashOffset;

        public double[] DashPattern
        {
            get
            {
                if (_dashPattern == null)
                    _dashPattern = new double[0];
                return _dashPattern;
            }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));

                int length = value.Length;
                for (int idx = 0; idx < length; idx++)
                {
                    if (value[idx] <= 0)
                        throw new ArgumentException("Dash pattern value must greater than zero.");
                }

                _dirty = true;
                _dashStyle = XDashStyle.Custom;
                _dashPattern = (double[])value.Clone();
            }
        }
        internal double[] _dashPattern;

        public bool Overprint
        {
            get { return _overprint; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XPen"));
                _overprint = value;
            }
        }
        internal bool _overprint;

        bool _dirty = true;
        readonly bool _immutable;

    }
    public static class XPens
    {
        public static XPen AliceBlue
        {
            get { return new XPen(XColors.AliceBlue, 1, true); }
        }

        public static XPen AntiqueWhite
        {
            get { return new XPen(XColors.AntiqueWhite, 1, true); }
        }

        public static XPen Aqua
        {
            get { return new XPen(XColors.Aqua, 1, true); }
        }

        public static XPen Aquamarine
        {
            get { return new XPen(XColors.Aquamarine, 1, true); }
        }

        public static XPen Azure
        {
            get { return new XPen(XColors.Azure, 1, true); }
        }

        public static XPen Beige
        {
            get { return new XPen(XColors.Beige, 1, true); }
        }

        public static XPen Bisque
        {
            get { return new XPen(XColors.Bisque, 1, true); }
        }

        public static XPen Black
        {
            get { return new XPen(XColors.Black, 1, true); }
        }

        public static XPen BlanchedAlmond
        {
            get { return new XPen(XColors.BlanchedAlmond, 1, true); }
        }

        public static XPen Blue
        {
            get { return new XPen(XColors.Blue, 1, true); }
        }

        public static XPen BlueViolet
        {
            get { return new XPen(XColors.BlueViolet, 1, true); }
        }

        public static XPen Brown
        {
            get { return new XPen(XColors.Brown, 1, true); }
        }

        public static XPen BurlyWood
        {
            get { return new XPen(XColors.BurlyWood, 1, true); }
        }

        public static XPen CadetBlue
        {
            get { return new XPen(XColors.CadetBlue, 1, true); }
        }

        public static XPen Chartreuse
        {
            get { return new XPen(XColors.Chartreuse, 1, true); }
        }

        public static XPen Chocolate
        {
            get { return new XPen(XColors.Chocolate, 1, true); }
        }

        public static XPen Coral
        {
            get { return new XPen(XColors.Coral, 1, true); }
        }

        public static XPen CornflowerBlue
        {
            get { return new XPen(XColors.CornflowerBlue, 1, true); }
        }

        public static XPen Cornsilk
        {
            get { return new XPen(XColors.Cornsilk, 1, true); }
        }

        public static XPen Crimson
        {
            get { return new XPen(XColors.Crimson, 1, true); }
        }

        public static XPen Cyan
        {
            get { return new XPen(XColors.Cyan, 1, true); }
        }

        public static XPen DarkBlue
        {
            get { return new XPen(XColors.DarkBlue, 1, true); }
        }

        public static XPen DarkCyan
        {
            get { return new XPen(XColors.DarkCyan, 1, true); }
        }

        public static XPen DarkGoldenrod
        {
            get { return new XPen(XColors.DarkGoldenrod, 1, true); }
        }

        public static XPen DarkGray
        {
            get { return new XPen(XColors.DarkGray, 1, true); }
        }

        public static XPen DarkGreen
        {
            get { return new XPen(XColors.DarkGreen, 1, true); }
        }

        public static XPen DarkKhaki
        {
            get { return new XPen(XColors.DarkKhaki, 1, true); }
        }

        public static XPen DarkMagenta
        {
            get { return new XPen(XColors.DarkMagenta, 1, true); }
        }

        public static XPen DarkOliveGreen
        {
            get { return new XPen(XColors.DarkOliveGreen, 1, true); }
        }

        public static XPen DarkOrange
        {
            get { return new XPen(XColors.DarkOrange, 1, true); }
        }

        public static XPen DarkOrchid
        {
            get { return new XPen(XColors.DarkOrchid, 1, true); }
        }

        public static XPen DarkRed
        {
            get { return new XPen(XColors.DarkRed, 1, true); }
        }

        public static XPen DarkSalmon
        {
            get { return new XPen(XColors.DarkSalmon, 1, true); }
        }

        public static XPen DarkSeaGreen
        {
            get { return new XPen(XColors.DarkSeaGreen, 1, true); }
        }

        public static XPen DarkSlateBlue
        {
            get { return new XPen(XColors.DarkSlateBlue, 1, true); }
        }

        public static XPen DarkSlateGray
        {
            get { return new XPen(XColors.DarkSlateGray, 1, true); }
        }

        public static XPen DarkTurquoise
        {
            get { return new XPen(XColors.DarkTurquoise, 1, true); }
        }

        public static XPen DarkViolet
        {
            get { return new XPen(XColors.DarkViolet, 1, true); }
        }

        public static XPen DeepPink
        {
            get { return new XPen(XColors.DeepPink, 1, true); }
        }

        public static XPen DeepSkyBlue
        {
            get { return new XPen(XColors.DeepSkyBlue, 1, true); }
        }

        public static XPen DimGray
        {
            get { return new XPen(XColors.DimGray, 1, true); }
        }

        public static XPen DodgerBlue
        {
            get { return new XPen(XColors.DodgerBlue, 1, true); }
        }

        public static XPen Firebrick
        {
            get { return new XPen(XColors.Firebrick, 1, true); }
        }

        public static XPen FloralWhite
        {
            get { return new XPen(XColors.FloralWhite, 1, true); }
        }

        public static XPen ForestGreen
        {
            get { return new XPen(XColors.ForestGreen, 1, true); }
        }

        public static XPen Fuchsia
        {
            get { return new XPen(XColors.Fuchsia, 1, true); }
        }

        public static XPen Gainsboro
        {
            get { return new XPen(XColors.Gainsboro, 1, true); }
        }

        public static XPen GhostWhite
        {
            get { return new XPen(XColors.GhostWhite, 1, true); }
        }

        public static XPen Gold
        {
            get { return new XPen(XColors.Gold, 1, true); }
        }

        public static XPen Goldenrod
        {
            get { return new XPen(XColors.Goldenrod, 1, true); }
        }

        public static XPen Gray
        {
            get { return new XPen(XColors.Gray, 1, true); }
        }

        public static XPen Green
        {
            get { return new XPen(XColors.Green, 1, true); }
        }

        public static XPen GreenYellow
        {
            get { return new XPen(XColors.GreenYellow, 1, true); }
        }

        public static XPen Honeydew
        {
            get { return new XPen(XColors.Honeydew, 1, true); }
        }

        public static XPen HotPink
        {
            get { return new XPen(XColors.HotPink, 1, true); }
        }

        public static XPen IndianRed
        {
            get { return new XPen(XColors.IndianRed, 1, true); }
        }

        public static XPen Indigo
        {
            get { return new XPen(XColors.Indigo, 1, true); }
        }

        public static XPen Ivory
        {
            get { return new XPen(XColors.Ivory, 1, true); }
        }

        public static XPen Khaki
        {
            get { return new XPen(XColors.Khaki, 1, true); }
        }

        public static XPen Lavender
        {
            get { return new XPen(XColors.Lavender, 1, true); }
        }

        public static XPen LavenderBlush
        {
            get { return new XPen(XColors.LavenderBlush, 1, true); }
        }

        public static XPen LawnGreen
        {
            get { return new XPen(XColors.LawnGreen, 1, true); }
        }

        public static XPen LemonChiffon
        {
            get { return new XPen(XColors.LemonChiffon, 1, true); }
        }

        public static XPen LightBlue
        {
            get { return new XPen(XColors.LightBlue, 1, true); }
        }

        public static XPen LightCoral
        {
            get { return new XPen(XColors.LightCoral, 1, true); }
        }

        public static XPen LightCyan
        {
            get { return new XPen(XColors.LightCyan, 1, true); }
        }

        public static XPen LightGoldenrodYellow
        {
            get { return new XPen(XColors.LightGoldenrodYellow, 1, true); }
        }

        public static XPen LightGray
        {
            get { return new XPen(XColors.LightGray, 1, true); }
        }

        public static XPen LightGreen
        {
            get { return new XPen(XColors.LightGreen, 1, true); }
        }

        public static XPen LightPink
        {
            get { return new XPen(XColors.LightPink, 1, true); }
        }

        public static XPen LightSalmon
        {
            get { return new XPen(XColors.LightSalmon, 1, true); }
        }

        public static XPen LightSeaGreen
        {
            get { return new XPen(XColors.LightSeaGreen, 1, true); }
        }

        public static XPen LightSkyBlue
        {
            get { return new XPen(XColors.LightSkyBlue, 1, true); }
        }

        public static XPen LightSlateGray
        {
            get { return new XPen(XColors.LightSlateGray, 1, true); }
        }

        public static XPen LightSteelBlue
        {
            get { return new XPen(XColors.LightSteelBlue, 1, true); }
        }

        public static XPen LightYellow
        {
            get { return new XPen(XColors.LightYellow, 1, true); }
        }

        public static XPen Lime
        {
            get { return new XPen(XColors.Lime, 1, true); }
        }

        public static XPen LimeGreen
        {
            get { return new XPen(XColors.LimeGreen, 1, true); }
        }

        public static XPen Linen
        {
            get { return new XPen(XColors.Linen, 1, true); }
        }

        public static XPen Magenta
        {
            get { return new XPen(XColors.Magenta, 1, true); }
        }

        public static XPen Maroon
        {
            get { return new XPen(XColors.Maroon, 1, true); }
        }

        public static XPen MediumAquamarine
        {
            get { return new XPen(XColors.MediumAquamarine, 1, true); }
        }

        public static XPen MediumBlue
        {
            get { return new XPen(XColors.MediumBlue, 1, true); }
        }

        public static XPen MediumOrchid
        {
            get { return new XPen(XColors.MediumOrchid, 1, true); }
        }

        public static XPen MediumPurple
        {
            get { return new XPen(XColors.MediumPurple, 1, true); }
        }

        public static XPen MediumSeaGreen
        {
            get { return new XPen(XColors.MediumSeaGreen, 1, true); }
        }

        public static XPen MediumSlateBlue
        {
            get { return new XPen(XColors.MediumSlateBlue, 1, true); }
        }

        public static XPen MediumSpringGreen
        {
            get { return new XPen(XColors.MediumSpringGreen, 1, true); }
        }

        public static XPen MediumTurquoise
        {
            get { return new XPen(XColors.MediumTurquoise, 1, true); }
        }

        public static XPen MediumVioletRed
        {
            get { return new XPen(XColors.MediumVioletRed, 1, true); }
        }

        public static XPen MidnightBlue
        {
            get { return new XPen(XColors.MidnightBlue, 1, true); }
        }

        public static XPen MintCream
        {
            get { return new XPen(XColors.MintCream, 1, true); }
        }

        public static XPen MistyRose
        {
            get { return new XPen(XColors.MistyRose, 1, true); }
        }

        public static XPen Moccasin
        {
            get { return new XPen(XColors.Moccasin, 1, true); }
        }

        public static XPen NavajoWhite
        {
            get { return new XPen(XColors.NavajoWhite, 1, true); }
        }

        public static XPen Navy
        {
            get { return new XPen(XColors.Navy, 1, true); }
        }

        public static XPen OldLace
        {
            get { return new XPen(XColors.OldLace, 1, true); }
        }

        public static XPen Olive
        {
            get { return new XPen(XColors.Olive, 1, true); }
        }

        public static XPen OliveDrab
        {
            get { return new XPen(XColors.OliveDrab, 1, true); }
        }

        public static XPen Orange
        {
            get { return new XPen(XColors.Orange, 1, true); }
        }

        public static XPen OrangeRed
        {
            get { return new XPen(XColors.OrangeRed, 1, true); }
        }

        public static XPen Orchid
        {
            get { return new XPen(XColors.Orchid, 1, true); }
        }

        public static XPen PaleGoldenrod
        {
            get { return new XPen(XColors.PaleGoldenrod, 1, true); }
        }

        public static XPen PaleGreen
        {
            get { return new XPen(XColors.PaleGreen, 1, true); }
        }

        public static XPen PaleTurquoise
        {
            get { return new XPen(XColors.PaleTurquoise, 1, true); }
        }

        public static XPen PaleVioletRed
        {
            get { return new XPen(XColors.PaleVioletRed, 1, true); }
        }

        public static XPen PapayaWhip
        {
            get { return new XPen(XColors.PapayaWhip, 1, true); }
        }

        public static XPen PeachPuff
        {
            get { return new XPen(XColors.PeachPuff, 1, true); }
        }

        public static XPen Peru
        {
            get { return new XPen(XColors.Peru, 1, true); }
        }

        public static XPen Pink
        {
            get { return new XPen(XColors.Pink, 1, true); }
        }

        public static XPen Plum
        {
            get { return new XPen(XColors.Plum, 1, true); }
        }

        public static XPen PowderBlue
        {
            get { return new XPen(XColors.PowderBlue, 1, true); }
        }

        public static XPen Purple
        {
            get { return new XPen(XColors.Purple, 1, true); }
        }

        public static XPen Red
        {
            get { return new XPen(XColors.Red, 1, true); }
        }

        public static XPen RosyBrown
        {
            get { return new XPen(XColors.RosyBrown, 1, true); }
        }

        public static XPen RoyalBlue
        {
            get { return new XPen(XColors.RoyalBlue, 1, true); }
        }

        public static XPen SaddleBrown
        {
            get { return new XPen(XColors.SaddleBrown, 1, true); }
        }

        public static XPen Salmon
        {
            get { return new XPen(XColors.Salmon, 1, true); }
        }

        public static XPen SandyBrown
        {
            get { return new XPen(XColors.SandyBrown, 1, true); }
        }

        public static XPen SeaGreen
        {
            get { return new XPen(XColors.SeaGreen, 1, true); }
        }

        public static XPen SeaShell
        {
            get { return new XPen(XColors.SeaShell, 1, true); }
        }

        public static XPen Sienna
        {
            get { return new XPen(XColors.Sienna, 1, true); }
        }

        public static XPen Silver
        {
            get { return new XPen(XColors.Silver, 1, true); }
        }

        public static XPen SkyBlue
        {
            get { return new XPen(XColors.SkyBlue, 1, true); }
        }

        public static XPen SlateBlue
        {
            get { return new XPen(XColors.SlateBlue, 1, true); }
        }

        public static XPen SlateGray
        {
            get { return new XPen(XColors.SlateGray, 1, true); }
        }

        public static XPen Snow
        {
            get { return new XPen(XColors.Snow, 1, true); }
        }

        public static XPen SpringGreen
        {
            get { return new XPen(XColors.SpringGreen, 1, true); }
        }

        public static XPen SteelBlue
        {
            get { return new XPen(XColors.SteelBlue, 1, true); }
        }

        public static XPen Tan
        {
            get { return new XPen(XColors.Tan, 1, true); }
        }

        public static XPen Teal
        {
            get { return new XPen(XColors.Teal, 1, true); }
        }

        public static XPen Thistle
        {
            get { return new XPen(XColors.Thistle, 1, true); }
        }

        public static XPen Tomato
        {
            get { return new XPen(XColors.Tomato, 1, true); }
        }

        public static XPen Transparent
        {
            get { return new XPen(XColors.Transparent, 1, true); }
        }

        public static XPen Turquoise
        {
            get { return new XPen(XColors.Turquoise, 1, true); }
        }

        public static XPen Violet
        {
            get { return new XPen(XColors.Violet, 1, true); }
        }

        public static XPen Wheat
        {
            get { return new XPen(XColors.Wheat, 1, true); }
        }

        public static XPen White
        {
            get { return new XPen(XColors.White, 1, true); }
        }

        public static XPen WhiteSmoke
        {
            get { return new XPen(XColors.WhiteSmoke, 1, true); }
        }

        public static XPen Yellow
        {
            get { return new XPen(XColors.Yellow, 1, true); }
        }

        public static XPen YellowGreen
        {
            get { return new XPen(XColors.YellowGreen, 1, true); }
        }

    }
    public struct XPoint : IFormattable
    {
        public XPoint(double x, double y)
        {
            _x = x;
            _y = y;
        }


        public static bool operator ==(XPoint point1, XPoint point2)
        {
            return point1._x == point2._x && point1._y == point2._y;
        }

        public static bool operator !=(XPoint point1, XPoint point2)
        {
            return !(point1 == point2);
        }

        public static bool Equals(XPoint point1, XPoint point2)
        {
            return point1.X.Equals(point2.X) && point1.Y.Equals(point2.Y);
        }

        public override bool Equals(object o)
        {
            if (!(o is XPoint))
                return false;
            return Equals(this, (XPoint)o);
        }

        public bool Equals(XPoint value)
        {
            return Equals(this, value);
        }

        public override int GetHashCode()
        {
            return X.GetHashCode() ^ Y.GetHashCode();
        }

        public static XPoint Parse(string source)
        {
            CultureInfo cultureInfo = CultureInfo.InvariantCulture;
            TokenizerHelper helper = new TokenizerHelper(source, cultureInfo);
            string str = helper.NextTokenRequired();
            XPoint point = new XPoint(Convert.ToDouble(str, cultureInfo), Convert.ToDouble(helper.NextTokenRequired(), cultureInfo));
            helper.LastTokenRequired();
            return point;
        }

        public static XPoint[] ParsePoints(string value)
        {
            if (value == null)
                throw new ArgumentNullException("value");
            string[] values = value.Split(' ');
            int count = values.Length;
            XPoint[] points = new XPoint[count];
            for (int idx = 0; idx < count; idx++)
                points[idx] = Parse(values[idx]);
            return points;
        }

        public double X
        {
            get { return _x; }
            set { _x = value; }
        }
        double _x;

        public double Y
        {
            get { return _y; }
            set { _y = value; }
        }
        double _y;

        public override string ToString()
        {
            return ConvertToString(null, null);
        }

        public string ToString(IFormatProvider provider)
        {
            return ConvertToString(null, provider);
        }

        string IFormattable.ToString(string format, IFormatProvider provider)
        {
            return ConvertToString(format, provider);
        }

        internal string ConvertToString(string format, IFormatProvider provider)
        {
            char numericListSeparator = TokenizerHelper.GetNumericListSeparator(provider);
            provider = provider ?? CultureInfo.InvariantCulture;
            return string.Format(provider, "{1:" + format + "}{0}{2:" + format + "}", new object[] { numericListSeparator, _x, _y });
        }

        public void Offset(double offsetX, double offsetY)
        {
            _x += offsetX;
            _y += offsetY;
        }

        public static XPoint operator +(XPoint point, XVector vector)
        {
            return new XPoint(point._x + vector.X, point._y + vector.Y);
        }

        public static XPoint operator +(XPoint point, XSize size)
        {
            return new XPoint(point._x + size.Width, point._y + size.Height);
        }

        public static XPoint Add(XPoint point, XVector vector)
        {
            return new XPoint(point._x + vector.X, point._y + vector.Y);
        }

        public static XPoint operator -(XPoint point, XVector vector)
        {
            return new XPoint(point._x - vector.X, point._y - vector.Y);
        }

        public static XPoint Subtract(XPoint point, XVector vector)
        {
            return new XPoint(point._x - vector.X, point._y - vector.Y);
        }

        public static XVector operator -(XPoint point1, XPoint point2)
        {
            return new XVector(point1._x - point2._x, point1._y - point2._y);
        }

        [Obsolete("Use XVector instead of XSize as second parameter.")]
        public static XPoint operator -(XPoint point, XSize size)
        {
            return new XPoint(point._x - size.Width, point._y - size.Height);
        }

        public static XVector Subtract(XPoint point1, XPoint point2)
        {
            return new XVector(point1._x - point2._x, point1._y - point2._y);
        }

        public static XPoint operator *(XPoint point, XMatrix matrix)
        {
            return matrix.Transform(point);
        }

        public static XPoint Multiply(XPoint point, XMatrix matrix)
        {
            return matrix.Transform(point);
        }

        public static XPoint operator *(XPoint point, double value)
        {
            return new XPoint(point._x * value, point._y * value);
        }

        public static XPoint operator *(double value, XPoint point)
        {
            return new XPoint(value * point._x, value * point._y);
        }

        public static explicit operator XSize(XPoint point)
        {
            return new XSize(Math.Abs(point._x), Math.Abs(point._y));
        }

        public static explicit operator XVector(XPoint point)
        {
            return new XVector(point._x, point._y);
        }

        string DebuggerDisplay
        {
            get
            {
                const string format = Config.SignificantFigures10;
                return String.Format(CultureInfo.InvariantCulture, "point=({0:" + format + "}, {1:" + format + "})", _x, _y);
            }
        }
    }
    public sealed class XPrivateFontCollection
    {
        XPrivateFontCollection()
        {
        }

        internal static XPrivateFontCollection Singleton
        {
            get { return _singleton; }
        }
        internal static XPrivateFontCollection _singleton = new XPrivateFontCollection();

#if GDI
 
#else
        [Obsolete("Use the GDI build of PDFsharp and use Add(Stream stream)")]
#endif
        public static void AddFont(string filename)
        {
            throw new NotImplementedException();
        }


#if GDI
        
#else
        [Obsolete("Use the GDI build of PDFsharp and use Add(Stream stream)")]
#endif
        public static void AddFont(Stream stream, string facename)
        {
            throw new NotImplementedException();
        }


        static string MakeKey(string familyName, XFontStyle style)
        {
            return MakeKey(familyName, (style & XFontStyle.Bold) != 0, (style & XFontStyle.Italic) != 0);
        }

        static string MakeKey(string familyName, bool bold, bool italic)
        {
            return familyName + "#" + (bold ? "b" : "") + (italic ? "i" : "");
        }

        readonly Dictionary<string, XGlyphTypeface> _typefaces = new Dictionary<string, XGlyphTypeface>();


    }
    public struct XRect : IFormattable
    {
        public XRect(double x, double y, double width, double height)
        {
            if (width < 0 || height < 0)
                throw new ArgumentException("WidthAndHeightCannotBeNegative");
            _x = x;
            _y = y;
            _width = width;
            _height = height;
        }

        public XRect(XPoint point1, XPoint point2)
        {
            _x = Math.Min(point1.X, point2.X);
            _y = Math.Min(point1.Y, point2.Y);
            _width = Math.Max(Math.Max(point1.X, point2.X) - _x, 0);
            _height = Math.Max(Math.Max(point1.Y, point2.Y) - _y, 0);
        }

        public XRect(XPoint point, XVector vector)
            : this(point, point + vector)
        { }

        public XRect(XPoint location, XSize size)
        {
            if (size.IsEmpty)
                this = s_empty;
            else
            {
                _x = location.X;
                _y = location.Y;
                _width = size.Width;
                _height = size.Height;
            }
        }

        public XRect(XSize size)
        {
            if (size.IsEmpty)
                this = s_empty;
            else
            {
                _x = _y = 0;
                _width = size.Width;
                _height = size.Height;
            }
        }


        public static XRect FromLTRB(double left, double top, double right, double bottom)
        {
            return new XRect(left, top, right - left, bottom - top);
        }

        public static bool operator ==(XRect rect1, XRect rect2)
        {
            return rect1.X == rect2.X && rect1.Y == rect2.Y && rect1.Width == rect2.Width && rect1.Height == rect2.Height;
        }

        public static bool operator !=(XRect rect1, XRect rect2)
        {
            return !(rect1 == rect2);
        }

        public static bool Equals(XRect rect1, XRect rect2)
        {
            if (rect1.IsEmpty)
                return rect2.IsEmpty;
            return rect1.X.Equals(rect2.X) && rect1.Y.Equals(rect2.Y) && rect1.Width.Equals(rect2.Width) && rect1.Height.Equals(rect2.Height);
        }

        public override bool Equals(object o)
        {
            if (!(o is XRect))
                return false;
            return Equals(this, (XRect)o);
        }

        public bool Equals(XRect value)
        {
            return Equals(this, value);
        }

        public override int GetHashCode()
        {
            if (IsEmpty)
                return 0;
            return X.GetHashCode() ^ Y.GetHashCode() ^ Width.GetHashCode() ^ Height.GetHashCode();
        }

        public static XRect Parse(string source)
        {
            XRect empty;
            CultureInfo cultureInfo = CultureInfo.InvariantCulture;
            TokenizerHelper helper = new TokenizerHelper(source, cultureInfo);
            string str = helper.NextTokenRequired();
            if (str == "Empty")
                empty = Empty;
            else
                empty = new XRect(Convert.ToDouble(str, cultureInfo), Convert.ToDouble(helper.NextTokenRequired(), cultureInfo), Convert.ToDouble(helper.NextTokenRequired(), cultureInfo), Convert.ToDouble(helper.NextTokenRequired(), cultureInfo));
            helper.LastTokenRequired();
            return empty;
        }

        public override string ToString()
        {
            return ConvertToString(null, null);
        }

        public string ToString(IFormatProvider provider)
        {
            return ConvertToString(null, provider);
        }

        string IFormattable.ToString(string format, IFormatProvider provider)
        {
            return ConvertToString(format, provider);
        }

        internal string ConvertToString(string format, IFormatProvider provider)
        {
            if (IsEmpty)
                return "Empty";
            char numericListSeparator = TokenizerHelper.GetNumericListSeparator(provider);
            provider = provider ?? CultureInfo.InvariantCulture;
            return string.Format(provider, "{1:" + format + "}{0}{2:" + format + "}{0}{3:" + format + "}{0}{4:" + format + "}", new object[] { numericListSeparator, _x, _y, _width, _height });
        }

        public static XRect Empty
        {
            get { return s_empty; }
        }

        public bool IsEmpty
        {
            get { return _width < 0; }
        }

        public XPoint Location
        {
            get { return new XPoint(_x, _y); }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptyRect");
                _x = value.X;
                _y = value.Y;
            }
        }

        public XSize Size
        {
            get
            {
                if (IsEmpty)
                    return XSize.Empty;
                return new XSize(_width, _height);
            }
            set
            {
                if (value.IsEmpty)
                    this = s_empty;
                else
                {
                    if (IsEmpty)
                        throw new InvalidOperationException("CannotModifyEmptyRect");
                    _width = value.Width;
                    _height = value.Height;
                }
            }
        }

        public double X
        {
            get { return _x; }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptyRect");
                _x = value;
            }
        }
        double _x;

        public double Y
        {
            get { return _y; }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptyRect");
                _y = value;
            }
        }
        double _y;

        public double Width
        {
            get { return _width; }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptyRect");
                if (value < 0)
                    throw new ArgumentException("WidthCannotBeNegative");

                _width = value;
            }
        }
        double _width;

        public double Height
        {
            get { return _height; }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptyRect");
                if (value < 0)
                    throw new ArgumentException("HeightCannotBeNegative");
                _height = value;
            }
        }
        double _height;

        public double Left
        {
            get { return _x; }
        }

        public double Top
        {
            get { return _y; }
        }

        public double Right
        {
            get
            {
                if (IsEmpty)
                    return double.NegativeInfinity;
                return _x + _width;
            }
        }

        public double Bottom
        {
            get
            {
                if (IsEmpty)
                    return double.NegativeInfinity;
                return _y + _height;
            }
        }

        public XPoint TopLeft
        {
            get { return new XPoint(Left, Top); }
        }

        public XPoint TopRight
        {
            get { return new XPoint(Right, Top); }
        }

        public XPoint BottomLeft
        {
            get { return new XPoint(Left, Bottom); }
        }

        public XPoint BottomRight
        {
            get { return new XPoint(Right, Bottom); }
        }

        public XPoint Center
        {
            get { return new XPoint(_x + _width / 2, _y + _height / 2); }
        }

        public bool Contains(XPoint point)
        {
            return Contains(point.X, point.Y);
        }

        public bool Contains(double x, double y)
        {
            if (IsEmpty)
                return false;
            return ContainsInternal(x, y);
        }

        public bool Contains(XRect rect)
        {
            return !IsEmpty && !rect.IsEmpty &&
              _x <= rect._x && _y <= rect._y &&
              _x + _width >= rect._x + rect._width && _y + _height >= rect._y + rect._height;
        }

        public bool IntersectsWith(XRect rect)
        {
            return !IsEmpty && !rect.IsEmpty &&
                rect.Left <= Right && rect.Right >= Left &&
                rect.Top <= Bottom && rect.Bottom >= Top;
        }

        public void Intersect(XRect rect)
        {
            if (!IntersectsWith(rect))
                this = Empty;
            else
            {
                double left = Math.Max(Left, rect.Left);
                double top = Math.Max(Top, rect.Top);
                _width = Math.Max(Math.Min(Right, rect.Right) - left, 0.0);
                _height = Math.Max(Math.Min(Bottom, rect.Bottom) - top, 0.0);
                _x = left;
                _y = top;
            }
        }

        public static XRect Intersect(XRect rect1, XRect rect2)
        {
            rect1.Intersect(rect2);
            return rect1;
        }

        public void Union(XRect rect)
        {
            if (IsEmpty)
                this = rect;
            else if (!rect.IsEmpty)
            {
                double left = Math.Min(Left, rect.Left);
                double top = Math.Min(Top, rect.Top);
                if (rect.Width == Double.PositiveInfinity || Width == Double.PositiveInfinity)
                    _width = Double.PositiveInfinity;
                else
                {
                    double right = Math.Max(Right, rect.Right);
                    _width = Math.Max(right - left, 0.0);
                }

                if (rect.Height == Double.PositiveInfinity || _height == Double.PositiveInfinity)
                    _height = Double.PositiveInfinity;
                else
                {
                    double bottom = Math.Max(Bottom, rect.Bottom);
                    _height = Math.Max(bottom - top, 0.0);
                }
                _x = left;
                _y = top;
            }
        }

        public static XRect Union(XRect rect1, XRect rect2)
        {
            rect1.Union(rect2);
            return rect1;
        }

        public void Union(XPoint point)
        {
            Union(new XRect(point, point));
        }

        public static XRect Union(XRect rect, XPoint point)
        {
            rect.Union(new XRect(point, point));
            return rect;
        }

        public void Offset(XVector offsetVector)
        {
            if (IsEmpty)
                throw new InvalidOperationException("CannotCallMethod");
            _x += offsetVector.X;
            _y += offsetVector.Y;
        }

        public void Offset(double offsetX, double offsetY)
        {
            if (IsEmpty)
                throw new InvalidOperationException("CannotCallMethod");
            _x += offsetX;
            _y += offsetY;
        }

        public static XRect Offset(XRect rect, XVector offsetVector)
        {
            rect.Offset(offsetVector.X, offsetVector.Y);
            return rect;
        }

        public static XRect Offset(XRect rect, double offsetX, double offsetY)
        {
            rect.Offset(offsetX, offsetY);
            return rect;
        }

        public static XRect operator +(XRect rect, XPoint point)
        {
            return new XRect(rect._x + point.X, rect.Y + point.Y, rect._width, rect._height);
        }

        public static XRect operator -(XRect rect, XPoint point)
        {
            return new XRect(rect._x - point.X, rect.Y - point.Y, rect._width, rect._height);
        }

        public void Inflate(XSize size)
        {
            Inflate(size.Width, size.Height);
        }

        public void Inflate(double width, double height)
        {
            if (IsEmpty)
                throw new InvalidOperationException("CannotCallMethod");
            _x -= width;
            _y -= height;
            _width += width;
            _width += width;
            _height += height;
            _height += height;
            if (_width < 0 || _height < 0)
                this = s_empty;
        }

        public static XRect Inflate(XRect rect, XSize size)
        {
            rect.Inflate(size.Width, size.Height);
            return rect;
        }

        public static XRect Inflate(XRect rect, double width, double height)
        {
            rect.Inflate(width, height);
            return rect;
        }

        public static XRect Transform(XRect rect, XMatrix matrix)
        {
            XMatrix.MatrixHelper.TransformRect(ref rect, ref matrix);
            return rect;
        }

        public void Transform(XMatrix matrix)
        {
            XMatrix.MatrixHelper.TransformRect(ref this, ref matrix);
        }

        public void Scale(double scaleX, double scaleY)
        {
            if (!IsEmpty)
            {
                _x *= scaleX;
                _y *= scaleY;
                _width *= scaleX;
                _height *= scaleY;
                if (scaleX < 0)
                {
                    _x += _width;
                    _width *= -1.0;
                }
                if (scaleY < 0)
                {
                    _y += _height;
                    _height *= -1.0;
                }
            }
        }


        bool ContainsInternal(double x, double y)
        {
            return x >= _x && x - _width <= _x && y >= _y && y - _height <= _y;
        }

        static XRect CreateEmptyRect()
        {
            XRect rect = new XRect();
            rect._x = double.PositiveInfinity;
            rect._y = double.PositiveInfinity;
            rect._width = double.NegativeInfinity;
            rect._height = double.NegativeInfinity;
            return rect;
        }

        static XRect()
        {
            s_empty = CreateEmptyRect();
        }

        static readonly XRect s_empty;

        string DebuggerDisplay
        {
            get
            {
                const string format = Config.SignificantFigures10;
                return String.Format(CultureInfo.InvariantCulture,
                    "rect=({0:" + format + "}, {1:" + format + "}, {2:" + format + "}, {3:" + format + "})",
                    _x, _y, _width, _height);
            }
        }
    }
    public struct XSize : IFormattable
    {
        public XSize(double width, double height)
        {
            if (width < 0 || height < 0)
                throw new ArgumentException("WidthAndHeightCannotBeNegative");

            _width = width;
            _height = height;
        }

        public static bool operator ==(XSize size1, XSize size2)
        {
            return size1.Width == size2.Width && size1.Height == size2.Height;
        }

        public static bool operator !=(XSize size1, XSize size2)
        {
            return !(size1 == size2);
        }

        public static bool Equals(XSize size1, XSize size2)
        {
            if (size1.IsEmpty)
                return size2.IsEmpty;
            return size1.Width.Equals(size2.Width) && size1.Height.Equals(size2.Height);
        }

        public override bool Equals(object o)
        {
            if (!(o is XSize))
                return false;
            return Equals(this, (XSize)o);
        }

        public bool Equals(XSize value)
        {
            return Equals(this, value);
        }

        public override int GetHashCode()
        {
            if (IsEmpty)
                return 0;
            return Width.GetHashCode() ^ Height.GetHashCode();
        }

        public static XSize Parse(string source)
        {
            XSize empty;
            CultureInfo cultureInfo = CultureInfo.InvariantCulture;
            TokenizerHelper helper = new TokenizerHelper(source, cultureInfo);
            string str = helper.NextTokenRequired();
            if (str == "Empty")
                empty = Empty;
            else
                empty = new XSize(Convert.ToDouble(str, cultureInfo), Convert.ToDouble(helper.NextTokenRequired(), cultureInfo));
            helper.LastTokenRequired();
            return empty;
        }

        public XPoint ToXPoint()
        {
            return new XPoint(_width, _height);
        }

        public XVector ToXVector()
        {
            return new XVector(_width, _height);
        }


        public override string ToString()
        {
            return ConvertToString(null, null);
        }

        public string ToString(IFormatProvider provider)
        {
            return ConvertToString(null, provider);
        }

        string IFormattable.ToString(string format, IFormatProvider provider)
        {
            return ConvertToString(format, provider);
        }

        internal string ConvertToString(string format, IFormatProvider provider)
        {
            if (IsEmpty)
                return "Empty";

            char numericListSeparator = TokenizerHelper.GetNumericListSeparator(provider);
            provider = provider ?? CultureInfo.InvariantCulture;
            return string.Format(provider, "{1:" + format + "}{0}{2:" + format + "}", new object[] { numericListSeparator, _width, _height });
        }

        public static XSize Empty
        {
            get { return s_empty; }
        }
        static readonly XSize s_empty;

        public bool IsEmpty
        {
            get { return _width < 0; }
        }

        public double Width
        {
            get { return _width; }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptySize");
                if (value < 0)
                    throw new ArgumentException("WidthCannotBeNegative");
                _width = value;
            }
        }
        double _width;

        public double Height
        {
            get { return _height; }
            set
            {
                if (IsEmpty)
                    throw new InvalidOperationException("CannotModifyEmptySize");
                if (value < 0)
                    throw new ArgumentException("HeightCannotBeNegative");
                _height = value;
            }
        }
        double _height;

        public static explicit operator XVector(XSize size)
        {
            return new XVector(size._width, size._height);
        }

        public static explicit operator XPoint(XSize size)
        {
            return new XPoint(size._width, size._height);
        }

        private static XSize CreateEmptySize()
        {
            XSize size = new XSize();
            size._width = double.NegativeInfinity;
            size._height = double.NegativeInfinity;
            return size;
        }

        static XSize()
        {
            s_empty = CreateEmptySize();
        }

        string DebuggerDisplay
        {
            get
            {
                const string format = Config.SignificantFigures10;
                return String.Format(CultureInfo.InvariantCulture,
                    "size=({2}{0:" + format + "}, {1:" + format + "})",
                    _width, _height, IsEmpty ? "Empty " : "");
            }
        }
    }
    public sealed class XSolidBrush : XBrush
    {
        public XSolidBrush()
        { }

        public XSolidBrush(XColor color)
            : this(color, false)
        { }

        internal XSolidBrush(XColor color, bool immutable)
        {
            _color = color;
            _immutable = immutable;
        }

        public XSolidBrush(XSolidBrush brush)
        {
            _color = brush.Color;
        }

        public XColor Color
        {
            get { return _color; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XSolidBrush"));
                _color = value;
            }
        }
        internal XColor _color;

        public bool Overprint
        {
            get { return _overprint; }
            set
            {
                if (_immutable)
                    throw new ArgumentException(PSSR.CannotChangeImmutableObject("XSolidBrush"));
                _overprint = value;
            }
        }
        internal bool _overprint;

        readonly bool _immutable;
    }
    public class XStringFormat
    {
        public XStringFormat()
        {

        }

        public XStringAlignment Alignment
        {
            get { return _alignment; }
            set
            {
                _alignment = value;
            }
        }
        XStringAlignment _alignment;

        public XLineAlignment LineAlignment
        {
            get { return _lineAlignment; }
            set
            {
                _lineAlignment = value;
            }
        }
        XLineAlignment _lineAlignment;

        [Obsolete("Use XStringFormats.Default. (Note plural in class name.)")]
        public static XStringFormat Default
        {
            get { return XStringFormats.Default; }
        }

        [Obsolete("Use XStringFormats.Default. (Note plural in class name.)")]
        public static XStringFormat TopLeft
        {
            get { return XStringFormats.TopLeft; }
        }

        [Obsolete("Use XStringFormats.Center. (Note plural in class name.)")]
        public static XStringFormat Center
        {
            get { return XStringFormats.Center; }
        }

        [Obsolete("Use XStringFormats.TopCenter. (Note plural in class name.)")]
        public static XStringFormat TopCenter
        {
            get { return XStringFormats.TopCenter; }
        }

        [Obsolete("Use XStringFormats.BottomCenter. (Note plural in class name.)")]
        public static XStringFormat BottomCenter
        {
            get { return XStringFormats.BottomCenter; }
        }

    }
    public static class XStringFormats
    {
        public static XStringFormat Default
        {
            get { return BaseLineLeft; }
        }

        public static XStringFormat BaseLineLeft
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Near;
                format.LineAlignment = XLineAlignment.BaseLine;
                return format;
            }
        }

        public static XStringFormat TopLeft
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Near;
                format.LineAlignment = XLineAlignment.Near;
                return format;
            }
        }

        public static XStringFormat CenterLeft
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Near;
                format.LineAlignment = XLineAlignment.Center;
                return format;
            }
        }

        public static XStringFormat BottomLeft
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Near;
                format.LineAlignment = XLineAlignment.Far;
                return format;
            }
        }

        public static XStringFormat BaseLineCenter
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Center;
                format.LineAlignment = XLineAlignment.BaseLine;
                return format;
            }
        }

        public static XStringFormat TopCenter
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Center;
                format.LineAlignment = XLineAlignment.Near;
                return format;
            }
        }

        public static XStringFormat Center
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Center;
                format.LineAlignment = XLineAlignment.Center;
                return format;
            }
        }

        public static XStringFormat BottomCenter
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Center;
                format.LineAlignment = XLineAlignment.Far;
                return format;
            }
        }

        public static XStringFormat BaseLineRight
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Far;
                format.LineAlignment = XLineAlignment.BaseLine;
                return format;
            }
        }

        public static XStringFormat TopRight
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Far;
                format.LineAlignment = XLineAlignment.Near;
                return format;
            }
        }

        public static XStringFormat CenterRight
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Far;
                format.LineAlignment = XLineAlignment.Center;
                return format;
            }
        }

        public static XStringFormat BottomRight
        {
            get
            {
                XStringFormat format = new XStringFormat();
                format.Alignment = XStringAlignment.Far;
                format.LineAlignment = XLineAlignment.Far;
                return format;
            }
        }
    }
    public struct XUnit : IFormattable
    {
        internal const double PointFactor = 1;
        internal const double InchFactor = 72;
        internal const double MillimeterFactor = 72 / 25.4;
        internal const double CentimeterFactor = 72 / 2.54;
        internal const double PresentationFactor = 72 / 96.0;

        internal const double PointFactorWpf = 96 / 72.0;
        internal const double InchFactorWpf = 96;
        internal const double MillimeterFactorWpf = 96 / 25.4;
        internal const double CentimeterFactorWpf = 96 / 2.54;
        internal const double PresentationFactorWpf = 1;

        public XUnit(double point)
        {
            _value = point;
            _type = XGraphicsUnit.Point;
        }

        public XUnit(double value, XGraphicsUnit type)
        {
            if (!Enum.IsDefined(typeof(XGraphicsUnit), type))
#if !SILVERLIGHT && !NETFX_CORE && !UWP
                throw new System.ComponentModel.InvalidEnumArgumentException(nameof(type), (int)type, typeof(XGraphicsUnit));
#endif
            _value = value;
            _type = type;
        }

        public double Value
        {
            get { return _value; }
        }

        public XGraphicsUnit Type
        {
            get { return _type; }
        }

        public double Point
        {
            get
            {
                switch (_type)
                {
                    case XGraphicsUnit.Point:
                        return _value;

                    case XGraphicsUnit.Inch:
                        return _value * 72;

                    case XGraphicsUnit.Millimeter:
                        return _value * 72 / 25.4;

                    case XGraphicsUnit.Centimeter:
                        return _value * 72 / 2.54;

                    case XGraphicsUnit.Presentation:
                        return _value * 72 / 96;

                    default:
                        throw new InvalidCastException();
                }
            }
            set
            {
                _value = value;
                _type = XGraphicsUnit.Point;
            }
        }

        public double Inch
        {
            get
            {
                switch (_type)
                {
                    case XGraphicsUnit.Point:
                        return _value / 72;

                    case XGraphicsUnit.Inch:
                        return _value;

                    case XGraphicsUnit.Millimeter:
                        return _value / 25.4;

                    case XGraphicsUnit.Centimeter:
                        return _value / 2.54;

                    case XGraphicsUnit.Presentation:
                        return _value / 96;

                    default:
                        throw new InvalidCastException();
                }
            }
            set
            {
                _value = value;
                _type = XGraphicsUnit.Inch;
            }
        }

        public double Millimeter
        {
            get
            {
                switch (_type)
                {
                    case XGraphicsUnit.Point:
                        return _value * 25.4 / 72;

                    case XGraphicsUnit.Inch:
                        return _value * 25.4;

                    case XGraphicsUnit.Millimeter:
                        return _value;

                    case XGraphicsUnit.Centimeter:
                        return _value * 10;

                    case XGraphicsUnit.Presentation:
                        return _value * 25.4 / 96;

                    default:
                        throw new InvalidCastException();
                }
            }
            set
            {
                _value = value;
                _type = XGraphicsUnit.Millimeter;
            }
        }

        public double Centimeter
        {
            get
            {
                switch (_type)
                {
                    case XGraphicsUnit.Point:
                        return _value * 2.54 / 72;

                    case XGraphicsUnit.Inch:
                        return _value * 2.54;

                    case XGraphicsUnit.Millimeter:
                        return _value / 10;

                    case XGraphicsUnit.Centimeter:
                        return _value;

                    case XGraphicsUnit.Presentation:
                        return _value * 2.54 / 96;

                    default:
                        throw new InvalidCastException();
                }
            }
            set
            {
                _value = value;
                _type = XGraphicsUnit.Centimeter;
            }
        }

        public double Presentation
        {
            get
            {
                switch (_type)
                {
                    case XGraphicsUnit.Point:
                        return _value * 96 / 72;

                    case XGraphicsUnit.Inch:
                        return _value * 96;

                    case XGraphicsUnit.Millimeter:
                        return _value * 96 / 25.4;

                    case XGraphicsUnit.Centimeter:
                        return _value * 96 / 2.54;

                    case XGraphicsUnit.Presentation:
                        return _value;

                    default:
                        throw new InvalidCastException();
                }
            }
            set
            {
                _value = value;
                _type = XGraphicsUnit.Point;
            }
        }

        public string ToString(IFormatProvider formatProvider)
        {
            string valuestring = _value.ToString(formatProvider) + GetSuffix();
            return valuestring;
        }

        string IFormattable.ToString(string format, IFormatProvider formatProvider)
        {
            string valuestring = _value.ToString(format, formatProvider) + GetSuffix();
            return valuestring;
        }

        public override string ToString()
        {
            string valuestring = _value.ToString(CultureInfo.InvariantCulture) + GetSuffix();
            return valuestring;
        }

        string GetSuffix()
        {
            switch (_type)
            {
                case XGraphicsUnit.Point:
                    return "pt";

                case XGraphicsUnit.Inch:
                    return "in";

                case XGraphicsUnit.Millimeter:
                    return "mm";

                case XGraphicsUnit.Centimeter:
                    return "cm";

                case XGraphicsUnit.Presentation:
                    return "pu";

                default:
                    throw new InvalidCastException();
            }
        }

        public static XUnit FromPoint(double value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Point;
            return unit;
        }

        public static XUnit FromInch(double value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Inch;
            return unit;
        }

        public static XUnit FromMillimeter(double value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Millimeter;
            return unit;
        }

        public static XUnit FromCentimeter(double value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Centimeter;
            return unit;
        }

        public static XUnit FromPresentation(double value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Presentation;
            return unit;
        }

        public static implicit operator XUnit(string value)
        {
            XUnit unit;
            value = value.Trim();

            value = value.Replace(',', '.');

            int count = value.Length;
            int valLen = 0;
            for (; valLen < count;)
            {
                char ch = value[valLen];
                if (ch == '.' || ch == '-' || ch == '+' || char.IsNumber(ch))
                    valLen++;
                else
                    break;
            }

            try
            {
                unit._value = Double.Parse(value.Substring(0, valLen).Trim(), CultureInfo.InvariantCulture);
            }
            catch (Exception ex)
            {
                unit._value = 1;
                string message = String.Format("String '{0}' is not a valid value for structure 'XUnit'.", value);
                throw new ArgumentException(message, ex);
            }

            string typeStr = value.Substring(valLen).Trim().ToLower();
            unit._type = XGraphicsUnit.Point;
            switch (typeStr)
            {
                case "cm":
                    unit._type = XGraphicsUnit.Centimeter;
                    break;

                case "in":
                    unit._type = XGraphicsUnit.Inch;
                    break;

                case "mm":
                    unit._type = XGraphicsUnit.Millimeter;
                    break;

                case "":
                case "pt":
                    unit._type = XGraphicsUnit.Point;
                    break;

                case "pu":
                    unit._type = XGraphicsUnit.Presentation;
                    break;

                default:
                    throw new ArgumentException("Unknown unit type: '" + typeStr + "'");
            }
            return unit;
        }

        public static implicit operator XUnit(int value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Point;
            return unit;
        }

        public static implicit operator XUnit(double value)
        {
            XUnit unit;
            unit._value = value;
            unit._type = XGraphicsUnit.Point;
            return unit;
        }

        public static implicit operator double(XUnit value)
        {
            return value.Point;
        }

        public static bool operator ==(XUnit value1, XUnit value2)
        {
            return value1._type == value2._type && value1._value == value2._value;
        }

        public static bool operator !=(XUnit value1, XUnit value2)
        {
            return !(value1 == value2);
        }

        public override bool Equals(Object obj)
        {
            if (obj is XUnit)
                return this == (XUnit)obj;
            return false;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode() ^ _type.GetHashCode();
        }

        public static XUnit Parse(string value)
        {
            XUnit unit = value;
            return unit;
        }

        public void ConvertType(XGraphicsUnit type)
        {
            if (_type == type)
                return;

            switch (type)
            {
                case XGraphicsUnit.Point:
                    _value = Point;
                    _type = XGraphicsUnit.Point;
                    break;

                case XGraphicsUnit.Inch:
                    _value = Inch;
                    _type = XGraphicsUnit.Inch;
                    break;

                case XGraphicsUnit.Centimeter:
                    _value = Centimeter;
                    _type = XGraphicsUnit.Centimeter;
                    break;

                case XGraphicsUnit.Millimeter:
                    _value = Millimeter;
                    _type = XGraphicsUnit.Millimeter;
                    break;

                case XGraphicsUnit.Presentation:
                    _value = Presentation;
                    _type = XGraphicsUnit.Presentation;
                    break;

                default:
                    throw new ArgumentException("Unknown unit type: '" + type + "'");
            }
        }

        public static readonly XUnit Zero = new XUnit();

        double _value;
        XGraphicsUnit _type;

        string DebuggerDisplay
        {
            get
            {
                const string format = Config.SignificantFigures10;
                return String.Format(CultureInfo.InvariantCulture, "unit=({0:" + format + "} {1})", _value, GetSuffix());
            }
        }
    }
    public struct XVector : IFormattable
    {
        public XVector(double x, double y)
        {
            _x = x;
            _y = y;
        }

        public static bool operator ==(XVector vector1, XVector vector2)
        {
            return vector1._x == vector2._x && vector1._y == vector2._y;
        }

        public static bool operator !=(XVector vector1, XVector vector2)
        {
            return vector1._x != vector2._x || vector1._y != vector2._y;
        }

        public static bool Equals(XVector vector1, XVector vector2)
        {
            if (vector1.X.Equals(vector2.X))
                return vector1.Y.Equals(vector2.Y);
            return false;
        }

        public override bool Equals(object o)
        {
            if (!(o is XVector))
                return false;
            return Equals(this, (XVector)o);
        }

        public bool Equals(XVector value)
        {
            return Equals(this, value);
        }

        public override int GetHashCode()
        {
            return _x.GetHashCode() ^ _y.GetHashCode();
        }

        public static XVector Parse(string source)
        {
            TokenizerHelper helper = new TokenizerHelper(source, CultureInfo.InvariantCulture);
            string str = helper.NextTokenRequired();
            XVector vector = new XVector(Convert.ToDouble(str, CultureInfo.InvariantCulture), Convert.ToDouble(helper.NextTokenRequired(), CultureInfo.InvariantCulture));
            helper.LastTokenRequired();
            return vector;
        }

        public double X
        {
            get { return _x; }
            set { _x = value; }
        }
        double _x;

        public double Y
        {
            get { return _y; }
            set { _y = value; }
        }
        double _y;

        public override string ToString()
        {
            return ConvertToString(null, null);
        }

        public string ToString(IFormatProvider provider)
        {
            return ConvertToString(null, provider);
        }

        string IFormattable.ToString(string format, IFormatProvider provider)
        {
            return ConvertToString(format, provider);
        }

        internal string ConvertToString(string format, IFormatProvider provider)
        {
            const char numericListSeparator = ',';
            provider = provider ?? CultureInfo.InvariantCulture;
            return string.Format(provider, "{1:" + format + "}{0}{2:" + format + "}", numericListSeparator, _x, _y);
        }

        public double Length
        {
            get { return Math.Sqrt(_x * _x + _y * _y); }
        }

        public double LengthSquared
        {
            get { return _x * _x + _y * _y; }
        }

        public void Normalize()
        {
            this = this / Math.Max(Math.Abs(_x), Math.Abs(_y));
            this = this / Length;
        }

        public static double CrossProduct(XVector vector1, XVector vector2)
        {
            return vector1._x * vector2._y - vector1._y * vector2._x;
        }

        public static double AngleBetween(XVector vector1, XVector vector2)
        {
            double y = vector1._x * vector2._y - vector2._x * vector1._y;
            double x = vector1._x * vector2._x + vector1._y * vector2._y;
            return (Math.Atan2(y, x) * 57.295779513082323);
        }

        public static XVector operator -(XVector vector)
        {
            return new XVector(-vector._x, -vector._y);
        }

        public void Negate()
        {
            _x = -_x;
            _y = -_y;
        }

        public static XVector operator +(XVector vector1, XVector vector2)
        {
            return new XVector(vector1._x + vector2._x, vector1._y + vector2._y);
        }

        public static XVector Add(XVector vector1, XVector vector2)
        {
            return new XVector(vector1._x + vector2._x, vector1._y + vector2._y);
        }

        public static XVector operator -(XVector vector1, XVector vector2)
        {
            return new XVector(vector1._x - vector2._x, vector1._y - vector2._y);
        }

        public static XVector Subtract(XVector vector1, XVector vector2)
        {
            return new XVector(vector1._x - vector2._x, vector1._y - vector2._y);
        }

        public static XPoint operator +(XVector vector, XPoint point)
        {
            return new XPoint(point.X + vector._x, point.Y + vector._y);
        }

        public static XPoint Add(XVector vector, XPoint point)
        {
            return new XPoint(point.X + vector._x, point.Y + vector._y);
        }

        public static XVector operator *(XVector vector, double scalar)
        {
            return new XVector(vector._x * scalar, vector._y * scalar);
        }

        public static XVector Multiply(XVector vector, double scalar)
        {
            return new XVector(vector._x * scalar, vector._y * scalar);
        }

        public static XVector operator *(double scalar, XVector vector)
        {
            return new XVector(vector._x * scalar, vector._y * scalar);
        }

        public static XVector Multiply(double scalar, XVector vector)
        {
            return new XVector(vector._x * scalar, vector._y * scalar);
        }

        public static XVector operator /(XVector vector, double scalar)
        {
            return vector * (1.0 / scalar);
        }

        public static XVector Divide(XVector vector, double scalar)
        {
            return vector * (1.0 / scalar);
        }

        public static XVector operator *(XVector vector, XMatrix matrix)
        {
            return matrix.Transform(vector);
        }

        public static XVector Multiply(XVector vector, XMatrix matrix)
        {
            return matrix.Transform(vector);
        }

        public static double operator *(XVector vector1, XVector vector2)
        {
            return vector1._x * vector2._x + vector1._y * vector2._y;
        }

        public static double Multiply(XVector vector1, XVector vector2)
        {
            return vector1._x * vector2._x + vector1._y * vector2._y;
        }

        public static double Determinant(XVector vector1, XVector vector2)
        {
            return vector1._x * vector2._y - vector1._y * vector2._x;
        }

        public static explicit operator XSize(XVector vector)
        {
            return new XSize(Math.Abs(vector._x), Math.Abs(vector._y));
        }

        public static explicit operator XPoint(XVector vector)
        {
            return new XPoint(vector._x, vector._y);
        }

        string DebuggerDisplay
        {
            get
            {
                const string format = Config.SignificantFigures10;
                return string.Format(CultureInfo.InvariantCulture, "vector=({0:" + format + "}, {1:" + format + "})", _x, _y);
            }
        }
    }
    public enum AnchorType
    {
        TopLeft,

        TopCenter,

        TopRight,

        MiddleLeft,

        MiddleCenter,

        MiddleRight,

        BottomLeft,

        BottomCenter,

        BottomRight,
    }
    public enum CodeDirection
    {
        LeftToRight,

        BottomToTop,

        RightToLeft,

        TopToBottom,
    }
    public enum CodeType
    {
        Code2of5Interleaved,

        Code3of9Standard,

        Omr,

        DataMatrix,
    }
    public enum DataMatrixEncoding
    {
        Ascii,

        C40,

        Text,

        X12,

        EDIFACT,

        Base256
    }
    public enum TextLocation
    {
        None,

        Above,

        Below,


        AboveEmbedded,


        BelowEmbedded,
    }
    public abstract class BarCode : CodeBase
    {
        public BarCode(string text, XSize size, CodeDirection direction)
            : base(text, size, direction)
        {
            Text = text;
            Size = size;
            Direction = direction;
        }

        public static BarCode FromType(CodeType type, string text, XSize size, CodeDirection direction)
        {
            switch (type)
            {
                case CodeType.Code2of5Interleaved:
                    return new Code2of5Interleaved(text, size, direction);

                case CodeType.Code3of9Standard:
                    return new Code3of9Standard(text, size, direction);

                default:
                    throw new InvalidEnumArgumentException("type", (int)type, typeof(CodeType));
            }
        }

        public static BarCode FromType(CodeType type, string text, XSize size)
        {
            return FromType(type, text, size, CodeDirection.LeftToRight);
        }

        public static BarCode FromType(CodeType type, string text)
        {
            return FromType(type, text, XSize.Empty, CodeDirection.LeftToRight);
        }

        public static BarCode FromType(CodeType type)
        {
            return FromType(type, String.Empty, XSize.Empty, CodeDirection.LeftToRight);
        }

        public virtual double WideNarrowRatio
        {
            get { return 0; }
            set { }
        }

        public TextLocation TextLocation
        {
            get { return _textLocation; }
            set { _textLocation = value; }
        }
        TextLocation _textLocation;

        public int DataLength
        {
            get { return _dataLength; }
            set { _dataLength = value; }
        }
        int _dataLength;

        public char StartChar
        {
            get { return _startChar; }
            set { _startChar = value; }
        }
        char _startChar;

        public char EndChar
        {
            get { return _endChar; }
            set { _endChar = value; }
        }
        char _endChar;

        public virtual bool TurboBit
        {
            get { return _turboBit; }
            set { _turboBit = value; }
        }
        bool _turboBit;

        internal virtual void InitRendering(BarCodeRenderInfo info)
        {
            if (Text == null)
                throw new InvalidOperationException(BcgSR.BarCodeNotSet);

            if (Size.IsEmpty)
                throw new InvalidOperationException(BcgSR.EmptyBarCodeSize);
        }

        protected internal abstract void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position);
    }
    class BarCodeRenderInfo
    {
        public BarCodeRenderInfo(XGraphics gfx, XBrush brush, XFont font, XPoint position)
        {
            Gfx = gfx;
            Brush = brush;
            Font = font;
            Position = position;
        }

        public XGraphics Gfx;
        public XBrush Brush;
        public XFont Font;
        public XPoint Position;
        public double BarHeight;
        public XPoint CurrPos;
        public int CurrPosInString;
        public double ThinBarWidth;
    }
    internal class BcgSR
    {
        internal static string Invalid2Of5Code(string code)
        {
            return string.Format("'{0}' is not a valid code for an interleave 2 of 5 bar code. It can only represent an even number of digits.", code);
        }

        internal static string Invalid3Of9Code(string code)
        {
            return string.Format("'{0}' is not a valid code for a 3 of 9 standard bar code.", code);
        }

        internal static string BarCodeNotSet
        {
            get { return "A text must be set before rendering the bar code."; }
        }

        internal static string EmptyBarCodeSize
        {
            get { return "A non-empty size must be set before rendering the bar code."; }
        }

        internal static string Invalid2of5Relation
        {
            get { return "Value of relation between thick and thin lines on the interleaved 2 of 5 code must be between 2 and 3."; }
        }

        internal static string InvalidMarkName(string name)
        {
            return string.Format("'{0}' is not a valid mark name for this OMR representation.", name);
        }

        internal static string OmrAlreadyInitialized
        {
            get { return "Mark descriptions cannot be set when marks have already been set on OMR."; }
        }

        internal static string DataMatrixTooBig
        {
            get { return "The given data and encoding combination is too big for the matrix size."; }
        }

        internal static string DataMatrixNotSupported
        {
            get { return "Zero sizes, odd sizes and other than ecc200 coded DataMatrix is not supported."; }
        }

        internal static string DataMatrixNull
        {
            get { return "No DataMatrix code is produced."; }
        }

        internal static string DataMatrixInvalid(int columns, int rows)
        {
            return string.Format("'{1}'x'{0}' is an invalid ecc200 DataMatrix size.", columns, rows);
        }
    }
    public class Code2of5Interleaved : ThickThinBarCode
    {
        public Code2of5Interleaved()
            : base("", XSize.Empty, CodeDirection.LeftToRight)
        { }

        public Code2of5Interleaved(string code)
            : base(code, XSize.Empty, CodeDirection.LeftToRight)
        { }

        public Code2of5Interleaved(string code, XSize size)
            : base(code, size, CodeDirection.LeftToRight)
        { }

        public Code2of5Interleaved(string code, XSize size, CodeDirection direction)
            : base(code, size, direction)
        { }

        static bool[] ThickAndThinLines(int digit)
        {
            return Lines[digit];
        }
        static bool[][] Lines =
        {
            new bool[] {false, false, true, true, false},
            new bool[] {true, false, false, false, true},
            new bool[] {false, true, false, false, true},
            new bool[] {true, true, false, false, false},
            new bool[] {false, false, true, false, true},
            new bool[] {true, false, true, false, false},
            new bool[] {false, true, true, false, false},
            new bool[] {false, false, false, true, true},
            new bool[] {true, false, false, true, false},
            new bool[] {false, true, false, true, false},
        };

        protected internal override void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position)
        {
            XGraphicsState state = gfx.Save();

            BarCodeRenderInfo info = new BarCodeRenderInfo(gfx, brush, font, position);
            InitRendering(info);
            info.CurrPosInString = 0;
            info.CurrPos = position - CodeBase.CalcDistance(AnchorType.TopLeft, Anchor, Size);

            if (TurboBit)
                RenderTurboBit(info, true);
            RenderStart(info);
            while (info.CurrPosInString < Text.Length)
                RenderNextPair(info);
            RenderStop(info);
            if (TurboBit)
                RenderTurboBit(info, false);
            if (TextLocation != TextLocation.None)
                RenderText(info);

            gfx.Restore(state);
        }

        internal override void CalcThinBarWidth(BarCodeRenderInfo info)
        {
            double thinLineAmount = 6 + WideNarrowRatio + (2 * WideNarrowRatio + 3) * Text.Length;
            info.ThinBarWidth = Size.Width / thinLineAmount;
        }

        private void RenderStart(BarCodeRenderInfo info)
        {
            RenderBar(info, false);
            RenderGap(info, false);
            RenderBar(info, false);
            RenderGap(info, false);
        }

        private void RenderStop(BarCodeRenderInfo info)
        {
            RenderBar(info, true);
            RenderGap(info, false);
            RenderBar(info, false);
        }

        private void RenderNextPair(BarCodeRenderInfo info)
        {
            int digitForLines = int.Parse(Text[info.CurrPosInString].ToString());
            int digitForGaps = int.Parse(Text[info.CurrPosInString + 1].ToString());
            bool[] linesArray = Lines[digitForLines];
            bool[] gapsArray = Lines[digitForGaps];
            for (int idx = 0; idx < 5; ++idx)
            {
                RenderBar(info, linesArray[idx]);
                RenderGap(info, gapsArray[idx]);
            }
            info.CurrPosInString += 2;
        }

        protected override void CheckCode(string text)
        {
        }
    }
    public class Code3of9Standard : ThickThinBarCode
    {
        public Code3of9Standard()
            : base("", XSize.Empty, CodeDirection.LeftToRight)
        { }

        public Code3of9Standard(string code)
            : base(code, XSize.Empty, CodeDirection.LeftToRight)
        { }

        public Code3of9Standard(string code, XSize size)
            : base(code, size, CodeDirection.LeftToRight)
        { }

        public Code3of9Standard(string code, XSize size, CodeDirection direction)
            : base(code, size, direction)
        { }

        private static bool[] ThickThinLines(char ch)
        {
            return Lines["0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*".IndexOf(ch)];
        }
        static readonly bool[][] Lines =
        {
            new bool[] {false, false, false, true, true, false, true, false, false},
            new bool[] {true, false, false, true, false, false, false, false, true},
            new bool[] {false, false, true, true, false, false, false, false, true},
            new bool[] {true, false, true, true, false, false, false, false, false},
            new bool[] {false, false, false, true, true, false, false, false, true},
            new bool[] {true, false, false, true, true, false, false, false, false},
            new bool[] {false, false, true, true, true, false, false, false, false},
            new bool[] {false, false, false, true, false, false, true, false, true},
            new bool[] {true, false, false, true, false, false, true, false, false},
            new bool[] {false, false, true, true, false, false, true, false, false},
            new bool[] {true, false, false, false, false, true, false, false, true},
            new bool[] {false, false, true, false, false, true, false, false, true},
            new bool[] {true, false, true, false, false, true, false, false, false},
            new bool[] {false, false, false, false, true, true, false, false, true},
            new bool[] {true, false, false, false, true, true, false, false, false},
            new bool[] {false, false, true, false, true, true, false, false, false},
            new bool[] {false, false, false, false, false, true, true, false, true},
            new bool[] {true, false, false, false, false, true, true, false, false},
            new bool[] {false, false, true, false, false, true, true, false, false},
            new bool[] {false, false, false, false, true, true, true, false, false},
            new bool[] {true, false, false, false, false, false, false, true, true},
            new bool[] {false, false, true, false, false, false, false, true, true},
            new bool[] {true, false, true, false, false, false, false, true, false},
            new bool[] {false, false, false, false, true, false, false, true, true},
            new bool[] {true, false, false, false, true, false, false, true, false},
            new bool[] {false, false, true, false, true, false, false, true, false},
            new bool[] {false, false, false, false, false, false, true, true, true},
            new bool[] {true, false, false, false, false, false, true, true, false},
            new bool[] {false, false, true, false, false, false, true, true, false},
            new bool[] {false, false, false, false, true, false, true, true, false},
            new bool[] {true, true, false, false, false, false, false, false, true},
            new bool[] {false, true, true, false, false, false, false, false, true},
            new bool[] {true, true, true, false, false, false, false, false, false},
            new bool[] {false, true, false, false, true, false, false, false, true},
            new bool[] {true, true, false, false, true, false, false, false, false},
            new bool[] {false, true, true, false, true, false, false, false, false},
            new bool[] {false, true, false, false, false, false, true, false, true},
            new bool[] {true, true, false, false, false, false, true, false, false},
            new bool[] {false, true, true, false, false, false, true, false, false},
            new bool[] {false, true, false, true, false, true, false, false, false},
            new bool[] {false, true, false, true, false, false, false, true, false},
            new bool[] {false, true, false, false, false, true, false, true, false},
            new bool[] {false, false, false, true, false, true, false, true, false},
            new bool[] {false, true, false, false, true, false, true, false, false},
        };


        internal override void CalcThinBarWidth(BarCodeRenderInfo info)
        {
            double thinLineAmount = 13 + 6 * WideNarrowRatio + (3 * WideNarrowRatio + 7) * Text.Length;
            info.ThinBarWidth = Size.Width / thinLineAmount;
        }

        protected override void CheckCode(string text)
        {
            if (text == null)
                throw new ArgumentNullException("text");

            if (text.Length == 0)
                throw new ArgumentException(BcgSR.Invalid3Of9Code(text));

            foreach (char ch in text)
            {
                if ("0123456789ABCDEFGHIJKLMNOP'QRSTUVWXYZ-. $/+%*".IndexOf(ch) < 0)
                    throw new ArgumentException(BcgSR.Invalid3Of9Code(text));
            }
        }

        protected internal override void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position)
        {
            XGraphicsState state = gfx.Save();

            BarCodeRenderInfo info = new BarCodeRenderInfo(gfx, brush, font, position);
            InitRendering(info);
            info.CurrPosInString = 0;
            info.CurrPos = position - CalcDistance(AnchorType.TopLeft, Anchor, Size);

            if (TurboBit)
                RenderTurboBit(info, true);
            RenderStart(info);
            while (info.CurrPosInString < Text.Length)
            {
                RenderNextChar(info);
                RenderGap(info, false);
            }
            RenderStop(info);
            if (TurboBit)
                RenderTurboBit(info, false);
            if (TextLocation != TextLocation.None)
                RenderText(info);

            gfx.Restore(state);
        }

        private void RenderNextChar(BarCodeRenderInfo info)
        {
            RenderChar(info, Text[info.CurrPosInString]);
            ++info.CurrPosInString;
        }

        private void RenderChar(BarCodeRenderInfo info, char ch)
        {
            bool[] thickThinLines = ThickThinLines(ch);
            int idx = 0;
            while (idx < 9)
            {
                RenderBar(info, thickThinLines[idx]);
                if (idx < 8)
                    RenderGap(info, thickThinLines[idx + 1]);
                idx += 2;
            }
        }

        private void RenderStart(BarCodeRenderInfo info)
        {
            RenderChar(info, '*');
            RenderGap(info, false);
        }

        private void RenderStop(BarCodeRenderInfo info)
        {
            RenderChar(info, '*');
        }
    }
    public abstract class CodeBase
    {
        public CodeBase(string text, XSize size, CodeDirection direction)
        {
            _text = text;
            _size = size;
            _direction = direction;
        }

        public XSize Size
        {
            get { return _size; }
            set { _size = value; }
        }
        XSize _size;

        public string Text
        {
            get { return _text; }
            set
            {
                CheckCode(value);
                _text = value;
            }
        }
        string _text;

        public AnchorType Anchor
        {
            get { return _anchor; }
            set { _anchor = value; }
        }
        AnchorType _anchor;

        public CodeDirection Direction
        {
            get { return _direction; }
            set { _direction = value; }
        }
        CodeDirection _direction;

        protected abstract void CheckCode(string text);

        public static XVector CalcDistance(AnchorType oldType, AnchorType newType, XSize size)
        {
            if (oldType == newType)
                return new XVector();

            XVector result;
            Delta delta = Deltas[(int)oldType, (int)newType];
            result = new XVector(size.Width / 2 * delta.X, size.Height / 2 * delta.Y);
            return result;
        }

        struct Delta
        {
            public Delta(int x, int y)
            {
                X = x;
                Y = y;
            }
            public readonly int X;
            public readonly int Y;
        }
        static readonly Delta[,] Deltas = new Delta[9, 9]
        {
              { new Delta(0, 0),   new Delta(1, 0),   new Delta(2, 0),  new Delta(0, 1),   new Delta(1, 1),   new Delta(2, 1),  new Delta(0, 2),  new Delta(1, 2),  new Delta(2, 2) },
              { new Delta(-1, 0),  new Delta(0, 0),   new Delta(1, 0),  new Delta(-1, 1),  new Delta(0, 1),   new Delta(1, 1),  new Delta(-1, 2), new Delta(0, 2),  new Delta(1, 2) },
              { new Delta(-2, 0),  new Delta(-1, 0),  new Delta(0, 0),  new Delta(-2, 1),  new Delta(-1, 1),  new Delta(0, 1),  new Delta(-2, 2), new Delta(-1, 2), new Delta(0, 2) },
              { new Delta(0, -1),  new Delta(1, -1),  new Delta(2, -1), new Delta(0, 0),   new Delta(1, 0),   new Delta(2, 0),  new Delta(0, 1),  new Delta(1, 1),  new Delta(2, 1) },
              { new Delta(-1, -1), new Delta(0, -1),  new Delta(1, -1), new Delta(-1, 0),  new Delta(0, 0),   new Delta(1, 0),  new Delta(-1, 1), new Delta(0, 1),  new Delta(1, 1) },
              { new Delta(-2, -1), new Delta(-1, -1), new Delta(0, -1), new Delta(-2, 0),  new Delta(-1, 0),  new Delta(0, 0),  new Delta(-2, 1), new Delta(-1, 1), new Delta(0, 1) },
              { new Delta(0, -2),  new Delta(1, -2),  new Delta(2, -2), new Delta(0, -1),  new Delta(1, -1),  new Delta(2, -1), new Delta(0, 0),  new Delta(1, 0),  new Delta(2, 0) },
              { new Delta(-1, -2), new Delta(0, -2),  new Delta(1, -2), new Delta(-1, -1), new Delta(0, -1),  new Delta(1, -1), new Delta(-1, 0), new Delta(0, 0),  new Delta(1, 0) },
              { new Delta(-2, -2), new Delta(-1, -2), new Delta(0, -2), new Delta(-2, -1), new Delta(-1, -1), new Delta(0, -1), new Delta(-2, 0), new Delta(-1, 0), new Delta(0, 0) },
        };
    }
    public class CodeDataMatrix : MatrixCode
    {
        public CodeDataMatrix()
            : this("", "", 26, 26, 0, XSize.Empty)
        { }

        public CodeDataMatrix(string code, int length)
            : this(code, "", length, length, 0, XSize.Empty)
        { }

        public CodeDataMatrix(string code, int length, XSize size)
            : this(code, "", length, length, 0, size)
        { }

        public CodeDataMatrix(string code, DataMatrixEncoding dmEncoding, int length, XSize size)
            : this(code, CreateEncoding(dmEncoding, code.Length), length, length, 0, size)
        { }

        public CodeDataMatrix(string code, int rows, int columns)
            : this(code, "", rows, columns, 0, XSize.Empty)
        { }

        public CodeDataMatrix(string code, int rows, int columns, XSize size)
            : this(code, "", rows, columns, 0, size)
        { }

        public CodeDataMatrix(string code, DataMatrixEncoding dmEncoding, int rows, int columns, XSize size)
            : this(code, CreateEncoding(dmEncoding, code.Length), rows, columns, 0, size)
        { }

        public CodeDataMatrix(string code, int rows, int columns, int quietZone)
            : this(code, "", rows, columns, quietZone, XSize.Empty)
        { }

        public CodeDataMatrix(string code, string encoding, int rows, int columns, int quietZone, XSize size)
            : base(code, encoding, rows, columns, size)
        {
            QuietZone = quietZone;
        }

        public void SetEncoding(DataMatrixEncoding dmEncoding)
        {
            Encoding = CreateEncoding(dmEncoding, Text.Length);
        }

        static string CreateEncoding(DataMatrixEncoding dmEncoding, int length)
        {
            string tempencoding = "";
            switch (dmEncoding)
            {
                case DataMatrixEncoding.Ascii:
                    tempencoding = new string('a', length);
                    break;
                case DataMatrixEncoding.C40:
                    tempencoding = new string('c', length);
                    break;
                case DataMatrixEncoding.Text:
                    tempencoding = new string('t', length);
                    break;
                case DataMatrixEncoding.X12:
                    tempencoding = new string('x', length);
                    break;
                case DataMatrixEncoding.EDIFACT:
                    tempencoding = new string('e', length);
                    break;
                case DataMatrixEncoding.Base256:
                    tempencoding = new string('b', length);
                    break;
            }
            return tempencoding;
        }

        public int QuietZone
        {
            get { return _quietZone; }
            set { _quietZone = value; }
        }
        int _quietZone;

        protected internal override void Render(XGraphics gfx, XBrush brush, XPoint position)
        {
            XGraphicsState state = gfx.Save();

            switch (Direction)
            {
                case CodeDirection.RightToLeft:
                    gfx.RotateAtTransform(180, position);
                    break;

                case CodeDirection.TopToBottom:
                    gfx.RotateAtTransform(90, position);
                    break;

                case CodeDirection.BottomToTop:
                    gfx.RotateAtTransform(-90, position);
                    break;
            }

            XPoint pos = position + CalcDistance(Anchor, AnchorType.TopLeft, Size);

            if (MatrixImage == null)
                MatrixImage = DataMatrixImage.GenerateMatrixImage(Text, Encoding, Rows, Columns);

            if (QuietZone > 0)
            {
                XSize sizeWithZone = new XSize(Size.Width, Size.Height);
                sizeWithZone.Width = sizeWithZone.Width / (Columns + 2 * QuietZone) * Columns;
                sizeWithZone.Height = sizeWithZone.Height / (Rows + 2 * QuietZone) * Rows;

                XPoint posWithZone = new XPoint(pos.X, pos.Y);
                posWithZone.X += Size.Width / (Columns + 2 * QuietZone) * QuietZone;
                posWithZone.Y += Size.Height / (Rows + 2 * QuietZone) * QuietZone;

                gfx.DrawRectangle(XBrushes.White, pos.X, pos.Y, Size.Width, Size.Height);
                gfx.DrawImage(MatrixImage, posWithZone.X, posWithZone.Y, sizeWithZone.Width, sizeWithZone.Height);
            }
            else
                gfx.DrawImage(MatrixImage, pos.X, pos.Y, Size.Width, Size.Height);

            gfx.Restore(state);
        }

        protected override void CheckCode(string text)
        {
            if (text == null)
                throw new ArgumentNullException("text");

            DataMatrixImage mImage = new DataMatrixImage(Text, Encoding, Rows, Columns);
            mImage.Iec16022Ecc200(Columns, Rows, Encoding, Text.Length, Text, 0, 0, 0);
        }
    }
    public class CodeOmr : BarCode
    {
        public CodeOmr(string text, XSize size, CodeDirection direction)
            : base(text, size, direction)
        { }

        protected internal override void Render(XGraphics gfx, XBrush brush, XFont font, XPoint position)
        {
            XGraphicsState state = gfx.Save();

            switch (Direction)
            {
                case CodeDirection.RightToLeft:
                    gfx.RotateAtTransform(180, position);
                    break;

                case CodeDirection.TopToBottom:
                    gfx.RotateAtTransform(90, position);
                    break;

                case CodeDirection.BottomToTop:
                    gfx.RotateAtTransform(-90, position);
                    break;
            }

            XPoint pt = position - CodeBase.CalcDistance(AnchorType.TopLeft, Anchor, Size);
            uint value;
            uint.TryParse(Text, out value);
#if true
            value |= 1;
            _synchronizeCode = true;
#endif
            if (_synchronizeCode)
            {
                XRect rect = new XRect(pt.X, pt.Y, _makerThickness, Size.Height);
                gfx.DrawRectangle(brush, rect);
                pt.X += 2 * _makerDistance;
            }
            for (int idx = 0; idx < 32; idx++)
            {
                if ((value & 1) == 1)
                {
                    XRect rect = new XRect(pt.X + idx * _makerDistance, pt.Y, _makerThickness, Size.Height);
                    gfx.DrawRectangle(brush, rect);
                }
                value = value >> 1;
            }
            gfx.Restore(state);
        }

        public bool SynchronizeCode
        {
            get { return _synchronizeCode; }
            set { _synchronizeCode = value; }
        }
        bool _synchronizeCode;

        public double MakerDistance
        {
            get { return _makerDistance; }
            set { _makerDistance = value; }
        }
        double _makerDistance = 12;

        public double MakerThickness
        {
            get { return _makerThickness; }
            set { _makerThickness = value; }
        }
        double _makerThickness = 1;

        protected override void CheckCode(string text)
        { }
    }
    internal class DataMatrixImage
    {
        public static XImage GenerateMatrixImage(string text, string encoding, int rows, int columns)
        {
            DataMatrixImage dataMatrixImage = new DataMatrixImage(text, encoding, rows, columns);
            return dataMatrixImage.DrawMatrix();
        }

        public DataMatrixImage(string text, string encoding, int rows, int columns)
        {
            _text = text;
            _encoding = encoding;
            _rows = rows;
            _columns = columns;
        }

        string _encoding;
        readonly string _text;
        readonly int _rows;
        readonly int _columns;

        static Ecc200Block[] ecc200Sizes =
    {
      new Ecc200Block( 10,  10, 10, 10,    3,   3,  5),
      new Ecc200Block( 12,  12, 12, 12,    5,   5,  7),
      new Ecc200Block(  8,  18,  8, 18,    5,   5,  7),
      new Ecc200Block( 14,  14, 14, 14,    8,   8, 10),
      new Ecc200Block(  8,  32,  8, 16,   10,  10, 11),
      new Ecc200Block( 16,  16, 16, 16,   12,  12, 12),
      new Ecc200Block( 12,  26, 12, 26,   16,  16, 14),
      new Ecc200Block( 18,  18, 18, 18,   18,  18, 14),
      new Ecc200Block( 20,  20, 20, 20,   22,  22, 18),
      new Ecc200Block( 12,  36, 12, 18,   22,  22, 18),
      new Ecc200Block( 22,  22, 22, 22,   30,  30, 20),
      new Ecc200Block( 16,  36, 16, 18,   32,  32, 24),
      new Ecc200Block( 24,  24, 24, 24,   36,  36, 24),
      new Ecc200Block( 26,  26, 26, 26,   44,  44, 28),
      new Ecc200Block( 16,  48, 16, 24,   49,  49, 28),
      new Ecc200Block( 32,  32, 16, 16,   62,  62, 36),
      new Ecc200Block( 36,  36, 18, 18,   86,  86, 42),
      new Ecc200Block( 40,  40, 20, 20,  114, 114, 48),
      new Ecc200Block( 44,  44, 22, 22,  144, 144, 56),
      new Ecc200Block( 48,  48, 24, 24,  174, 174, 68),
      new Ecc200Block( 52,  52, 26, 26,  204, 102, 42),
      new Ecc200Block( 64,  64, 16, 16,  280, 140, 56),
      new Ecc200Block( 72,  72, 18, 18,  368,  92, 36),
      new Ecc200Block( 80,  80, 20, 20,  456, 114, 48),
      new Ecc200Block( 88,  88, 22, 22,  576, 144, 56),
      new Ecc200Block( 96,  96, 24, 24,  696, 174, 68),
      new Ecc200Block(104, 104, 26, 26,  816, 136, 56),
      new Ecc200Block(120, 120, 20, 20, 1050, 175, 68),
      new Ecc200Block(132, 132, 22, 22, 1304, 163, 62),
      new Ecc200Block(144, 144, 24, 24, 1558, 156, 62),
      new Ecc200Block(  0,   0,  0,  0,    0,    0, 0)
    };

        public XImage DrawMatrix()
        {
            return CreateImage(DataMatrix(), _rows, _columns);
        }

        internal char[] DataMatrix()
        {
            int matrixColumns = _columns;
            int matrixRows = _rows;
            int ecc = 200;
            if (String.IsNullOrEmpty(_encoding))
                _encoding = new String('a', _text.Length);
            int len = 0;
            int maxlen = 0;
            int ecclen = 0;
            char[] grid = null;

            if (matrixColumns != 0 && matrixRows != 0 && (matrixColumns & 1) != 0 && (matrixRows & 1) != 0 && ecc == 200)
                throw new ArgumentException(BcgSR.DataMatrixNotSupported);

            grid = Iec16022Ecc200(matrixColumns, matrixRows, _encoding, _text.Length, _text, len, maxlen, ecclen);

            if (grid == null || matrixColumns == 0)
                throw new ArgumentException(BcgSR.DataMatrixNull);
            return grid;
        }

        internal char[] Iec16022Ecc200(int columns, int rows, string encoding, int barcodeLength, string barcode, int len, int max, int ecc)
        {
            char[] binary = new char[3000];
            Ecc200Block matrix = new Ecc200Block(0, 0, 0, 0, 0, 0, 0);
            for (int i = 0; i < 3000; i++)
                binary[i] = (char)0;

            foreach (Ecc200Block eccmatrix in ecc200Sizes)
            {
                matrix = eccmatrix;
                if (matrix.Width == columns && matrix.Height == rows)
                    break;
            }

            if (matrix.Width == 0)
                throw new ArgumentException(BcgSR.DataMatrixInvalid(columns, rows));

            if (!Ecc200Encode(ref binary, matrix.Bytes, barcode, barcodeLength, encoding, ref len))
                throw new ArgumentException(BcgSR.DataMatrixTooBig);

            Ecc200(binary, matrix.Bytes, matrix.DataBlock, matrix.RSBlock);
            int x;
            int y;
            int NR;
            int[] places;
            int NC = columns - 2 * (columns / matrix.CellWidth);
            NR = rows - 2 * (rows / matrix.CellHeight);
            places = new int[NC * NR];
            Ecc200Placement(ref places, NR, NC);
            char[] grid = new char[columns * rows];
            for (y = 0; y < rows; y += matrix.CellHeight)
            {
                for (x = 0; x < columns; x++)
                    grid[y * columns + x] = (char)1;
                for (x = 0; x < columns; x += 2)
                    grid[(y + matrix.CellHeight - 1) * columns + x] = (char)1;
            }

            for (x = 0; x < columns; x += matrix.CellWidth)
            {
                for (y = 0; y < rows; y++)
                    grid[y * columns + x] = (char)1;
                for (y = 0; y < rows; y += 2)
                    grid[y * columns + x + matrix.CellWidth - 1] = (char)1;
            }

            for (y = 0; y < NR; y++)
            {
                for (x = 0; x < NC; x++)
                {
                    int v = places[(NR - y - 1) * NC + x];
                    if (v == 1 || v > 7 && ((binary[(v >> 3) - 1] & (1 << (v & 7))) != 0))
                        grid[(1 + y + 2 * (y / (matrix.CellHeight - 2))) * columns + 1 + x + 2 * (x / (matrix.CellWidth - 2))] = (char)1;
                }
            }
            return grid;
        }

        internal bool Ecc200Encode(ref char[] t, int targetLength, string s, int sourceLength, string encoding, ref int len)
        {
            char enc = 'a';
            int targetposition = 0;
            int sourceposition = 0;
            if (encoding.Length < sourceLength)
                return false;

            while (sourceposition < sourceLength && targetposition < targetLength)
            {
                char newenc = enc;
                if (targetLength - targetposition <= 1 && (enc == 'c' || enc == 't') || targetLength - targetposition <= 2 && enc == 'x')
                    enc = 'a';
#if !SILVERLIGHT
                newenc = char.ToLower(encoding[sourceposition]);
#endif
                switch (newenc)
                {
                    case 'c':
                    case 't':
                    case 'x':
                        {
                            char[] output = new char[6];
                            char p = (char)0;

                            string e = null;
                            string s2 = "!\"#$%&'()*+,-./:;<=>?@[\\]_";
                            string s3 = null;
                            if (newenc == 'c')
                            {
                                e = " 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                                s3 = "`abcdefghijklmnopqrstuvwxyz{|}~±";
                            }
                            if (newenc == 't')
                            {
                                e = " 0123456789abcdefghijklmnopqrstuvwxyz";
                                s3 = "`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~±";
                            }
                            if (newenc == 'x')
                                e = " 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\r*>";
                            do
                            {
                                char c = s[sourceposition++];
                                char w;
                                if ((c & 0x80) != 0)
                                {
                                    if (newenc == 'x')
                                    {
                                        return false;
                                    }
                                    c &= (char)0x7f;
                                    output[p++] = (char)1;
                                    output[p++] = (char)30;
                                }
                                w = e.IndexOf(c) == -1 ? (char)0 : e[e.IndexOf(c)];
                                if (w != (char)0)
                                    output[p++] = (char)((e.IndexOf(w) + 3) % 40);
                                else
                                {
                                    if (newenc == 'x')
                                    {
                                        return false;
                                    }
                                    if (c < 32)
                                    {
                                        output[p++] = (char)0;
                                        output[p++] = c;
                                    }
                                    else
                                    {
                                        w = s2.IndexOf(c) == -1 ? (char)0 : (char)s2.IndexOf(c);
                                        if (w != (char)0)
                                        {
                                            output[p++] = (char)1;
                                            output[p++] = w;
                                        }
                                        else
                                        {
                                            w = s3.IndexOf(c) == -1 ? (char)0 : (char)s3.IndexOf(c);
                                            if (w != (char)0)
                                            {
                                                output[p++] = (char)2;
                                                output[p++] = w;
                                            }
                                            else
                                                return false;
                                        }
                                    }
                                }

                                if (p == 2 && targetposition + 2 == targetLength && sourceposition == sourceLength)
                                    output[p++] = (char)0;
                                while (p >= 3)
                                {
                                    int v = output[0] * 1600 + output[1] * 40 + output[2] + 1;
                                    if (enc != newenc)
                                    {
                                        if (enc == 'c' || enc == 't' || enc == 'x')
                                            t[targetposition++] = (char)254;
                                        else if (enc == 'x')
                                            t[targetposition++] = (char)0x7C;
                                        if (newenc == 'c')
                                            t[targetposition++] = (char)230;
                                        if (newenc == 't')
                                            t[targetposition++] = (char)239;
                                        if (newenc == 'x')
                                            t[targetposition++] = (char)238;
                                        enc = newenc;
                                    }
                                    t[targetposition++] = (char)(v >> 8);
                                    t[targetposition++] = (char)(v & 0xFF);
                                    p -= (char)3;
                                    output[0] = output[3];
                                    output[1] = output[4];
                                    output[2] = output[5];
                                }
                            }
                            while (p != (char)0 && sourceposition < sourceLength);
                        }
                        break;
                    case 'e':
                        {
                            char[] output = new char[4];
                            char p = (char)0;
                            if (enc != newenc)
                            {
                                t[targetposition++] = (char)254;
                                enc = 'a';
                            }
                            while (sourceposition < sourceLength &&
                              char.ToLower(encoding[sourceposition]) == 'e' && p < 4)
                                output[p++] = s[sourceposition++];
                            if (p < 4)
                            {
                                output[p++] = (char)0x1F;
                                enc = 'a';
                            }
                            t[targetposition] = (char)((s[0] & 0x3F) << 2);
                            t[targetposition++] |= (char)((s[1] & 0x30) >> 4);
                            t[targetposition] = (char)((s[1] & 0x0F) << 4);
                            if (p == 2)
                                targetposition++;
                            else
                            {
                                t[targetposition++] |= (char)((s[2] & 0x3C) >> 2);
                                t[targetposition] = (char)((s[2] & 0x03) << 6);
                                t[targetposition++] |= (char)(s[3] & 0x3F);
                            }
                        }
                        break;
                    case 'a':
                        if (enc != newenc)
                        {
                            if (enc == 'c' || enc == 't' || enc == 'x')
                                t[targetposition++] = (char)254;
                            else
                                t[targetposition++] = (char)0x7C;
                        }
                        enc = 'a';
                        if (sourceLength - sourceposition >= 2 && char.IsDigit(s[sourceposition]) && char.IsDigit(s[sourceposition + 1]))
                        {
                            t[targetposition++] = (char)((s[sourceposition] - '0') * 10 + s[sourceposition + 1] - '0' + 130);
                            sourceposition += 2;
                        }
                        else if (s[sourceposition] > 127)
                        {
                            t[targetposition++] = (char)235;
                            t[targetposition++] = (char)(s[sourceposition++] - 127);
                        }
                        else
                            t[targetposition++] = (char)(s[sourceposition++] + 1);
                        break;
                    case 'b':
                        {
                            int l = 0;
                            if (encoding != null)
                            {
                                int p;
                                for (p = sourceposition; p < sourceLength && char.ToLower(encoding[p]) == 'b'; p++)
                                    l++;
                            }
                            t[targetposition++] = (char)231;
                            if (l < 250)
                            {
                                t[targetposition] = (char)State255(l, targetposition);
                                targetposition++;
                            }
                            else
                            {
                                t[targetposition] = (char)State255(249 + (l / 250), targetposition);
                                targetposition++;
                                t[targetposition] = (char)State255(l % 250, targetposition);
                                targetposition++;
                            }
                            while (l-- != 0 && targetposition < targetLength)
                            {
                                t[targetposition] = (char)State255(s[sourceposition++], targetposition);
                                targetposition++;
                            }
                            enc = 'a';
                        }
                        break;
                }
            }
            if (len != 0)
                len = targetposition;
            if (targetposition < targetLength && enc != 'a')
            {
                if (enc == 'c' || enc == 'x' || enc == 't')
                    t[targetposition++] = (char)254;
                else
                    t[targetposition++] = (char)0x7C;
            }

            if (targetposition < targetLength)
                t[targetposition++] = (char)129;

            while (targetposition < targetLength)
            {
                int v = 129 + (((targetposition + 1) * 149) % 253) + 1;
                if (v > 254)
                    v -= 254;
                t[targetposition++] = (char)v;
            }
            if (targetposition > targetLength || sourceposition < sourceLength)
                return false;
            return true;
        }

        int State255(int value, int position)
        {
            return ((value + (((position + 1) * 149) % 255) + 1) % 256);
        }

        void Ecc200Placement(ref int[] array, int NR, int NC)
        {
            int r;
            int c;
            int p;

            for (r = 0; r < NR; r++)
                for (c = 0; c < NC; c++)
                    array[r * NC + c] = 0;
            p = 1;
            r = 4;
            c = 0;
            do
            {
                if (r == NR && (c == 0))
                    Ecc200PlacementCornerA(ref array, NR, NC, p++);
                if (r == NR - 2 && c == 0 && ((NC % 4) != 0))
                    Ecc200PlacementCornerB(ref array, NR, NC, p++);
                if (r == NR - 2 && c == 0 && ((NC % 8) == 4))
                    Ecc200PlacementCornerC(ref array, NR, NC, p++);
                if (r == NR + 4 && c == 2 && ((NC % 8) == 0))
                    Ecc200PlacementCornerD(ref array, NR, NC, p++);
                do
                {
                    if (r < NR && c >= 0 && array[r * NC + c] == 0)
                        Ecc200PlacementBlock(ref array, NR, NC, r, c, p++);
                    r -= 2;
                    c += 2;
                }
                while (r >= 0 && c < NC);
                r++;
                c += 3;
                do
                {
                    if (r >= 0 && c < NC && array[r * NC + c] == 0)
                        Ecc200PlacementBlock(ref array, NR, NC, r, c, p++);
                    r += 2;
                    c -= 2;
                }
                while (r < NR && c >= 0);
                r += 3;
                c++;
            }
            while (r < NR || c < NC);
            if (array[NR * NC - 1] == 0)
                array[NR * NC - 1] = array[NR * NC - NC - 2] = 1;
        }

        void Ecc200PlacementBit(ref int[] array, int NR, int NC, int r, int c, int p, int b)
        {
            if (r < 0)
            {
                r += NR;
                c += 4 - ((NR + 4) % 8);
            }
            if (c < 0)
            {
                c += NC;
                r += 4 - ((NC + 4) % 8);
            }
            array[r * NC + c] = (p << 3) + b;
        }

        void Ecc200PlacementBlock(ref int[] array, int NR, int NC, int r, int c, int p)
        {
            Ecc200PlacementBit(ref array, NR, NC, r - 2, c - 2, p, 7);
            Ecc200PlacementBit(ref array, NR, NC, r - 2, c - 1, p, 6);
            Ecc200PlacementBit(ref array, NR, NC, r - 1, c - 2, p, 5);
            Ecc200PlacementBit(ref array, NR, NC, r - 1, c - 1, p, 4);
            Ecc200PlacementBit(ref array, NR, NC, r - 1, c - 0, p, 3);
            Ecc200PlacementBit(ref array, NR, NC, r - 0, c - 2, p, 2);
            Ecc200PlacementBit(ref array, NR, NC, r - 0, c - 1, p, 1);
            Ecc200PlacementBit(ref array, NR, NC, r - 0, c - 0, p, 0);
        }

        void Ecc200PlacementCornerA(ref int[] array, int NR, int NC, int p)
        {
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, 0, p, 7);
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, 1, p, 6);
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, 2, p, 5);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 2, p, 4);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 1, p, 3);
            Ecc200PlacementBit(ref array, NR, NC, 1, NC - 1, p, 2);
            Ecc200PlacementBit(ref array, NR, NC, 2, NC - 1, p, 1);
            Ecc200PlacementBit(ref array, NR, NC, 3, NC - 1, p, 0);
        }

        void Ecc200PlacementCornerB(ref int[] array, int NR, int NC, int p)
        {
            Ecc200PlacementBit(ref array, NR, NC, NR - 3, 0, p, 7);
            Ecc200PlacementBit(ref array, NR, NC, NR - 2, 0, p, 6);
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, 0, p, 5);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 4, p, 4);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 3, p, 3);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 2, p, 2);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 1, p, 1);
            Ecc200PlacementBit(ref array, NR, NC, 1, NC - 1, p, 0);
        }

        void Ecc200PlacementCornerC(ref int[] array, int NR, int NC, int p)
        {
            Ecc200PlacementBit(ref array, NR, NC, NR - 3, 0, p, 7);
            Ecc200PlacementBit(ref array, NR, NC, NR - 2, 0, p, 6);
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, 0, p, 5);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 2, p, 4);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 1, p, 3);
            Ecc200PlacementBit(ref array, NR, NC, 1, NC - 1, p, 2);
            Ecc200PlacementBit(ref array, NR, NC, 2, NC - 1, p, 1);
            Ecc200PlacementBit(ref array, NR, NC, 3, NC - 1, p, 0);
        }

        void Ecc200PlacementCornerD(ref int[] array, int NR, int NC, int p)
        {
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, 0, p, 7);
            Ecc200PlacementBit(ref array, NR, NC, NR - 1, NC - 1, p, 6);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 3, p, 5);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 2, p, 4);
            Ecc200PlacementBit(ref array, NR, NC, 0, NC - 1, p, 3);
            Ecc200PlacementBit(ref array, NR, NC, 1, NC - 3, p, 2);
            Ecc200PlacementBit(ref array, NR, NC, 1, NC - 2, p, 1);
            Ecc200PlacementBit(ref array, NR, NC, 1, NC - 1, p, 0);
        }

        void Ecc200(char[] binary, int bytes, int datablock, int rsblock)
        {
            int blocks = (bytes + 2) / datablock;
            int b;
            InitGalois(0x12d);
            InitReedSolomon(rsblock, 1);
            for (b = 0; b < blocks; b++)
            {
                int[] buf = new int[256];
                int[] ecc = new int[256];
                int n,
                  p = 0;
                for (n = b; n < bytes; n += blocks)
                    buf[p++] = binary[n];
                EncodeReedSolomon(p, buf, ref ecc);
                p = rsblock - 1;
                for (n = b; n < rsblock * blocks; n += blocks)
                    binary[bytes + n] = (char)ecc[p--];
            }
        }

        static int gfpoly;
        static int symsize;
        static int logmod;
        static int rlen;

        static int[] log = null;
        static int[] alog = null;
        static int[] rspoly = null;

        public static void InitGalois(int poly)
        {
            int m;
            int b;
            int p;
            int v;

            if (log != null)
            {
                log = null;
                alog = null;
                rspoly = null;
            }
            for (b = 1, m = 0; b <= poly; b <<= 1)
                m++;
            b >>= 1;
            m--;
            gfpoly = poly;
            symsize = m;

            logmod = (1 << m) - 1;
            log = new int[logmod + 1];
            alog = new int[logmod];

            for (p = 1, v = 0; v < logmod; v++)
            {
                alog[v] = p;
                log[p] = v;
                p <<= 1;
                if ((p & b) != 0)
                    p ^= poly;
            }
        }

        public static void InitReedSolomon(int nsym, int index)
        {
            int i;
            int k;

            if (rspoly != null)
                rspoly = null;
            rspoly = new int[nsym + 1];

            rlen = nsym;

            rspoly[0] = 1;
            for (i = 1; i <= nsym; i++)
            {
                rspoly[i] = 1;
                for (k = i - 1; k > 0; k--)
                {
                    if (rspoly[k] != 0)
                        rspoly[k] = alog[(log[rspoly[k]] + index) % logmod];
                    rspoly[k] ^= rspoly[k - 1];
                }
                rspoly[0] = alog[(log[rspoly[0]] + index) % logmod];
                index++;
            }
        }

        public void EncodeReedSolomon(int length, int[] data, ref int[] result)
        {
            int i;
            int k;
            int m;
            for (i = 0; i < rlen; i++)
                result[i] = 0;
            for (i = 0; i < length; i++)
            {
                m = result[rlen - 1] ^ data[i];
                for (k = rlen - 1; k > 0; k--)
                {
                    if ((m != 0) && (rspoly[k] != 0))
                        result[k] = result[k - 1] ^ alog[(log[m] + log[rspoly[k]]) % logmod];
                    else
                        result[k] = result[k - 1];
                }
                if ((m != 0) && (rspoly[0] != 0))
                    result[0] = alog[(log[m] + log[rspoly[0]]) % logmod];
                else
                    result[0] = 0;
            }
        }

        public XImage CreateImage(char[] code, int size)
        {
            return CreateImage(code, size, size, 10);
        }

        public XImage CreateImage(char[] code, int rows, int columns)
        {
            return CreateImage(code, rows, columns, 10);
        }

        public XImage CreateImage(char[] code, int rows, int columns, int pixelsize)
        {

#if CORE || NETFX_CORE || UWP
            return null;
#endif
        }

        struct Ecc200Block
        {
            public readonly int Height;
            public readonly int Width;
            public readonly int CellHeight;
            public readonly int CellWidth;
            public readonly int Bytes;
            public readonly int DataBlock;
            public readonly int RSBlock;

            public Ecc200Block(int h, int w, int ch, int cw, int bytes, int dataBlock, int rsBlock)
            {
                Height = h;
                Width = w;
                CellHeight = ch;
                CellWidth = cw;
                Bytes = bytes;
                DataBlock = dataBlock;
                RSBlock = rsBlock;
            }
        }
    }
    public abstract class MatrixCode : CodeBase
    {
        public MatrixCode(string text, string encoding, int rows, int columns, XSize size)
            : base(text, size, CodeDirection.LeftToRight)
        {
            _encoding = encoding;
            if (String.IsNullOrEmpty(_encoding))
                _encoding = new String('a', Text.Length);

            if (columns < rows)
            {
                _rows = columns;
                _columns = rows;
            }
            else
            {
                _columns = columns;
                _rows = rows;
            }

            Text = text;
        }

        public string Encoding
        {
            get { return _encoding; }
            set
            {
                _encoding = value;
                _matrixImage = null;
            }
        }
        string _encoding;

        public int Columns
        {
            get { return _columns; }
            set
            {
                _columns = value;
                _matrixImage = null;
            }
        }
        int _columns;

        public int Rows
        {
            get { return _rows; }
            set
            {
                _rows = value;
                _matrixImage = null;
            }
        }
        int _rows;

        public new string Text
        {
            get { return base.Text; }
            set
            {
                base.Text = value;
                _matrixImage = null;
            }
        }

        internal XImage MatrixImage
        {
            get { return _matrixImage; }
            set { _matrixImage = value; }
        }
        XImage _matrixImage;

        protected internal abstract void Render(XGraphics gfx, XBrush brush, XPoint center);

        protected override void CheckCode(string text)
        { }
    }
    public abstract class ThickThinBarCode : BarCode
    {
        public ThickThinBarCode(string code, XSize size, CodeDirection direction)
            : base(code, size, direction)
        { }

        internal override void InitRendering(BarCodeRenderInfo info)
        {
            base.InitRendering(info);
            CalcThinBarWidth(info);
            info.BarHeight = Size.Height;
            if (TextLocation != TextLocation.None)
                info.BarHeight *= 4.0 / 5;

            switch (Direction)
            {
                case CodeDirection.RightToLeft:
                    info.Gfx.RotateAtTransform(180, info.Position);
                    break;

                case CodeDirection.TopToBottom:
                    info.Gfx.RotateAtTransform(90, info.Position);
                    break;

                case CodeDirection.BottomToTop:
                    info.Gfx.RotateAtTransform(-90, info.Position);
                    break;
            }
        }

        public override double WideNarrowRatio
        {
            get { return _wideNarrowRatio; }
            set
            {
                if (value > 3 || value < 2)
                    throw new ArgumentOutOfRangeException("value", BcgSR.Invalid2of5Relation);
                _wideNarrowRatio = value;
            }
        }
        double _wideNarrowRatio = 2.6;

        internal void RenderBar(BarCodeRenderInfo info, bool isThick)
        {
            double barWidth = GetBarWidth(info, isThick);
            double height = Size.Height;
            double xPos = info.CurrPos.X;
            double yPos = info.CurrPos.Y;

            switch (TextLocation)
            {
                case TextLocation.AboveEmbedded:
                    height -= info.Gfx.MeasureString(Text, info.Font).Height;
                    yPos += info.Gfx.MeasureString(Text, info.Font).Height;
                    break;
                case TextLocation.BelowEmbedded:
                    height -= info.Gfx.MeasureString(Text, info.Font).Height;
                    break;
            }

            XRect rect = new XRect(xPos, yPos, barWidth, height);
            info.Gfx.DrawRectangle(info.Brush, rect);
            info.CurrPos.X += barWidth;
        }

        internal void RenderGap(BarCodeRenderInfo info, bool isThick)
        {
            info.CurrPos.X += GetBarWidth(info, isThick);
        }

        internal void RenderTurboBit(BarCodeRenderInfo info, bool startBit)
        {
            if (startBit)
                info.CurrPos.X -= 0.5 + GetBarWidth(info, true);
            else
                info.CurrPos.X += 0.5;

            RenderBar(info, true);

            if (startBit)
                info.CurrPos.X += 0.5;
        }

        internal void RenderText(BarCodeRenderInfo info)
        {
            if (info.Font == null)
                info.Font = new XFont("Courier New", Size.Height / 6);
            XPoint center = info.Position + CalcDistance(Anchor, AnchorType.TopLeft, Size);

            switch (TextLocation)
            {
                case TextLocation.Above:
                    center = new XPoint(center.X, center.Y - info.Gfx.MeasureString(Text, info.Font).Height);
                    info.Gfx.DrawString(Text, info.Font, info.Brush, new XRect(center, Size), XStringFormats.TopCenter);
                    break;
                case TextLocation.AboveEmbedded:
                    info.Gfx.DrawString(Text, info.Font, info.Brush, new XRect(center, Size), XStringFormats.TopCenter);
                    break;
                case TextLocation.Below:
                    center = new XPoint(center.X, info.Gfx.MeasureString(Text, info.Font).Height + center.Y);
                    info.Gfx.DrawString(Text, info.Font, info.Brush, new XRect(center, Size), XStringFormats.BottomCenter);
                    break;
                case TextLocation.BelowEmbedded:
                    info.Gfx.DrawString(Text, info.Font, info.Brush, new XRect(center, Size), XStringFormats.BottomCenter);
                    break;
            }
        }

        internal double GetBarWidth(BarCodeRenderInfo info, bool isThick)
        {
            if (isThick)
                return info.ThinBarWidth * _wideNarrowRatio;
            return info.ThinBarWidth;
        }

        internal abstract void CalcThinBarWidth(BarCodeRenderInfo info);
    }
    internal interface IImageImporter
    {
        ImportedImage ImportImage(StreamReaderHelper stream, PdfDocument document);

        ImageData PrepareImage(ImagePrivateData data);
    }

    internal class StreamReaderHelper
    {
        internal StreamReaderHelper(Stream stream)
        {
            _stream = stream;
            _stream.Position = 0;
            if (_stream.Length > int.MaxValue)
                throw new ArgumentException("Stream is too large.", "stream");
            _length = (int)_stream.Length;
            _data = new byte[_length];
            _stream.Read(_data, 0, _length);
        }

        internal byte GetByte(int offset)
        {
            if (_currentOffset + offset >= _length)
            {
                Debug.Assert(false);
                return 0;
            }
            return _data[_currentOffset + offset];
        }

        internal ushort GetWord(int offset, bool bigEndian)
        {
            return (ushort)(bigEndian ?
                GetByte(offset) * 256 + GetByte(offset + 1) :
                GetByte(offset) + GetByte(offset + 1) * 256);
        }

        internal uint GetDWord(int offset, bool bigEndian)
        {
            return (uint)(bigEndian ?
                GetWord(offset, true) * 65536 + GetWord(offset + 2, true) :
                GetWord(offset, false) + GetWord(offset + 2, false) * 65536);
        }

        private static void CopyStream(Stream input, Stream output)
        {
            byte[] buffer = new byte[65536];
            int read;
            while ((read = input.Read(buffer, 0, buffer.Length)) > 0)
            {
                output.Write(buffer, 0, read);
            }
        }

        public void Reset()
        {
            _currentOffset = 0;
        }

        public Stream OriginalStream
        {
            get { return _stream; }
        }
        private readonly Stream _stream;

        internal int CurrentOffset
        {
            get { return _currentOffset; }
            set { _currentOffset = value; }
        }
        private int _currentOffset;

        public byte[] Data
        {
            get { return _data; }
        }
        private readonly byte[] _data;

        public int Length
        {
            get { return _length; }
        }

        private readonly int _length;

    }

    internal abstract class ImportedImage
    {
        protected ImportedImage(IImageImporter importer, ImagePrivateData data, PdfDocument document)
        {
            Data = data;
            _document = document;
            data.Image = this;
            _importer = importer;
        }


        public ImageInformation Information
        {
            get { return _information; }
            private set { _information = value; }
        }
        private ImageInformation _information = new ImageInformation();

        public bool HasImageData
        {
            get { return _imageData != null; }
        }

        public ImageData ImageData
        {
            get { if (!HasImageData) _imageData = PrepareImageData(); return _imageData; }
            private set { _imageData = value; }
        }
        private ImageData _imageData;

        internal virtual ImageData PrepareImageData()
        {
            throw new NotImplementedException();
        }

        private IImageImporter _importer;
        internal ImagePrivateData Data;
        internal readonly PdfDocument _document;
    }

    internal class ImageInformation
    {
        internal enum ImageFormats
        {
            JPEG,
            JPEGGRAY,
            JPEGRGBW,
            JPEGCMYK,
            Palette1,
            Palette4,
            Palette8,
            RGB24,
            ARGB32
        }

        internal ImageFormats ImageFormat;

        internal uint Width;
        internal uint Height;

        internal decimal HorizontalDPI;
        internal decimal VerticalDPI;

        internal decimal HorizontalDPM;
        internal decimal VerticalDPM;

        internal decimal HorizontalAspectRatio;
        internal decimal VerticalAspectRatio;

        internal uint ColorsUsed;
    }

    internal abstract class ImagePrivateData
    {
        internal ImagePrivateData()
        {
        }

        public ImportedImage Image
        {
            get { return _image; }
            internal set { _image = value; }
        }
        private ImportedImage _image;
    }

    internal abstract class ImageData
    {
    }
    internal class ImageImporter
    {
        public static ImageImporter GetImageImporter()
        {
            return new ImageImporter();
        }

        private ImageImporter()
        {
            _importers.Add(new ImageImporterJpeg());
            _importers.Add(new ImageImporterBmp());
        }

        public ImportedImage ImportImage(Stream stream, PdfDocument document)
        {
            StreamReaderHelper helper = new StreamReaderHelper(stream);

            foreach (IImageImporter importer in _importers)
            {
                helper.Reset();
                ImportedImage image = importer.ImportImage(helper, document);
                if (image != null)
                    return image;
            }
            return null;
        }

#if GDI || WPF || CORE
        public ImportedImage ImportImage(string filename, PdfDocument document)
        {
            ImportedImage ii;
            using (Stream fs = File.OpenRead(filename))
            {
                ii = ImportImage(fs, document);
            }
            return ii;
        }
#endif

        private readonly List<IImageImporter> _importers = new List<IImageImporter>();
    }
    internal class ImageImporterBmp : ImageImporterRoot, IImageImporter
    {
        public ImportedImage ImportImage(StreamReaderHelper stream, PdfDocument document)
        {
            try
            {
                stream.CurrentOffset = 0;
                int offsetImageData;
                if (TestBitmapFileHeader(stream, out offsetImageData))
                {
                    ImagePrivateDataBitmap ipd = new ImagePrivateDataBitmap(stream.Data, stream.Length);
                    ImportedImage ii = new ImportedImageBitmap(this, ipd, document);
                    if (TestBitmapInfoHeader(stream, ii, offsetImageData))
                    {
                        return ii;
                    }
                }
            }
            catch (Exception)
            {
            }
            return null;
        }

        private bool TestBitmapFileHeader(StreamReaderHelper stream, out int offset)
        {
            offset = 0;
            if (stream.GetWord(0, true) == 0x424d)
            {
                int filesize = (int)stream.GetDWord(2, false);
                if (filesize < stream.Length)
                    return false;

                offset = (int)stream.GetDWord(10, false);
                stream.CurrentOffset += 14;
                return true;
            }
            return false;
        }

        private bool TestBitmapInfoHeader(StreamReaderHelper stream, ImportedImage ii, int offset)
        {
            int size = (int)stream.GetDWord(0, false);
            if (size == 40 || size == 108 || size == 124)
            {
                uint width = stream.GetDWord(4, false);
                int height = (int)stream.GetDWord(8, false);
                int planes = stream.GetWord(12, false);
                int bitcount = stream.GetWord(14, false);
                int compression = (int)stream.GetDWord(16, false);
                int sizeImage = (int)stream.GetDWord(20, false);
                int xPelsPerMeter = (int)stream.GetDWord(24, false);
                int yPelsPerMeter = (int)stream.GetDWord(28, false);
                uint colorsUsed = stream.GetDWord(32, false);
                uint colorsImportant = stream.GetDWord(36, false);
                if (sizeImage != 0 && sizeImage + offset > stream.Length)
                    return false;

                ImagePrivateDataBitmap privateData = (ImagePrivateDataBitmap)ii.Data;

                if (compression == 0 || compression == 3)
                {
                    ((ImagePrivateDataBitmap)ii.Data).Offset = offset;
                    ((ImagePrivateDataBitmap)ii.Data).ColorPaletteOffset = stream.CurrentOffset + size;
                    ii.Information.Width = width;
                    ii.Information.Height = (uint)Math.Abs(height);
                    ii.Information.HorizontalDPM = xPelsPerMeter;
                    ii.Information.VerticalDPM = yPelsPerMeter;
                    privateData.FlippedImage = height < 0;
                    if (planes == 1 && bitcount == 24)
                    {
                        ii.Information.ImageFormat = ImageInformation.ImageFormats.RGB24;

                        return true;
                    }
                    if (planes == 1 && bitcount == 32)
                    {
                        ii.Information.ImageFormat = compression == 0 ?
                            ImageInformation.ImageFormats.RGB24 :
                            ImageInformation.ImageFormats.ARGB32;

                        return true;
                    }
                    if (planes == 1 && bitcount == 8)
                    {
                        ii.Information.ImageFormat = ImageInformation.ImageFormats.Palette8;
                        ii.Information.ColorsUsed = colorsUsed;

                        return true;
                    }
                    if (planes == 1 && bitcount == 4)
                    {
                        ii.Information.ImageFormat = ImageInformation.ImageFormats.Palette4;
                        ii.Information.ColorsUsed = colorsUsed;

                        return true;
                    }
                    if (planes == 1 && bitcount == 1)
                    {
                        ii.Information.ImageFormat = ImageInformation.ImageFormats.Palette1;
                        ii.Information.ColorsUsed = colorsUsed;

                        return true;
                    }
                }
            }
            return false;
        }


        public ImageData PrepareImage(ImagePrivateData data)
        {
            throw new NotImplementedException();
        }
    }

    internal class ImportedImageBitmap : ImportedImage
    {
        public ImportedImageBitmap(IImageImporter importer, ImagePrivateDataBitmap data, PdfDocument document)
            : base(importer, data, document)
        { }

        internal override ImageData PrepareImageData()
        {
            ImagePrivateDataBitmap data = (ImagePrivateDataBitmap)Data;
            ImageDataBitmap imageData = new ImageDataBitmap(_document);
            data.CopyBitmap(imageData);

            return imageData;
        }
    }

    internal class ImageDataBitmap : ImageData
    {
        private ImageDataBitmap()
        {
        }

        internal ImageDataBitmap(PdfDocument document)
        {
            _document = document;
        }

        public byte[] Data
        {
            get { return _data; }
            internal set { _data = value; }
        }
        private byte[] _data;

        public int Length
        {
            get { return _length; }
            internal set { _length = value; }
        }
        private int _length;

        public byte[] DataFax
        {
            get { return _dataFax; }
            internal set { _dataFax = value; }
        }
        private byte[] _dataFax;

        public int LengthFax
        {
            get { return _lengthFax; }
            internal set { _lengthFax = value; }
        }
        private int _lengthFax;

        public byte[] AlphaMask
        {
            get { return _alphaMask; }
            internal set { _alphaMask = value; }
        }
        private byte[] _alphaMask;

        public int AlphaMaskLength
        {
            get { return _alphaMaskLength; }
            internal set { _alphaMaskLength = value; }
        }
        private int _alphaMaskLength;

        public byte[] BitmapMask
        {
            get { return _bitmapMask; }
            internal set { _bitmapMask = value; }
        }
        private byte[] _bitmapMask;

        public int BitmapMaskLength
        {
            get { return _bitmapMaskLength; }
            internal set { _bitmapMaskLength = value; }
        }
        private int _bitmapMaskLength;

        public byte[] PaletteData
        {
            get { return _paletteData; }
            set { _paletteData = value; }
        }
        private byte[] _paletteData;

        public int PaletteDataLength
        {
            get { return _paletteDataLength; }
            set { _paletteDataLength = value; }
        }
        private int _paletteDataLength;

        public bool SegmentedColorMask;

        public int IsBitonal;

        public int K;

        public bool IsGray;

        internal readonly PdfDocument _document;
    }

    internal class ImagePrivateDataBitmap : ImagePrivateData
    {
        public ImagePrivateDataBitmap(byte[] data, int length)
        {
            _data = data;
            _length = length;
        }

        public byte[] Data
        {
            get { return _data; }
        }
        private readonly byte[] _data;

        public int Length
        {
            get { return _length; }
        }
        private readonly int _length;

        internal bool FlippedImage;

        internal int Offset;

        internal int ColorPaletteOffset;

        internal void CopyBitmap(ImageDataBitmap dest)
        {
            switch (Image.Information.ImageFormat)
            {
                case ImageInformation.ImageFormats.ARGB32:
                    CopyTrueColorMemoryBitmap(3, 8, true, dest);
                    break;

                case ImageInformation.ImageFormats.RGB24:
                    CopyTrueColorMemoryBitmap(4, 8, false, dest);
                    break;

                case ImageInformation.ImageFormats.Palette8:
                    CopyIndexedMemoryBitmap(8, dest);
                    break;

                case ImageInformation.ImageFormats.Palette4:
                    CopyIndexedMemoryBitmap(4, dest);
                    break;

                case ImageInformation.ImageFormats.Palette1:
                    CopyIndexedMemoryBitmap(1, dest);
                    break;



                default:
                    throw new NotImplementedException();
            }
        }

        private void CopyTrueColorMemoryBitmap(int components, int bits, bool hasAlpha, ImageDataBitmap dest)
        {
            int width = (int)Image.Information.Width;
            int height = (int)Image.Information.Height;

            int logicalComponents = components;
            if (components == 4)
                logicalComponents = 3;

            byte[] imageData = new byte[components * width * height];

            bool hasMask = false;
            bool hasAlphaMask = false;
            byte[] alphaMask = hasAlpha ? new byte[width * height] : null;
            MonochromeMask mask = hasAlpha ?
              new MonochromeMask(width, height) : null;

            int nFileOffset = Offset;
            int nOffsetRead = 0;
            if (logicalComponents == 3)
            {
                for (int y = 0; y < height; ++y)
                {
                    int nOffsetWrite = 3 * (height - 1 - y) * width;
                    int nOffsetWriteAlpha = 0;
                    if (hasAlpha)
                    {
                        mask.StartLine(y);
                        nOffsetWriteAlpha = (height - 1 - y) * width;
                    }

                    for (int x = 0; x < width; ++x)
                    {
                        imageData[nOffsetWrite] = Data[nFileOffset + nOffsetRead + 2];
                        imageData[nOffsetWrite + 1] = Data[nFileOffset + nOffsetRead + 1];
                        imageData[nOffsetWrite + 2] = Data[nFileOffset + nOffsetRead];
                        if (hasAlpha)
                        {
                            mask.AddPel(Data[nFileOffset + nOffsetRead + 3]);
                            alphaMask[nOffsetWriteAlpha] = Data[nFileOffset + nOffsetRead + 3];
                            if (!hasMask || !hasAlphaMask)
                            {
                                if (Data[nFileOffset + nOffsetRead + 3] != 255)
                                {
                                    hasMask = true;
                                    if (Data[nFileOffset + nOffsetRead + 3] != 0)
                                        hasAlphaMask = true;
                                }
                            }
                            ++nOffsetWriteAlpha;
                        }
                        nOffsetRead += hasAlpha ? 4 : components;
                        nOffsetWrite += 3;
                    }
                    nOffsetRead = 4 * ((nOffsetRead + 3) / 4);
                }
            }
            else if (components == 1)
            {
                throw new NotImplementedException("Image format not supported (grayscales).");
            }

            dest.Data = imageData;
            dest.Length = imageData.Length;

            if (alphaMask != null)
            {
                dest.AlphaMask = alphaMask;
                dest.AlphaMaskLength = alphaMask.Length;
            }

            if (mask != null)
            {
                dest.BitmapMask = mask.MaskData;
                dest.BitmapMaskLength = mask.MaskData.Length;
            }
        }

        private void CopyIndexedMemoryBitmap(int bits, ImageDataBitmap dest)
        {
            int firstMaskColor = -1, lastMaskColor = -1;
            bool segmentedColorMask = false;

            int bytesColorPaletteOffset = ((ImagePrivateDataBitmap)Image.Data).ColorPaletteOffset;

            int bytesFileOffset = ((ImagePrivateDataBitmap)Image.Data).Offset;
            uint paletteColors = Image.Information.ColorsUsed;
            int width = (int)Image.Information.Width;
            int height = (int)Image.Information.Height;

            MonochromeMask mask = new MonochromeMask(width, height);

            bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);
            int isBitonal = 0;
            byte[] paletteData = new byte[3 * paletteColors];
            for (int color = 0; color < paletteColors; ++color)
            {
                paletteData[3 * color] = Data[bytesColorPaletteOffset + 4 * color + 2];
                paletteData[3 * color + 1] = Data[bytesColorPaletteOffset + 4 * color + 1];
                paletteData[3 * color + 2] = Data[bytesColorPaletteOffset + 4 * color + 0];
                if (isGray)
                    isGray = paletteData[3 * color] == paletteData[3 * color + 1] &&
                      paletteData[3 * color] == paletteData[3 * color + 2];

                if (Data[bytesColorPaletteOffset + 4 * color + 3] < 128)
                {
                    if (firstMaskColor == -1)
                        firstMaskColor = color;
                    if (lastMaskColor == -1 || lastMaskColor == color - 1)
                        lastMaskColor = color;
                    if (lastMaskColor != color)
                        segmentedColorMask = true;
                }
            }

            if (bits == 1)
            {
                if (paletteColors == 0)
                    isBitonal = 1;
                if (paletteColors == 2)
                {
                    if (paletteData[0] == 0 &&
                      paletteData[1] == 0 &&
                      paletteData[2] == 0 &&
                      paletteData[3] == 255 &&
                      paletteData[4] == 255 &&
                      paletteData[5] == 255)
                        isBitonal = 1;
                    if (paletteData[5] == 0 &&
                      paletteData[4] == 0 &&
                      paletteData[3] == 0 &&
                      paletteData[2] == 255 &&
                      paletteData[1] == 255 &&
                      paletteData[0] == 255)
                        isBitonal = -1;
                }
            }

            bool isFaxEncoding = false;
            byte[] imageData = new byte[((width * bits + 7) / 8) * height];
            byte[] imageDataFax = null;
            int k = 0;


            if (bits == 1 && dest._document.Options.EnableCcittCompressionForBilevelImages)
            {
                byte[] tempG4 = new byte[imageData.Length];
                int ccittSizeG4 = PdfImage.DoFaxEncodingGroup4(ref tempG4, Data, (uint)bytesFileOffset, (uint)width, (uint)height);

                isFaxEncoding = ccittSizeG4 > 0;
                if (isFaxEncoding)
                {
                    if (ccittSizeG4 == 0)
                        ccittSizeG4 = 0x7fffffff;
                    {
                        Array.Resize(ref tempG4, ccittSizeG4);
                        imageDataFax = tempG4;
                        k = -1;
                    }
                }
            }

            {
                int bytesOffsetRead = 0;
                if (bits == 8 || bits == 4 || bits == 1)
                {
                    int bytesPerLine = (width * bits + 7) / 8;
                    for (int y = 0; y < height; ++y)
                    {
                        mask.StartLine(y);
                        int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);
                        for (int x = 0; x < bytesPerLine; ++x)
                        {
                            if (isGray)
                            {
                                imageData[bytesOffsetWrite] = paletteData[3 * Data[bytesFileOffset + bytesOffsetRead]];
                            }
                            else
                            {
                                imageData[bytesOffsetWrite] = Data[bytesFileOffset + bytesOffsetRead];
                            }
                            if (firstMaskColor != -1)
                            {
                                int n = Data[bytesFileOffset + bytesOffsetRead];
                                if (bits == 8)
                                {
                                    mask.AddPel((n >= firstMaskColor) && (n <= lastMaskColor));
                                }
                                else if (bits == 4)
                                {
                                    int n1 = (n & 0xf0) / 16;
                                    int n2 = (n & 0x0f);
                                    mask.AddPel((n1 >= firstMaskColor) && (n1 <= lastMaskColor));
                                    mask.AddPel((n2 >= firstMaskColor) && (n2 <= lastMaskColor));
                                }
                                else if (bits == 1)
                                {
                                    for (int bit = 1; bit <= 8; ++bit)
                                    {
                                        int n1 = (n & 0x80) / 128;
                                        mask.AddPel((n1 >= firstMaskColor) && (n1 <= lastMaskColor));
                                        n *= 2;
                                    }
                                }
                            }
                            bytesOffsetRead += 1;
                            bytesOffsetWrite += 1;
                        }
                        bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);
                    }
                }
                else
                {
                    throw new NotImplementedException("ReadIndexedMemoryBitmap: unsupported format #3");
                }
            }

            dest.Data = imageData;
            dest.Length = imageData.Length;

            if (imageDataFax != null)
            {
                dest.DataFax = imageDataFax;
                dest.LengthFax = imageDataFax.Length;
            }

            dest.IsGray = isGray;
            dest.K = k;
            dest.IsBitonal = isBitonal;

            dest.PaletteData = paletteData;
            dest.PaletteDataLength = paletteData.Length;
            dest.SegmentedColorMask = segmentedColorMask;

            if (mask != null && firstMaskColor != -1)
            {
                dest.BitmapMask = mask.MaskData;
                dest.BitmapMaskLength = mask.MaskData.Length;
            }

        }
    }
    internal class ImageImporterJpeg : ImageImporterRoot, IImageImporter
    {
        public ImportedImage ImportImage(StreamReaderHelper stream, PdfDocument document)
        {
            try
            {

                stream.CurrentOffset = 0;
                if (TestFileHeader(stream))
                {
                    stream.CurrentOffset += 2;

                    ImagePrivateDataDct ipd = new ImagePrivateDataDct(stream.Data, stream.Length);
                    ImportedImage ii = new ImportedImageJpeg(this, ipd, document);
                    if (TestJfifHeader(stream, ii))
                    {
                        bool colorHeader = false, infoHeader = false;

                        while (MoveToNextHeader(stream))
                        {
                            if (TestColorFormatHeader(stream, ii))
                            {
                                colorHeader = true;
                            }
                            else if (TestInfoHeader(stream, ii))
                            {
                                infoHeader = true;
                            }
                        }
                        if (colorHeader && infoHeader)
                            return ii;
                    }
                }
            }
            catch (Exception)
            {
            }
            return null;
        }

        private bool TestFileHeader(StreamReaderHelper stream)
        {
            return stream.GetWord(0, true) == 0xffd8;
        }

        private bool TestJfifHeader(StreamReaderHelper stream, ImportedImage ii)
        {
            if (stream.GetWord(0, true) == 0xffe0)
            {
                if (stream.GetDWord(4, true) == 0x4a464946)
                {
                    int blockLength = stream.GetWord(2, true);
                    if (blockLength >= 16)
                    {
                        int version = stream.GetWord(9, true);
                        int units = stream.GetByte(11);
                        int densityX = stream.GetWord(12, true);
                        int densityY = stream.GetWord(14, true);

                        switch (units)
                        {
                            case 0:
                                ii.Information.HorizontalAspectRatio = densityX;
                                ii.Information.VerticalAspectRatio = densityY;
                                break;
                            case 1:
                                ii.Information.HorizontalDPI = densityX;
                                ii.Information.VerticalDPI = densityY;
                                break;
                            case 2:
                                ii.Information.HorizontalDPM = densityX * 100;
                                ii.Information.VerticalDPM = densityY * 100;
                                break;
                        }

                        return true;
                    }
                }
            }
            return false;
        }

        private bool TestColorFormatHeader(StreamReaderHelper stream, ImportedImage ii)
        {
            if (stream.GetWord(0, true) == 0xffda)
            {
                int components = stream.GetByte(4);
                if (components < 1 || components > 4 || components == 2)
                    return false;
                int blockLength = stream.GetWord(2, true);
                if (blockLength != 6 + 2 * components)
                    return false;

                ii.Information.ImageFormat = components == 3 ? ImageInformation.ImageFormats.JPEG :
                    (components == 1 ? ImageInformation.ImageFormats.JPEGGRAY : ImageInformation.ImageFormats.JPEGRGBW);

                return true;
            }
            return false;
        }

        private bool TestInfoHeader(StreamReaderHelper stream, ImportedImage ii)
        {
            int header = stream.GetWord(0, true);
            if (header >= 0xffc0 && header <= 0xffc3 ||
                header >= 0xffc9 && header <= 0xffcb)
            {
                int sizeY = stream.GetWord(5, true);
                int sizeX = stream.GetWord(7, true);

                ii.Information.Width = (uint)sizeX;
                ii.Information.Height = (uint)sizeY;

                return true;
            }
            return false;
        }

        private bool MoveToNextHeader(StreamReaderHelper stream)
        {
            int blockLength = stream.GetWord(2, true);

            int headerMagic = stream.GetByte(0);
            int headerType = stream.GetByte(1);

            if (headerMagic == 0xff)
            {
                if (headerType == 0xd9)
                    return false;

                if (headerType == 0x01 || headerType >= 0xd0 && headerType <= 0xd7)
                {
                    stream.CurrentOffset += 2;
                    return true;
                }

                stream.CurrentOffset += 2 + blockLength;
                return true;
            }
            return false;
        }

        public ImageData PrepareImage(ImagePrivateData data)
        {
            throw new NotImplementedException();
        }


    }

    internal class ImportedImageJpeg : ImportedImage
    {
        public ImportedImageJpeg(IImageImporter importer, ImagePrivateDataDct data, PdfDocument document)
            : base(importer, data, document)
        { }

        internal override ImageData PrepareImageData()
        {
            ImagePrivateDataDct data = (ImagePrivateDataDct)Data;
            ImageDataDct imageData = new ImageDataDct();
            imageData.Data = data.Data;
            imageData.Length = data.Length;

            return imageData;
        }
    }

    internal class ImageDataDct : ImageData
    {
        public byte[] Data
        {
            get { return _data; }
            internal set { _data = value; }
        }
        private byte[] _data;

        public int Length
        {
            get { return _length; }
            internal set { _length = value; }
        }
        private int _length;
    }

    internal class ImagePrivateDataDct : ImagePrivateData
    {
        public ImagePrivateDataDct(byte[] data, int length)
        {
            _data = data;
            _length = length;
        }

        public byte[] Data
        {
            get { return _data; }
        }
        private readonly byte[] _data;

        public int Length
        {
            get { return _length; }
        }
        private readonly int _length;
    }

    public enum XParagraphAlignment
    {
        Default,

        Left,

        Center,

        Right,

        Justify,
    }
    public class XTextFormatter
    {
        public XTextFormatter(XGraphics gfx)
        {
            if (gfx == null)
                throw new ArgumentNullException("gfx");
            _gfx = gfx;
        }
        readonly XGraphics _gfx;

        public string Text
        {
            get { return _text; }
            set { _text = value; }
        }
        string _text;

        public XFont Font
        {
            get { return _font; }
            set
            {
                if (value == null)
                    throw new ArgumentNullException("Font");
                _font = value;

                _lineSpace = _font.GetHeight();
                _cyAscent = _lineSpace * _font.CellAscent / _font.CellSpace;
                _cyDescent = _lineSpace * _font.CellDescent / _font.CellSpace;

                _spaceWidth = _gfx.MeasureString("x x", value).Width;
                _spaceWidth -= _gfx.MeasureString("xx", value).Width;
            }
        }
        XFont _font;
        double _lineSpace;
        double _cyAscent;
        double _cyDescent;
        double _spaceWidth;

        public XRect LayoutRectangle
        {
            get { return _layoutRectangle; }
            set { _layoutRectangle = value; }
        }
        XRect _layoutRectangle;

        public XParagraphAlignment Alignment
        {
            get { return _alignment; }
            set { _alignment = value; }
        }
        XParagraphAlignment _alignment = XParagraphAlignment.Left;

        public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle)
        {
            DrawString(text, font, brush, layoutRectangle, XStringFormats.TopLeft);
        }

        public void DrawString(string text, XFont font, XBrush brush, XRect layoutRectangle, XStringFormat format)
        {
            if (text == null)
                throw new ArgumentNullException("text");
            if (font == null)
                throw new ArgumentNullException("font");
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (format.Alignment != XStringAlignment.Near || format.LineAlignment != XLineAlignment.Near)
                throw new ArgumentException("Only TopLeft alignment is currently implemented.");

            Text = text;
            Font = font;
            LayoutRectangle = layoutRectangle;

            if (text.Length == 0)
                return;

            CreateBlocks();

            CreateLayout();

            double dx = layoutRectangle.Location.X;
            double dy = layoutRectangle.Location.Y + _cyAscent;
            int count = _blocks.Count;
            for (int idx = 0; idx < count; idx++)
            {
                Block block = _blocks[idx];
                if (block.Stop)
                    break;
                if (block.Type == BlockType.LineBreak)
                    continue;
                _gfx.DrawString(block.Text, font, brush, dx + block.Location.X, dy + block.Location.Y);
            }
        }

        void CreateBlocks()
        {
            _blocks.Clear();
            int length = _text.Length;
            bool inNonWhiteSpace = false;
            int startIndex = 0, blockLength = 0;
            for (int idx = 0; idx < length; idx++)
            {
                char ch = _text[idx];

                if (ch == Chars.CR)
                {
                    if (idx < length - 1 && _text[idx + 1] == Chars.LF)
                        idx++;
                    ch = Chars.LF;
                }
                if (ch == Chars.LF)
                {
                    if (blockLength != 0)
                    {
                        string token = _text.Substring(startIndex, blockLength);
                        _blocks.Add(new Block(token, BlockType.Text,
                          _gfx.MeasureString(token, _font).Width));
                    }
                    startIndex = idx + 1;
                    blockLength = 0;
                    _blocks.Add(new Block(BlockType.LineBreak));
                }
                else if (ch != Chars.NonBreakableSpace && char.IsWhiteSpace(ch))
                {
                    if (inNonWhiteSpace)
                    {
                        string token = _text.Substring(startIndex, blockLength);
                        _blocks.Add(new Block(token, BlockType.Text,
                          _gfx.MeasureString(token, _font).Width));
                        startIndex = idx + 1;
                        blockLength = 0;
                    }
                    else
                    {
                        blockLength++;
                    }
                }
                else
                {
                    inNonWhiteSpace = true;
                    blockLength++;
                }
            }
            if (blockLength != 0)
            {
                string token = _text.Substring(startIndex, blockLength);
                _blocks.Add(new Block(token, BlockType.Text,
                  _gfx.MeasureString(token, _font).Width));
            }
        }

        void CreateLayout()
        {
            double rectWidth = _layoutRectangle.Width;
            double rectHeight = _layoutRectangle.Height - _cyAscent - _cyDescent;
            int firstIndex = 0;
            double x = 0, y = 0;
            int count = _blocks.Count;
            for (int idx = 0; idx < count; idx++)
            {
                Block block = _blocks[idx];
                if (block.Type == BlockType.LineBreak)
                {
                    if (Alignment == XParagraphAlignment.Justify)
                        _blocks[firstIndex].Alignment = XParagraphAlignment.Left;
                    AlignLine(firstIndex, idx - 1, rectWidth);
                    firstIndex = idx + 1;
                    x = 0;
                    y += _lineSpace;
                    if (y > rectHeight)
                    {
                        block.Stop = true;
                        break;
                    }
                }
                else
                {
                    double width = block.Width;
                    if ((x + width <= rectWidth || x == 0) && block.Type != BlockType.LineBreak)
                    {
                        block.Location = new XPoint(x, y);
                        x += width + _spaceWidth;
                    }
                    else
                    {
                        AlignLine(firstIndex, idx - 1, rectWidth);
                        firstIndex = idx;
                        y += _lineSpace;
                        if (y > rectHeight)
                        {
                            block.Stop = true;
                            break;
                        }
                        block.Location = new XPoint(0, y);
                        x = width + _spaceWidth;
                    }
                }
            }
            if (firstIndex < count && Alignment != XParagraphAlignment.Justify)
                AlignLine(firstIndex, count - 1, rectWidth);
        }

        void AlignLine(int firstIndex, int lastIndex, double layoutWidth)
        {
            XParagraphAlignment blockAlignment = _blocks[firstIndex].Alignment;
            if (_alignment == XParagraphAlignment.Left || blockAlignment == XParagraphAlignment.Left)
                return;

            int count = lastIndex - firstIndex + 1;
            if (count == 0)
                return;

            double totalWidth = -_spaceWidth;
            for (int idx = firstIndex; idx <= lastIndex; idx++)
                totalWidth += _blocks[idx].Width + _spaceWidth;

            double dx = Math.Max(layoutWidth - totalWidth, 0);
            if (_alignment != XParagraphAlignment.Justify)
            {
                if (_alignment == XParagraphAlignment.Center)
                    dx /= 2;
                for (int idx = firstIndex; idx <= lastIndex; idx++)
                {
                    Block block = _blocks[idx];
                    block.Location += new XSize(dx, 0);
                }
            }
            else if (count > 1)
            {
                dx /= count - 1;
                for (int idx = firstIndex + 1, i = 1; idx <= lastIndex; idx++, i++)
                {
                    Block block = _blocks[idx];
                    block.Location += new XSize(dx * i, 0);
                }
            }
        }

        readonly List<Block> _blocks = new List<Block>();

        enum BlockType
        {
            Text, Space, Hyphen, LineBreak,
        }

        class Block
        {
            public Block(string text, BlockType type, double width)
            {
                Text = text;
                Type = type;
                Width = width;
            }

            public Block(BlockType type)
            {
                Type = type;
            }

            public readonly string Text;

            public readonly BlockType Type;

            public readonly double Width;

            public XPoint Location;

            public XParagraphAlignment Alignment;

            public bool Stop;
        }
    }
    enum DirtyFlags
    {
        Ctm = 0x00000001,
        ClipPath = 0x00000002,
        LineWidth = 0x00000010,
        LineJoin = 0x00000020,
        MiterLimit = 0x00000040,
        StrokeFill = 0x00000070,
    }
    enum StreamMode
    {
        Graphic,

        Text,
    }
    internal sealed class PdfGraphicsState : ICloneable
    {
        public PdfGraphicsState(XGraphicsPdfRenderer renderer)
        {
            _renderer = renderer;
        }
        readonly XGraphicsPdfRenderer _renderer;

        public PdfGraphicsState Clone()
        {
            PdfGraphicsState state = (PdfGraphicsState)MemberwiseClone();
            return state;
        }

        object ICloneable.Clone()
        {
            return Clone();
        }

        internal int Level;

        internal InternalGraphicsState InternalState;

        public void PushState()
        {
            _renderer.Append("q/n");
        }

        public void PopState()
        {
            _renderer.Append("Q/n");
        }

        double _realizedLineWith = -1;
        int _realizedLineCap = -1;
        int _realizedLineJoin = -1;
        double _realizedMiterLimit = -1;
        XDashStyle _realizedDashStyle = (XDashStyle)(-1);
        string _realizedDashPattern;
        XColor _realizedStrokeColor = XColor.Empty;
        bool _realizedStrokeOverPrint;

        public void RealizePen(XPen pen, PdfColorMode colorMode)
        {
            const string frmt2 = Config.SignificantFigures2;
            const string format = Config.SignificantFigures3;
            XColor color = pen.Color;
            bool overPrint = pen.Overprint;
            color = ColorSpaceHelper.EnsureColorMode(colorMode, color);

            if (_realizedLineWith != pen._width)
            {
                _renderer.AppendFormatArgs("{0:" + format + "} w\n", pen._width);
                _realizedLineWith = pen._width;
            }

            if (_realizedLineCap != (int)pen._lineCap)
            {
                _renderer.AppendFormatArgs("{0} J\n", (int)pen._lineCap);
                _realizedLineCap = (int)pen._lineCap;
            }

            if (_realizedLineJoin != (int)pen._lineJoin)
            {
                _renderer.AppendFormatArgs("{0} j\n", (int)pen._lineJoin);
                _realizedLineJoin = (int)pen._lineJoin;
            }

            if (_realizedLineCap == (int)XLineJoin.Miter)
            {
                if (_realizedMiterLimit != (int)pen._miterLimit && (int)pen._miterLimit != 0)
                {
                    _renderer.AppendFormatInt("{0} M\n", (int)pen._miterLimit);
                    _realizedMiterLimit = (int)pen._miterLimit;
                }
            }

            if (_realizedDashStyle != pen._dashStyle || pen._dashStyle == XDashStyle.Custom)
            {
                double dot = pen.Width;
                double dash = 3 * dot;

                XDashStyle dashStyle = pen.DashStyle;
                if (dot == 0)
                    dashStyle = XDashStyle.Solid;

                switch (dashStyle)
                {
                    case XDashStyle.Solid:
                        _renderer.Append("[]0 d\n");
                        break;

                    case XDashStyle.Dash:
                        _renderer.AppendFormatArgs("[{0:" + frmt2 + "} {1:" + frmt2 + "}]0 d\n", dash, dot);
                        break;

                    case XDashStyle.Dot:
                        _renderer.AppendFormatArgs("[{0:" + frmt2 + "}]0 d\n", dot);
                        break;

                    case XDashStyle.DashDot:
                        _renderer.AppendFormatArgs("[{0:" + frmt2 + "} {1:" + frmt2 + "} {1:" + frmt2 + "} {1:" + frmt2 + "}]0 d\n", dash, dot);
                        break;

                    case XDashStyle.DashDotDot:
                        _renderer.AppendFormatArgs("[{0:" + frmt2 + "} {1:" + frmt2 + "} {1:" + frmt2 + "} {1:" + frmt2 + "} {1:" + frmt2 + "} {1:" + frmt2 + "}]0 d\n", dash, dot);
                        break;

                    case XDashStyle.Custom:
                        {
                            StringBuilder pdf = new StringBuilder("[", 256);
                            int len = pen._dashPattern == null ? 0 : pen._dashPattern.Length;
                            for (int idx = 0; idx < len; idx++)
                            {
                                if (idx > 0)
                                    pdf.Append(' ');
                                pdf.Append(PdfEncoders.ToString(pen._dashPattern[idx] * pen._width));
                            }
                            if (len > 0 && len % 2 == 1)
                            {
                                pdf.Append(' ');
                                pdf.Append(PdfEncoders.ToString(0.2 * pen._width));
                            }
                            pdf.AppendFormat(CultureInfo.InvariantCulture, "]{0:" + format + "} d\n", pen._dashOffset * pen._width);
                            string pattern = pdf.ToString();

                            {
                                _realizedDashPattern = pattern;
                                _renderer.Append(pattern);
                            }
                        }
                        break;
                }
                _realizedDashStyle = dashStyle;
            }

            if (colorMode != PdfColorMode.Cmyk)
            {
                if (_realizedStrokeColor.Rgb != color.Rgb)
                {
                    _renderer.Append(PdfEncoders.ToString(color, PdfColorMode.Rgb));
                    _renderer.Append(" RG\n");
                }
            }
            else
            {
                if (!ColorSpaceHelper.IsEqualCmyk(_realizedStrokeColor, color))
                {
                    _renderer.Append(PdfEncoders.ToString(color, PdfColorMode.Cmyk));
                    _renderer.Append(" K\n");
                }
            }

            if (_renderer.Owner.Version >= 14 && (_realizedStrokeColor.A != color.A || _realizedStrokeOverPrint != overPrint))
            {
                PdfExtGState extGState = _renderer.Owner.ExtGStateTable.GetExtGStateStroke(color.A, overPrint);
                string gs = _renderer.Resources.AddExtGState(extGState);
                _renderer.AppendFormatString("{0} gs\n", gs);

                if (_renderer._page != null && color.A < 1)
                    _renderer._page.TransparencyUsed = true;
            }
            _realizedStrokeColor = color;
            _realizedStrokeOverPrint = overPrint;
        }

        XColor _realizedFillColor = XColor.Empty;
        bool _realizedNonStrokeOverPrint;

        public void RealizeBrush(XBrush brush, PdfColorMode colorMode, int renderingMode, double fontEmSize)
        {
            XSolidBrush solidBrush = brush as XSolidBrush;
            if (solidBrush != null)
            {
                XColor color = solidBrush.Color;
                bool overPrint = solidBrush.Overprint;

                if (renderingMode == 0)
                {
                    RealizeFillColor(color, overPrint, colorMode);
                }
                else if (renderingMode == 2)
                {
                    RealizeFillColor(color, false, colorMode);
                    RealizePen(new XPen(color, fontEmSize * Const.BoldEmphasis), colorMode);
                }
                else
                    throw new InvalidOperationException("Only rendering modes 0 and 2 are currently supported.");
            }
            else
            {
                if (renderingMode != 0)
                    throw new InvalidOperationException("Rendering modes other than 0 can only be used with solid color brushes.");

                XLinearGradientBrush gradientBrush = brush as XLinearGradientBrush;
                if (gradientBrush != null)
                {
                    Debug.Assert(UnrealizedCtm.IsIdentity, "Must realize ctm first.");
                    XMatrix matrix = _renderer.DefaultViewMatrix;
                    matrix.Prepend(EffectiveCtm);
                    PdfShadingPattern pattern = new PdfShadingPattern(_renderer.Owner);
                    pattern.SetupFromBrush(gradientBrush, matrix, _renderer);
                    string name = _renderer.Resources.AddPattern(pattern);
                    _renderer.AppendFormatString("/Pattern cs\n", name);
                    _renderer.AppendFormatString("{0} scn\n", name);

                    _realizedFillColor = XColor.Empty;
                }
            }
        }

        private void RealizeFillColor(XColor color, bool overPrint, PdfColorMode colorMode)
        {
            color = ColorSpaceHelper.EnsureColorMode(colorMode, color);

            if (colorMode != PdfColorMode.Cmyk)
            {
                if (_realizedFillColor.IsEmpty || _realizedFillColor.Rgb != color.Rgb)
                {
                    _renderer.Append(PdfEncoders.ToString(color, PdfColorMode.Rgb));
                    _renderer.Append(" rg\n");
                }
            }
            else
            {
                Debug.Assert(colorMode == PdfColorMode.Cmyk);

                if (_realizedFillColor.IsEmpty || !ColorSpaceHelper.IsEqualCmyk(_realizedFillColor, color))
                {
                    _renderer.Append(PdfEncoders.ToString(color, PdfColorMode.Cmyk));
                    _renderer.Append(" k\n");
                }
            }

            if (_renderer.Owner.Version >= 14 && (_realizedFillColor.A != color.A || _realizedNonStrokeOverPrint != overPrint))
            {

                PdfExtGState extGState = _renderer.Owner.ExtGStateTable.GetExtGStateNonStroke(color.A, overPrint);
                string gs = _renderer.Resources.AddExtGState(extGState);
                _renderer.AppendFormatString("{0} gs\n", gs);

                if (_renderer._page != null && color.A < 1)
                    _renderer._page.TransparencyUsed = true;
            }
            _realizedFillColor = color;
            _realizedNonStrokeOverPrint = overPrint;
        }

        internal void RealizeNonStrokeTransparency(double transparency, PdfColorMode colorMode)
        {
            XColor color = _realizedFillColor;
            color.A = transparency;
            RealizeFillColor(color, _realizedNonStrokeOverPrint, colorMode);
        }

        internal PdfFont _realizedFont;
        string _realizedFontName = String.Empty;
        double _realizedFontSize;
        int _realizedRenderingMode;
        double _realizedCharSpace;

        public void RealizeFont(XFont font, XBrush brush, int renderingMode)
        {
            const string format = Config.SignificantFigures3;

            RealizeBrush(brush, _renderer._colorMode, renderingMode, font.Size);

            if (_realizedRenderingMode != renderingMode)
            {
                _renderer.AppendFormatInt("{0} Tr\n", renderingMode);
                _realizedRenderingMode = renderingMode;
            }

            if (_realizedRenderingMode == 0)
            {
                if (_realizedCharSpace != 0)
                {
                    _renderer.Append("0 Tc\n");
                    _realizedCharSpace = 0;
                }
            }
            else
            {
                double charSpace = font.Size * Const.BoldEmphasis;
                if (_realizedCharSpace != charSpace)
                {
                    _renderer.AppendFormatDouble("{0:" + format + "} Tc\n", charSpace);
                    _realizedCharSpace = charSpace;
                }
            }

            _realizedFont = null;
            string fontName = _renderer.GetFontName(font, out _realizedFont);
            if (fontName != _realizedFontName || _realizedFontSize != font.Size)
            {
                if (_renderer.Gfx.PageDirection == XPageDirection.Downwards)
                    _renderer.AppendFormatFont("{0} {1:" + format + "} Tf\n", fontName, font.Size);
                else
                    _renderer.AppendFormatFont("{0} {1:" + format + "} Tf\n", fontName, font.Size);
                _realizedFontName = fontName;
                _realizedFontSize = font.Size;
            }
        }

        public XPoint RealizedTextPosition;

        public bool ItalicSimulationOn;

        public XMatrix RealizedCtm;

        public XMatrix UnrealizedCtm;

        public XMatrix EffectiveCtm;

        public XMatrix InverseEffectiveCtm;

        public XMatrix WorldTransform;

        public void AddTransform(XMatrix value, XMatrixOrder matrixOrder)
        {
            XMatrix transform = value;
            if (_renderer.Gfx.PageDirection == XPageDirection.Downwards)
            {
                transform.M12 = -value.M12;
                transform.M21 = -value.M21;
            }
            UnrealizedCtm.Prepend(transform);

            WorldTransform.Prepend(value);
        }

        public void RealizeCtm()
        {
            if (!UnrealizedCtm.IsIdentity)
            {
                Debug.Assert(!UnrealizedCtm.IsIdentity, "mrCtm is unnecessarily set.");

                const string format = Config.SignificantFigures7;

                double[] matrix = UnrealizedCtm.GetElements();
                _renderer.AppendFormatArgs("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} cm\n",
                    matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);

                RealizedCtm.Prepend(UnrealizedCtm);
                UnrealizedCtm = new XMatrix();
                EffectiveCtm = RealizedCtm;
                InverseEffectiveCtm = EffectiveCtm;
                InverseEffectiveCtm.Invert();
            }
        }
        public void SetAndRealizeClipRect(XRect clipRect)
        {
            XGraphicsPath clipPath = new XGraphicsPath();
            clipPath.AddRectangle(clipRect);
            RealizeClipPath(clipPath);
        }

        public void SetAndRealizeClipPath(XGraphicsPath clipPath)
        {
            RealizeClipPath(clipPath);
        }

        void RealizeClipPath(XGraphicsPath clipPath)
        {
#if CORE
            DiagnosticsHelper.HandleNotImplemented("RealizeClipPath");
#endif
            _renderer.BeginGraphicMode();
            RealizeCtm();
#if CORE
            _renderer.AppendPath(clipPath._corePath);
#endif
            _renderer.Append(clipPath.FillMode == XFillMode.Winding ? "W n\n" : "W* n\n");
        }

    }
    internal class XGraphicsPdfRenderer : IXGraphicsRenderer
    {
        public XGraphicsPdfRenderer(PdfPage page, XGraphics gfx, XGraphicsPdfPageOptions options)
        {
            _page = page;
            _colorMode = page._document.Options.ColorMode;
            _options = options;
            _gfx = gfx;
            _content = new StringBuilder();
            page.RenderContent._pdfRenderer = this;
            _gfxState = new PdfGraphicsState(this);
        }

        public XGraphicsPdfRenderer(XForm form, XGraphics gfx)
        {
            _form = form;
            _colorMode = form.Owner.Options.ColorMode;
            _gfx = gfx;
            _content = new StringBuilder();
            form.PdfRenderer = this;
            _gfxState = new PdfGraphicsState(this);
        }

        string GetContent()
        {
            EndPage();
            return _content.ToString();
        }

        public XGraphicsPdfPageOptions PageOptions
        {
            get { return _options; }
        }

        public void Close()
        {
            if (_page != null)
            {
                PdfContent content2 = _page.RenderContent;
                content2.CreateStream(PdfEncoders.RawEncoding.GetBytes(GetContent()));

                _gfx = null;
                _page.RenderContent._pdfRenderer = null;
                _page.RenderContent = null;
                _page = null;
            }
            else if (_form != null)
            {
                _form._pdfForm.CreateStream(PdfEncoders.RawEncoding.GetBytes(GetContent()));
                _gfx = null;
                _form.PdfRenderer = null;
                _form = null;
            }
        }

        public void DrawLine(XPen pen, double x1, double y1, double x2, double y2)
        {
            DrawLines(pen, new XPoint[] { new XPoint(x1, y1), new XPoint(x2, y2) });
        }

        public void DrawLines(XPen pen, XPoint[] points)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            int count = points.Length;
            if (count == 0)
                return;

            Realize(pen);

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx++)
                AppendFormatPoint("{0:" + format + "} {1:" + format + "} l\n", points[idx].X, points[idx].Y);
            _content.Append("S\n");
        }

        public void DrawBezier(XPen pen, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            DrawBeziers(pen, new XPoint[] { new XPoint(x1, y1), new XPoint(x2, y2), new XPoint(x3, y3), new XPoint(x4, y4) });
        }

        public void DrawBeziers(XPen pen, XPoint[] points)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            int count = points.Length;
            if (count == 0)
                return;

            if ((count - 1) % 3 != 0)
                throw new ArgumentException("Invalid number of points for bezier curves. Number must fulfil 4+3n.", "points");

            Realize(pen);

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx += 3)
                AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
                    points[idx].X, points[idx].Y,
                    points[idx + 1].X, points[idx + 1].Y,
                    points[idx + 2].X, points[idx + 2].Y);

            AppendStrokeFill(pen, null, XFillMode.Alternate, false);
        }

        public void DrawCurve(XPen pen, XPoint[] points, double tension)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            int count = points.Length;
            if (count == 0)
                return;
            if (count < 2)
                throw new ArgumentException("Not enough points", "points");

            tension /= 3;

            Realize(pen);

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", points[0].X, points[0].Y);
            if (count == 2)
            {
                AppendCurveSegment(points[0], points[0], points[1], points[1], tension);
            }
            else
            {
                AppendCurveSegment(points[0], points[0], points[1], points[2], tension);
                for (int idx = 1; idx < count - 2; idx++)
                    AppendCurveSegment(points[idx - 1], points[idx], points[idx + 1], points[idx + 2], tension);
                AppendCurveSegment(points[count - 3], points[count - 2], points[count - 1], points[count - 1], tension);
            }
            AppendStrokeFill(pen, null, XFillMode.Alternate, false);
        }

        public void DrawArc(XPen pen, double x, double y, double width, double height, double startAngle, double sweepAngle)
        {
            if (pen == null)
                throw new ArgumentNullException("pen");

            Realize(pen);

            AppendPartialArc(x, y, width, height, startAngle, sweepAngle, PathStart.MoveTo1st, new XMatrix());
            AppendStrokeFill(pen, null, XFillMode.Alternate, false);
        }

        public void DrawRectangle(XPen pen, XBrush brush, double x, double y, double width, double height)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen and brush");

            const string format = Config.SignificantFigures3;

            Realize(pen, brush);
            AppendFormatRect("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} re\n", x, y + height, width, height);

            if (pen != null && brush != null)
                _content.Append("B\n");
            else if (pen != null)
                _content.Append("S\n");
            else
                _content.Append("f\n");
        }

        public void DrawRectangles(XPen pen, XBrush brush, XRect[] rects)
        {
            int count = rects.Length;
            for (int idx = 0; idx < count; idx++)
            {
                XRect rect = rects[idx];
                DrawRectangle(pen, brush, rect.X, rect.Y, rect.Width, rect.Height);
            }
        }

        public void DrawRoundedRectangle(XPen pen, XBrush brush, double x, double y, double width, double height, double ellipseWidth, double ellipseHeight)
        {
            XGraphicsPath path = new XGraphicsPath();
            path.AddRoundedRectangle(x, y, width, height, ellipseWidth, ellipseHeight);
            DrawPath(pen, brush, path);
        }

        public void DrawEllipse(XPen pen, XBrush brush, double x, double y, double width, double height)
        {
            Realize(pen, brush);

            XRect rect = new XRect(x, y, width, height);
            double δx = rect.Width / 2;
            double δy = rect.Height / 2;
            double fx = δx * Const.κ;
            double fy = δy * Const.κ;
            double x0 = rect.X + δx;
            double y0 = rect.Y + δy;

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", x0 + δx, y0);
            AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
              x0 + δx, y0 + fy, x0 + fx, y0 + δy, x0, y0 + δy);
            AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
              x0 - fx, y0 + δy, x0 - δx, y0 + fy, x0 - δx, y0);
            AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
              x0 - δx, y0 - fy, x0 - fx, y0 - δy, x0, y0 - δy);
            AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
              x0 + fx, y0 - δy, x0 + δx, y0 - fy, x0 + δx, y0);
            AppendStrokeFill(pen, brush, XFillMode.Winding, true);
        }

        public void DrawPolygon(XPen pen, XBrush brush, XPoint[] points, XFillMode fillmode)
        {
            Realize(pen, brush);

            int count = points.Length;
            if (points.Length < 2)
                throw new ArgumentException(PSSR.PointArrayAtLeast(2), "points");

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", points[0].X, points[0].Y);
            for (int idx = 1; idx < count; idx++)
                AppendFormatPoint("{0:" + format + "} {1:" + format + "} l\n", points[idx].X, points[idx].Y);

            AppendStrokeFill(pen, brush, fillmode, true);
        }

        public void DrawPie(XPen pen, XBrush brush, double x, double y, double width, double height,
          double startAngle, double sweepAngle)
        {
            Realize(pen, brush);

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", x + width / 2, y + height / 2);
            AppendPartialArc(x, y, width, height, startAngle, sweepAngle, PathStart.LineTo1st, new XMatrix());
            AppendStrokeFill(pen, brush, XFillMode.Alternate, true);
        }

        public void DrawClosedCurve(XPen pen, XBrush brush, XPoint[] points, double tension, XFillMode fillmode)
        {
            int count = points.Length;
            if (count == 0)
                return;
            if (count < 2)
                throw new ArgumentException("Not enough points.", "points");

            tension /= 3;

            Realize(pen, brush);

            const string format = Config.SignificantFigures4;
            AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", points[0].X, points[0].Y);
            if (count == 2)
            {
                AppendCurveSegment(points[0], points[0], points[1], points[1], tension);
            }
            else
            {
                AppendCurveSegment(points[count - 1], points[0], points[1], points[2], tension);
                for (int idx = 1; idx < count - 2; idx++)
                    AppendCurveSegment(points[idx - 1], points[idx], points[idx + 1], points[idx + 2], tension);
                AppendCurveSegment(points[count - 3], points[count - 2], points[count - 1], points[0], tension);
                AppendCurveSegment(points[count - 2], points[count - 1], points[0], points[1], tension);
            }
            AppendStrokeFill(pen, brush, fillmode, true);
        }

        public void DrawPath(XPen pen, XBrush brush, XGraphicsPath path)
        {
            if (pen == null && brush == null)
                throw new ArgumentNullException("pen");

#if CORE
            Realize(pen, brush);
            AppendPath(path._corePath);
            AppendStrokeFill(pen, brush, path.FillMode, false);
#endif
        }

        public void DrawString(string s, XFont font, XBrush brush, XRect rect, XStringFormat format)
        {
            double x = rect.X;
            double y = rect.Y;

            double lineSpace = font.GetHeight();
            double cyAscent = lineSpace * font.CellAscent / font.CellSpace;
            double cyDescent = lineSpace * font.CellDescent / font.CellSpace;
            double width = _gfx.MeasureString(s, font).Width;

            bool italicSimulation = (font.GlyphTypeface.StyleSimulations & XStyleSimulations.ItalicSimulation) != 0;
            bool boldSimulation = (font.GlyphTypeface.StyleSimulations & XStyleSimulations.BoldSimulation) != 0;
            bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;
            bool underline = (font.Style & XFontStyle.Underline) != 0;

            Realize(font, brush, boldSimulation ? 2 : 0);

            switch (format.Alignment)
            {
                case XStringAlignment.Near:
                    break;

                case XStringAlignment.Center:
                    x += (rect.Width - width) / 2;
                    break;

                case XStringAlignment.Far:
                    x += rect.Width - width;
                    break;
            }
            if (Gfx.PageDirection == XPageDirection.Downwards)
            {
                switch (format.LineAlignment)
                {
                    case XLineAlignment.Near:
                        y += cyAscent;
                        break;

                    case XLineAlignment.Center:
                        y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;
                        break;

                    case XLineAlignment.Far:
                        y += -cyDescent + rect.Height;
                        break;

                    case XLineAlignment.BaseLine:
                        break;
                }
            }
            else
            {
                switch (format.LineAlignment)
                {
                    case XLineAlignment.Near:
                        y += cyDescent;
                        break;

                    case XLineAlignment.Center:
                        y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;
                        break;

                    case XLineAlignment.Far:
                        y += -cyAscent + rect.Height;
                        break;

                    case XLineAlignment.BaseLine:
                        break;
                }
            }

            PdfFont realizedFont = _gfxState._realizedFont;
            Debug.Assert(realizedFont != null);
            realizedFont.AddChars(s);

            const string format2 = Config.SignificantFigures4;
            OpenTypeDescriptor descriptor = realizedFont.FontDescriptor._descriptor;

            string text = null;
            if (font.Unicode)
            {
                StringBuilder sb = new StringBuilder();
                bool isSymbolFont = descriptor.FontFace.cmap.symbol;
                for (int idx = 0; idx < s.Length; idx++)
                {
                    char ch = s[idx];
                    if (isSymbolFont)
                    {
                        ch = (char)(ch | (descriptor.FontFace.os2.usFirstCharIndex & 0xFF00));
                    }
                    int glyphID = descriptor.CharCodeToGlyphIndex(ch);
                    sb.Append((char)glyphID);
                }
                s = sb.ToString();

                byte[] bytes = PdfEncoders.RawUnicodeEncoding.GetBytes(s);
                bytes = PdfEncoders.FormatStringLiteral(bytes, true, false, true, null);
                text = PdfEncoders.RawEncoding.GetString(bytes, 0, bytes.Length);
            }
            else
            {
                byte[] bytes = PdfEncoders.WinAnsiEncoding.GetBytes(s);
                text = PdfEncoders.ToStringLiteral(bytes, false, null);
            }

            XPoint pos = new XPoint(x, y);
            pos = WorldToView(pos);

            double verticalOffset = 0;
            if (boldSimulation)
            {
            }

#if ITALIC_SIMULATION
            if (italicSimulation)
            {
                if (_gfxState.ItalicSimulationOn)
                {
                    AdjustTdOffset(ref pos, verticalOffset, true);
                    AppendFormatArgs("{0:" + format2 + "} {1:" + format2 + "} Td\n{2} Tj\n", pos.X, pos.Y, text);
                }
                else
                {
                    XMatrix m = new XMatrix(1, 0, Const.ItalicSkewAngleSinus, 1, pos.X, pos.Y);
                    AppendFormatArgs("{0:" + format2 + "} {1:" + format2 + "} {2:" + format2 + "} {3:" + format2 + "} {4:" + format2 + "} {5:" + format2 + "} Tm\n{6} Tj\n",
                        m.M11, m.M12, m.M21, m.M22, m.OffsetX, m.OffsetY, text);
                    _gfxState.ItalicSimulationOn = true;
                    AdjustTdOffset(ref pos, verticalOffset, false);
                }
            }
            else
            {
                if (_gfxState.ItalicSimulationOn)
                {
                    XMatrix m = new XMatrix(1, 0, 0, 1, pos.X, pos.Y);
                    AppendFormatArgs("{0:" + format2 + "} {1:" + format2 + "} {2:" + format2 + "} {3:" + format2 + "} {4:" + format2 + "} {5:" + format2 + "} Tm\n{6} Tj\n",
                        m.M11, m.M12, m.M21, m.M22, m.OffsetX, m.OffsetY, text);
                    _gfxState.ItalicSimulationOn = false;
                    AdjustTdOffset(ref pos, verticalOffset, false);
                }
                else
                {
                    AdjustTdOffset(ref pos, verticalOffset, false);
                    AppendFormatArgs("{0:" + format2 + "} {1:" + format2 + "} Td {2} Tj\n", pos.X, pos.Y, text);
                }
            }
#endif
            if (underline)
            {
                double underlinePosition = lineSpace * realizedFont.FontDescriptor._descriptor.UnderlinePosition / font.CellSpace;
                double underlineThickness = lineSpace * realizedFont.FontDescriptor._descriptor.UnderlineThickness / font.CellSpace;
                double underlineRectY = Gfx.PageDirection == XPageDirection.Downwards
                    ? y - underlinePosition
                    : y + underlinePosition - underlineThickness;
                DrawRectangle(null, brush, x, underlineRectY, width, underlineThickness);
            }

            if (strikeout)
            {
                double strikeoutPosition = lineSpace * realizedFont.FontDescriptor._descriptor.StrikeoutPosition / font.CellSpace;
                double strikeoutSize = lineSpace * realizedFont.FontDescriptor._descriptor.StrikeoutSize / font.CellSpace;
                double strikeoutRectY = Gfx.PageDirection == XPageDirection.Downwards
                    ? y - strikeoutPosition
                    : y + strikeoutPosition - strikeoutSize;
                DrawRectangle(null, brush, x, strikeoutRectY, width, strikeoutSize);
            }
        }

        public void DrawImage(XImage image, double x, double y, double width, double height)
        {
            const string format = Config.SignificantFigures4;

            string name = Realize(image);
            if (!(image is XForm))
            {
                if (_gfx.PageDirection == XPageDirection.Downwards)
                {
                    AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do Q\n",
                        x, y + height, width, height, name);
                }
                else
                {
                    AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do Q\n",
                        x, y, width, height, name);
                }
            }
            else
            {
                BeginPage();

                XForm form = (XForm)image;
                form.Finish();

                PdfFormXObject pdfForm = Owner.FormTable.GetForm(form);

                double cx = width / image.PointWidth;
                double cy = height / image.PointHeight;

                if (cx != 0 && cy != 0)
                {
                    XPdfForm xForm = image as XPdfForm;
                    if (_gfx.PageDirection == XPageDirection.Downwards)
                    {
                        double xDraw = x;
                        double yDraw = y;
                        if (xForm != null)
                        {
                            xDraw -= xForm.Page.MediaBox.X1;
                            yDraw += xForm.Page.MediaBox.Y1;
                        }
                        AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm 100 Tz {4} Do Q\n",
                            xDraw, yDraw + height, cx, cy, name);
                    }
                    else
                    {
                        AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do Q\n",
                            x, y, cx, cy, name);
                    }
                }
            }
        }

        public void DrawImage(XImage image, XRect destRect, XRect srcRect, XGraphicsUnit srcUnit)
        {
            const string format = Config.SignificantFigures4;

            double x = destRect.X;
            double y = destRect.Y;
            double width = destRect.Width;
            double height = destRect.Height;

            string name = Realize(image);
            if (!(image is XForm))
            {
                if (_gfx.PageDirection == XPageDirection.Downwards)
                {
                    AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do\nQ\n",
                        x, y + height, width, height, name);
                }
                else
                {
                    AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do Q\n",
                        x, y, width, height, name);
                }
            }
            else
            {
                BeginPage();

                XForm form = (XForm)image;
                form.Finish();

                PdfFormXObject pdfForm = Owner.FormTable.GetForm(form);

                double cx = width / image.PointWidth;
                double cy = height / image.PointHeight;

                if (cx != 0 && cy != 0)
                {
                    XPdfForm xForm = image as XPdfForm;
                    if (_gfx.PageDirection == XPageDirection.Downwards)
                    {
                        double xDraw = x;
                        double yDraw = y;
                        if (xForm != null)
                        {
                            xDraw -= xForm.Page.MediaBox.X1;
                            yDraw += xForm.Page.MediaBox.Y1;
                        }
                        AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do Q\n",
                            xDraw, yDraw + height, cx, cy, name);
                    }
                    else
                    {
                        AppendFormatImage("q {2:" + format + "} 0 0 {3:" + format + "} {0:" + format + "} {1:" + format + "} cm {4} Do Q\n",
                            x, y, cx, cy, name);
                    }
                }
            }
        }

        public void Save(XGraphicsState state)
        {
            BeginGraphicMode();
            RealizeTransform();
            _gfxState.InternalState = state.InternalState;
            SaveState();
        }

        public void Restore(XGraphicsState state)
        {
            BeginGraphicMode();
            RestoreState(state.InternalState);
        }

        public void BeginContainer(XGraphicsContainer container, XRect dstrect, XRect srcrect, XGraphicsUnit unit)
        {
            BeginGraphicMode();
            RealizeTransform();
            _gfxState.InternalState = container.InternalState;
            SaveState();
        }

        public void EndContainer(XGraphicsContainer container)
        {
            BeginGraphicMode();
            RestoreState(container.InternalState);
        }

        public XMatrix Transform
        {
            get
            {
                if (_gfxState.UnrealizedCtm.IsIdentity)
                    return _gfxState.EffectiveCtm;
                return _gfxState.UnrealizedCtm * _gfxState.RealizedCtm;
            }
        }

        public void AddTransform(XMatrix value, XMatrixOrder matrixOrder)
        {
            _gfxState.AddTransform(value, matrixOrder);
        }

        public void SetClip(XGraphicsPath path, XCombineMode combineMode)
        {
            if (path == null)
                throw new NotImplementedException("SetClip with no path.");

            if (_gfxState.Level < GraphicsStackLevelWorldSpace)
                RealizeTransform();

            if (combineMode == XCombineMode.Replace)
            {
                if (_clipLevel != 0)
                {
                    if (_clipLevel != _gfxState.Level)
                        throw new NotImplementedException("Cannot set new clip region in an inner graphic state level.");
                    else
                        ResetClip();
                }
                _clipLevel = _gfxState.Level;
            }
            else if (combineMode == XCombineMode.Intersect)
            {
                if (_clipLevel == 0)
                    _clipLevel = _gfxState.Level;
            }
            else
            {
                Debug.Assert(false, "Invalid XCombineMode in internal function.");
            }
            _gfxState.SetAndRealizeClipPath(path);
        }

        public void ResetClip()
        {
            if (_clipLevel == 0)
                return;

            if (_clipLevel != _gfxState.Level)
                throw new NotImplementedException("Cannot reset clip region in an inner graphic state level.");

            BeginGraphicMode();

            InternalGraphicsState state = _gfxState.InternalState;
            XMatrix ctm = _gfxState.EffectiveCtm;
            RestoreState();
            SaveState();
            _gfxState.InternalState = state;
        }

        int _clipLevel;

        public void WriteComment(string comment)
        {
            comment = comment.Replace("\n", "\n% ");
            Append("% " + comment + "\n");
        }

        void AppendPartialArc(double x, double y, double width, double height, double startAngle, double sweepAngle, PathStart pathStart, XMatrix matrix)
        {
            double α = startAngle;
            if (α < 0)
                α = α + (1 + Math.Floor((Math.Abs(α) / 360))) * 360;
            else if (α > 360)
                α = α - Math.Floor(α / 360) * 360;
            Debug.Assert(α >= 0 && α <= 360);

            double β = sweepAngle;
            if (β < -360)
                β = -360;
            else if (β > 360)
                β = 360;

            if (α == 0 && β < 0)
                α = 360;
            else if (α == 360 && β > 0)
                α = 0;

            bool smallAngle = Math.Abs(β) <= 90;

            β = α + β;
            if (β < 0)
                β = β + (1 + Math.Floor((Math.Abs(β) / 360))) * 360;

            bool clockwise = sweepAngle > 0;
            int startQuadrant = Quadrant(α, true, clockwise);
            int endQuadrant = Quadrant(β, false, clockwise);

            if (startQuadrant == endQuadrant && smallAngle)
                AppendPartialArcQuadrant(x, y, width, height, α, β, pathStart, matrix);
            else
            {
                int currentQuadrant = startQuadrant;
                bool firstLoop = true;
                do
                {
                    if (currentQuadrant == startQuadrant && firstLoop)
                    {
                        double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);
                        AppendPartialArcQuadrant(x, y, width, height, α, ξ, pathStart, matrix);
                    }
                    else if (currentQuadrant == endQuadrant)
                    {
                        double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);
                        AppendPartialArcQuadrant(x, y, width, height, ξ, β, PathStart.Ignore1st, matrix);
                    }
                    else
                    {
                        double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);
                        double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);
                        AppendPartialArcQuadrant(x, y, width, height, ξ1, ξ2, PathStart.Ignore1st, matrix);
                    }

                    if (currentQuadrant == endQuadrant && smallAngle)
                        break;

                    smallAngle = true;

                    if (clockwise)
                        currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;
                    else
                        currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;

                    firstLoop = false;
                } while (true);
            }
        }

        int Quadrant(double φ, bool start, bool clockwise)
        {
            Debug.Assert(φ >= 0);
            if (φ > 360)
                φ = φ - Math.Floor(φ / 360) * 360;

            int quadrant = (int)(φ / 90);
            if (quadrant * 90 == φ)
            {
                if ((start && !clockwise) || (!start && clockwise))
                    quadrant = quadrant == 0 ? 3 : quadrant - 1;
            }
            else
                quadrant = clockwise ? ((int)Math.Floor(φ / 90)) % 4 : (int)Math.Floor(φ / 90);
            return quadrant;
        }

        void AppendPartialArcQuadrant(double x, double y, double width, double height, double α, double β, PathStart pathStart, XMatrix matrix)
        {
            Debug.Assert(α >= 0 && α <= 360);
            Debug.Assert(β >= 0);
            if (β > 360)
                β = β - Math.Floor(β / 360) * 360;
            Debug.Assert(Math.Abs(α - β) <= 90);

            double δx = width / 2;
            double δy = height / 2;

            double x0 = x + δx;
            double y0 = y + δy;

            bool reflect = false;
            if (α >= 180 && β >= 180)
            {
                α -= 180;
                β -= 180;
                reflect = true;
            }

            double sinα, sinβ;
            if (width == height)
            {
                α = α * Calc.Deg2Rad;
                β = β * Calc.Deg2Rad;
            }
            else
            {
                α = α * Calc.Deg2Rad;
                sinα = Math.Sin(α);
                if (Math.Abs(sinα) > 1E-10)
                    α = Math.PI / 2 - Math.Atan(δy * Math.Cos(α) / (δx * sinα));
                β = β * Calc.Deg2Rad;
                sinβ = Math.Sin(β);
                if (Math.Abs(sinβ) > 1E-10)
                    β = Math.PI / 2 - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));
            }

            double κ = 4 * (1 - Math.Cos((α - β) / 2)) / (3 * Math.Sin((β - α) / 2));
            sinα = Math.Sin(α);
            double cosα = Math.Cos(α);
            sinβ = Math.Sin(β);
            double cosβ = Math.Cos(β);

            const string format = Config.SignificantFigures3;
            XPoint pt1, pt2, pt3;
            if (!reflect)
            {
                switch (pathStart)
                {
                    case PathStart.MoveTo1st:
                        pt1 = matrix.Transform(new XPoint(x0 + δx * cosα, y0 + δy * sinα));
                        AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", pt1.X, pt1.Y);
                        break;

                    case PathStart.LineTo1st:
                        pt1 = matrix.Transform(new XPoint(x0 + δx * cosα, y0 + δy * sinα));
                        AppendFormatPoint("{0:" + format + "} {1:" + format + "} l\n", pt1.X, pt1.Y);
                        break;

                    case PathStart.Ignore1st:
                        break;
                }
                pt1 = matrix.Transform(new XPoint(x0 + δx * (cosα - κ * sinα), y0 + δy * (sinα + κ * cosα)));
                pt2 = matrix.Transform(new XPoint(x0 + δx * (cosβ + κ * sinβ), y0 + δy * (sinβ - κ * cosβ)));
                pt3 = matrix.Transform(new XPoint(x0 + δx * cosβ, y0 + δy * sinβ));
                AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
                  pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y);
            }
            else
            {
                switch (pathStart)
                {
                    case PathStart.MoveTo1st:
                        pt1 = matrix.Transform(new XPoint(x0 - δx * cosα, y0 - δy * sinα));
                        AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", pt1.X, pt1.Y);
                        break;

                    case PathStart.LineTo1st:
                        pt1 = matrix.Transform(new XPoint(x0 - δx * cosα, y0 - δy * sinα));
                        AppendFormatPoint("{0:" + format + "} {1:" + format + "} l\n", pt1.X, pt1.Y);
                        break;

                    case PathStart.Ignore1st:
                        break;
                }
                pt1 = matrix.Transform(new XPoint(x0 - δx * (cosα - κ * sinα), y0 - δy * (sinα + κ * cosα)));
                pt2 = matrix.Transform(new XPoint(x0 - δx * (cosβ + κ * sinβ), y0 - δy * (sinβ - κ * cosβ)));
                pt3 = matrix.Transform(new XPoint(x0 - δx * cosβ, y0 - δy * sinβ));
                AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
                    pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y);
            }
        }

        void AppendCurveSegment(XPoint pt0, XPoint pt1, XPoint pt2, XPoint pt3, double tension3)
        {
            const string format = Config.SignificantFigures4;
            AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n",
                pt1.X + tension3 * (pt2.X - pt0.X), pt1.Y + tension3 * (pt2.Y - pt0.Y),
                pt2.X - tension3 * (pt3.X - pt1.X), pt2.Y - tension3 * (pt3.Y - pt1.Y),
                pt2.X, pt2.Y);
        }



#if CORE
        internal void AppendPath(CoreGraphicsPath path)
        {
            AppendPath(path.PathPoints, path.PathTypes);
        }
#endif

#if CORE || GDI
        void AppendPath(XPoint[] points, Byte[] types)
        {
            const string format = Config.SignificantFigures4;
            int count = points.Length;
            if (count == 0)
                return;

            for (int idx = 0; idx < count; idx++)
            {
                const byte PathPointTypeStart = 0;  
                const byte PathPointTypeLine = 1;  
                const byte PathPointTypeBezier = 3;      
                const byte PathPointTypePathTypeMask = 0x07;      
                const byte PathPointTypeCloseSubpath = 0x80;   
                byte type = types[idx];
                switch (type & PathPointTypePathTypeMask)
                {
                    case PathPointTypeStart:
                        AppendFormatPoint("{0:" + format + "} {1:" + format + "} m\n", points[idx].X, points[idx].Y);
                        break;

                    case PathPointTypeLine:
                        AppendFormatPoint("{0:" + format + "} {1:" + format + "} l\n", points[idx].X, points[idx].Y);
                        if ((type & PathPointTypeCloseSubpath) != 0)
                            Append("h\n");
                        break;

                    case PathPointTypeBezier:
                        Debug.Assert(idx + 2 < count);
                        AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} c\n", points[idx].X, points[idx].Y,
                            points[++idx].X, points[idx].Y, points[++idx].X, points[idx].Y);
                        if ((types[idx] & PathPointTypeCloseSubpath) != 0)
                            Append("h\n");
                        break;
                }
            }
        }
#endif
        internal void Append(string value)
        {
            _content.Append(value);
        }

        internal void AppendFormatArgs(string format, params object[] args)
        {
            _content.AppendFormat(CultureInfo.InvariantCulture, format, args);
        }

        internal void AppendFormatString(string format, string s)
        {
            _content.AppendFormat(CultureInfo.InvariantCulture, format, s);
        }

        internal void AppendFormatFont(string format, string s, double d)
        {
            _content.AppendFormat(CultureInfo.InvariantCulture, format, s, d);
        }

        internal void AppendFormatInt(string format, int n)
        {
            _content.AppendFormat(CultureInfo.InvariantCulture, format, n);
        }

        internal void AppendFormatDouble(string format, double d)
        {
            _content.AppendFormat(CultureInfo.InvariantCulture, format, d);
        }

        internal void AppendFormatPoint(string format, double x, double y)
        {
            XPoint result = WorldToView(new XPoint(x, y));
            _content.AppendFormat(CultureInfo.InvariantCulture, format, result.X, result.Y);
        }

        internal void AppendFormatRect(string format, double x, double y, double width, double height)
        {
            XPoint point1 = WorldToView(new XPoint(x, y));
            _content.AppendFormat(CultureInfo.InvariantCulture, format, point1.X, point1.Y, width, height);
        }

        internal void AppendFormat3Points(string format, double x1, double y1, double x2, double y2, double x3, double y3)
        {
            XPoint point1 = WorldToView(new XPoint(x1, y1));
            XPoint point2 = WorldToView(new XPoint(x2, y2));
            XPoint point3 = WorldToView(new XPoint(x3, y3));
            _content.AppendFormat(CultureInfo.InvariantCulture, format, point1.X, point1.Y, point2.X, point2.Y, point3.X, point3.Y);
        }

        internal void AppendFormat(string format, XPoint point)
        {
            XPoint result = WorldToView(point);
            _content.AppendFormat(CultureInfo.InvariantCulture, format, result.X, result.Y);
        }

        internal void AppendFormat(string format, double x, double y, string s)
        {
            XPoint result = WorldToView(new XPoint(x, y));
            _content.AppendFormat(CultureInfo.InvariantCulture, format, result.X, result.Y, s);
        }

        internal void AppendFormatImage(string format, double x, double y, double width, double height, string name)
        {
            XPoint result = WorldToView(new XPoint(x, y));
            _content.AppendFormat(CultureInfo.InvariantCulture, format, result.X, result.Y, width, height, name);
        }

        void AppendStrokeFill(XPen pen, XBrush brush, XFillMode fillMode, bool closePath)
        {
            if (closePath)
                _content.Append("h ");

            if (fillMode == XFillMode.Winding)
            {
                if (pen != null && brush != null)
                    _content.Append("B\n");
                else if (pen != null)
                    _content.Append("S\n");
                else
                    _content.Append("f\n");
            }
            else
            {
                if (pen != null && brush != null)
                    _content.Append("B*\n");
                else if (pen != null)
                    _content.Append("S\n");
                else
                    _content.Append("f*\n");
            }
        }
        void BeginPage()
        {
            if (_gfxState.Level == GraphicsStackLevelInitial)
            {
                DefaultViewMatrix = new XMatrix();
                if (_gfx.PageDirection == XPageDirection.Downwards)
                {
                    PageHeightPt = Size.Height;
                    XPoint trimOffset = new XPoint();
                    if (_page != null && _page.TrimMargins.AreSet)
                    {
                        PageHeightPt += _page.TrimMargins.Top.Point + _page.TrimMargins.Bottom.Point;
                        trimOffset = new XPoint(_page.TrimMargins.Left.Point, _page.TrimMargins.Top.Point);
                    }

                    switch (_gfx.PageUnit)
                    {
                        case XGraphicsUnit.Point:
                            break;

                        case XGraphicsUnit.Presentation:
                            DefaultViewMatrix.ScalePrepend(XUnit.PresentationFactor);
                            break;

                        case XGraphicsUnit.Inch:
                            DefaultViewMatrix.ScalePrepend(XUnit.InchFactor);
                            break;

                        case XGraphicsUnit.Millimeter:
                            DefaultViewMatrix.ScalePrepend(XUnit.MillimeterFactor);
                            break;

                        case XGraphicsUnit.Centimeter:
                            DefaultViewMatrix.ScalePrepend(XUnit.CentimeterFactor);
                            break;
                    }

                    if (trimOffset != new XPoint())
                    {
                        Debug.Assert(_gfx.PageUnit == XGraphicsUnit.Point, "With TrimMargins set the page units must be Point. Ohter cases nyi.");
                        DefaultViewMatrix.TranslatePrepend(trimOffset.X, -trimOffset.Y);
                    }

                    SaveState();

                    if (!DefaultViewMatrix.IsIdentity)
                    {
                        Debug.Assert(_gfxState.RealizedCtm.IsIdentity);
                        const string format = Config.SignificantFigures7;
                        double[] cm = DefaultViewMatrix.GetElements();
                        AppendFormatArgs("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} cm ",
                                     cm[0], cm[1], cm[2], cm[3], cm[4], cm[5]);
                    }

                }
                else
                {
                    switch (_gfx.PageUnit)
                    {
                        case XGraphicsUnit.Point:
                            break;

                        case XGraphicsUnit.Presentation:
                            DefaultViewMatrix.ScalePrepend(XUnit.PresentationFactor);
                            break;

                        case XGraphicsUnit.Inch:
                            DefaultViewMatrix.ScalePrepend(XUnit.InchFactor);
                            break;

                        case XGraphicsUnit.Millimeter:
                            DefaultViewMatrix.ScalePrepend(XUnit.MillimeterFactor);
                            break;

                        case XGraphicsUnit.Centimeter:
                            DefaultViewMatrix.ScalePrepend(XUnit.CentimeterFactor);
                            break;
                    }

                    SaveState();
                    const string format = Config.SignificantFigures7;
                    double[] cm = DefaultViewMatrix.GetElements();
                    AppendFormat3Points("{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "} {4:" + format + "} {5:" + format + "} cm ",
                        cm[0], cm[1], cm[2], cm[3], cm[4], cm[5]);
                }
            }
        }

        void EndPage()
        {
            if (_streamMode == StreamMode.Text)
            {
                _content.Append("ET\n");
                _streamMode = StreamMode.Graphic;
            }

            while (_gfxStateStack.Count != 0)
                RestoreState();
        }

        internal void BeginGraphicMode()
        {
            if (_streamMode != StreamMode.Graphic)
            {
                if (_streamMode == StreamMode.Text)
                    _content.Append("ET\n");

                _streamMode = StreamMode.Graphic;
            }
        }

        internal void BeginTextMode()
        {
            if (_streamMode != StreamMode.Text)
            {
                _streamMode = StreamMode.Text;
                _content.Append("BT\n");
                _gfxState.RealizedTextPosition = new XPoint();
                _gfxState.ItalicSimulationOn = false;
            }
        }

        StreamMode _streamMode;

        private void Realize(XPen pen, XBrush brush)
        {
            BeginPage();
            BeginGraphicMode();
            RealizeTransform();

            if (pen != null)
                _gfxState.RealizePen(pen, _colorMode);

            if (brush != null)
            {
                _gfxState.RealizeBrush(brush, _colorMode, 0, 0);
            }
        }

        void Realize(XPen pen)
        {
            Realize(pen, null);
        }

        void Realize(XBrush brush)
        {
            Realize(null, brush);
        }

        void Realize(XFont font, XBrush brush, int renderingMode)
        {
            BeginPage();
            RealizeTransform();
            BeginTextMode();
            _gfxState.RealizeFont(font, brush, renderingMode);
        }

        void AdjustTdOffset(ref XPoint pos, double dy, bool adjustSkew)
        {
            pos.Y += dy;
            XPoint posSave = pos;
            pos = pos - new XVector(_gfxState.RealizedTextPosition.X, _gfxState.RealizedTextPosition.Y);
            if (adjustSkew)
            {
                pos.X -= Const.ItalicSkewAngleSinus * pos.Y;
            }
            _gfxState.RealizedTextPosition = posSave;
        }

        string Realize(XImage image)
        {
            BeginPage();
            BeginGraphicMode();
            RealizeTransform();

            _gfxState.RealizeNonStrokeTransparency(1, _colorMode);

            XForm form = image as XForm;
            return form != null ? GetFormName(form) : GetImageName(image);
        }

        void RealizeTransform()
        {
            BeginPage();

            if (_gfxState.Level == GraphicsStackLevelPageSpace)
            {
                BeginGraphicMode();
                SaveState();
            }

            if (!_gfxState.UnrealizedCtm.IsIdentity)
            {
                BeginGraphicMode();
                _gfxState.RealizeCtm();
            }
        }

        internal XPoint WorldToView(XPoint point)
        {
            Debug.Assert(_gfxState.UnrealizedCtm.IsIdentity, "Somewhere a RealizeTransform is missing.");
#if true
            XPoint pt = _gfxState.WorldTransform.Transform(point);
            return _gfxState.InverseEffectiveCtm.Transform(new XPoint(pt.X, PageHeightPt / DefaultViewMatrix.M22 - pt.Y));
#endif
        }

#if CORE || GDI
        [Conditional("DEBUG")]
        void DumpPathData(XPoint[] points, byte[] types)
        {
            int count = points.Length;
            for (int idx = 0; idx < count; idx++)
            {
                string info = PdfEncoders.Format("{0:X}   {1:####0.000} {2:####0.000}", types[idx], points[idx].X, points[idx].Y);
                Debug.WriteLine(info, "PathData");
            }
        }
#endif

        internal PdfDocument Owner
        {
            get
            {
                if (_page != null)
                    return _page.Owner;
                return _form.Owner;
            }
        }

        internal XGraphics Gfx
        {
            get { return _gfx; }
        }

        internal PdfResources Resources
        {
            get
            {
                if (_page != null)
                    return _page.Resources;
                return _form.Resources;
            }
        }

        internal XSize Size
        {
            get
            {
                if (_page != null)
                    return new XSize(_page.Width, _page.Height);
                return _form.Size;
            }
        }

        internal string GetFontName(XFont font, out PdfFont pdfFont)
        {
            if (_page != null)
                return _page.GetFontName(font, out pdfFont);
            return _form.GetFontName(font, out pdfFont);
        }

        internal string GetImageName(XImage image)
        {
            if (_page != null)
                return _page.GetImageName(image);
            return _form.GetImageName(image);
        }

        internal string GetFormName(XForm form)
        {
            if (_page != null)
                return _page.GetFormName(form);
            return _form.GetFormName(form);
        }

        internal PdfPage _page;
        internal XForm _form;
        internal PdfColorMode _colorMode;
        XGraphicsPdfPageOptions _options;
        XGraphics _gfx;
        readonly StringBuilder _content;

        const int GraphicsStackLevelInitial = 0;

        const int GraphicsStackLevelPageSpace = 1;

        const int GraphicsStackLevelWorldSpace = 2;

        void SaveState()
        {
            Debug.Assert(_streamMode == StreamMode.Graphic, "Cannot save state in text mode.");

            _gfxStateStack.Push(_gfxState);
            _gfxState = _gfxState.Clone();
            _gfxState.Level = _gfxStateStack.Count;
            Append("q\n");
        }

        void RestoreState()
        {
            Debug.Assert(_streamMode == StreamMode.Graphic, "Cannot restore state in text mode.");

            _gfxState = _gfxStateStack.Pop();
            Append("Q\n");
        }

        PdfGraphicsState RestoreState(InternalGraphicsState state)
        {
            int count = 1;
            PdfGraphicsState top = _gfxStateStack.Pop();
            while (top.InternalState != state)
            {
                Append("Q\n");
                count++;
                top = _gfxStateStack.Pop();
            }
            Append("Q\n");
            _gfxState = top;
            return top;
        }

        PdfGraphicsState _gfxState;

        readonly Stack<PdfGraphicsState> _gfxStateStack = new Stack<PdfGraphicsState>();

        public double PageHeightPt;

        public XMatrix DefaultViewMatrix;
    }
    internal class CMapInfo
    {
        public CMapInfo(OpenTypeDescriptor descriptor)
        {
            Debug.Assert(descriptor != null);
            _descriptor = descriptor;
        }
        internal OpenTypeDescriptor _descriptor;

        public void AddChars(string text)
        {
            if (text != null)
            {
                bool symbol = _descriptor.FontFace.cmap.symbol;
                int length = text.Length;
                for (int idx = 0; idx < length; idx++)
                {
                    char ch = text[idx];
                    if (!CharacterToGlyphIndex.ContainsKey(ch))
                    {
                        char ch2 = ch;
                        if (symbol)
                        {
                            ch2 = (char)(ch | (_descriptor.FontFace.os2.usFirstCharIndex & 0xFF00));
                        }
                        int glyphIndex = _descriptor.CharCodeToGlyphIndex(ch2);
                        CharacterToGlyphIndex.Add(ch, glyphIndex);
                        GlyphIndices[glyphIndex] = null;
                        MinChar = (char)Math.Min(MinChar, ch);
                        MaxChar = (char)Math.Max(MaxChar, ch);
                    }
                }
            }
        }

        public void AddGlyphIndices(string glyphIndices)
        {
            if (glyphIndices != null)
            {
                int length = glyphIndices.Length;
                for (int idx = 0; idx < length; idx++)
                {
                    int glyphIndex = glyphIndices[idx];
                    GlyphIndices[glyphIndex] = null;
                }
            }
        }

        internal void AddAnsiChars()
        {
            byte[] ansi = new byte[256 - 32];
            for (int idx = 0; idx < 256 - 32; idx++)
                ansi[idx] = (byte)(idx + 32);
#if EDF_CORE
            string text = null; // PdfEncoders.WinAnsiEncoding.GetString(ansi, 0, ansi.Length);
#else
            string text = PdfEncoders.WinAnsiEncoding.GetString(ansi, 0, ansi.Length);
#endif
            AddChars(text);
        }

        internal bool Contains(char ch)
        {
            return CharacterToGlyphIndex.ContainsKey(ch);
        }

        public char[] Chars
        {
            get
            {
                char[] chars = new char[CharacterToGlyphIndex.Count];
                CharacterToGlyphIndex.Keys.CopyTo(chars, 0);
                Array.Sort(chars);
                return chars;
            }
        }

        public int[] GetGlyphIndices()
        {
            int[] indices = new int[GlyphIndices.Count];
            GlyphIndices.Keys.CopyTo(indices, 0);
            Array.Sort(indices);
            return indices;
        }

        public char MinChar = char.MaxValue;
        public char MaxChar = char.MinValue;
        public Dictionary<char, int> CharacterToGlyphIndex = new Dictionary<char, int>();
        public Dictionary<int, object> GlyphIndices = new Dictionary<int, object>();
    }
    internal sealed class FontDescriptorCache
    {
        FontDescriptorCache()
        {
            _cache = new Dictionary<string, FontDescriptor>();
        }

        public static FontDescriptor GetOrCreateDescriptorFor(XFont font)
        {
            if (font == null)
                throw new ArgumentNullException("font");

            string fontDescriptorKey = FontDescriptor.ComputeKey(font);
            try
            {
                Lock.EnterFontFactory();
                FontDescriptor descriptor;
                if (!Singleton._cache.TryGetValue(fontDescriptorKey, out descriptor))
                {
                    descriptor = new OpenTypeDescriptor(fontDescriptorKey, font);
                    Singleton._cache.Add(fontDescriptorKey, descriptor);
                }
                return descriptor;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static FontDescriptor GetOrCreateDescriptor(string fontFamilyName, XFontStyle style)
        {
            if (string.IsNullOrEmpty(fontFamilyName))
                throw new ArgumentNullException("fontFamilyName");

            string fontDescriptorKey = FontDescriptor.ComputeKey(fontFamilyName, style);
            try
            {
                Lock.EnterFontFactory();
                FontDescriptor descriptor;
                if (!Singleton._cache.TryGetValue(fontDescriptorKey, out descriptor))
                {
                    XFont font = new XFont(fontFamilyName, 10, style);
                    descriptor = GetOrCreateDescriptorFor(font);
                    if (Singleton._cache.ContainsKey(fontDescriptorKey))
                        Singleton.GetType();
                    else
                        Singleton._cache.Add(fontDescriptorKey, descriptor);
                }
                return descriptor;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static FontDescriptor GetOrCreateDescriptor(string idName, byte[] fontData)
        {
            string fontDescriptorKey = FontDescriptor.ComputeKey(idName);
            try
            {
                Lock.EnterFontFactory();
                FontDescriptor descriptor;
                if (!Singleton._cache.TryGetValue(fontDescriptorKey, out descriptor))
                {
                    descriptor = GetOrCreateOpenTypeDescriptor(fontDescriptorKey, idName, fontData);
                    Singleton._cache.Add(fontDescriptorKey, descriptor);
                }
                return descriptor;
            }
            finally { Lock.ExitFontFactory(); }
        }

        static OpenTypeDescriptor GetOrCreateOpenTypeDescriptor(string fontDescriptorKey, string idName, byte[] fontData)
        {
            return new OpenTypeDescriptor(fontDescriptorKey, idName, fontData);
        }

        static FontDescriptorCache Singleton
        {
            get
            {
                if (_singleton == null)
                {
                    try
                    {
                        Lock.EnterFontFactory();
                        if (_singleton == null)
                            _singleton = new FontDescriptorCache();
                    }
                    finally { Lock.ExitFontFactory(); }
                }
                return _singleton;
            }
        }
        static volatile FontDescriptorCache _singleton;

        readonly Dictionary<string, FontDescriptor> _cache;
    }
    internal static class FontFactory
    {
        public static FontResolverInfo ResolveTypeface(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey)
        {
            if (string.IsNullOrEmpty(typefaceKey))
                typefaceKey = XGlyphTypeface.ComputeKey(familyName, fontResolvingOptions);

            try
            {
                Lock.EnterFontFactory();
                FontResolverInfo fontResolverInfo;
                if (FontResolverInfosByName.TryGetValue(typefaceKey, out fontResolverInfo))
                    return fontResolverInfo;

                IFontResolver customFontResolver = GlobalFontSettings.FontResolver;
                if (customFontResolver != null)
                {
                    fontResolverInfo = customFontResolver.ResolveTypeface(familyName, fontResolvingOptions.IsBold, fontResolvingOptions.IsItalic);

                    if (fontResolverInfo != null && !(fontResolverInfo is PlatformFontResolverInfo))
                    {
                        if (fontResolvingOptions.OverrideStyleSimulations)
                        {
                            fontResolverInfo = new FontResolverInfo(fontResolverInfo.FaceName, fontResolvingOptions.MustSimulateBold, fontResolvingOptions.MustSimulateItalic, fontResolverInfo.CollectionNumber);
                        }

                        string resolverInfoKey = fontResolverInfo.Key;
                        FontResolverInfo existingFontResolverInfo;
                        if (FontResolverInfosByName.TryGetValue(resolverInfoKey, out existingFontResolverInfo))
                        {
                            fontResolverInfo = existingFontResolverInfo;
                            FontResolverInfosByName.Add(typefaceKey, fontResolverInfo);
                        }
                        else
                        {
                            FontResolverInfosByName.Add(typefaceKey, fontResolverInfo);
                            Debug.Assert(resolverInfoKey == fontResolverInfo.Key);
                            FontResolverInfosByName.Add(resolverInfoKey, fontResolverInfo);

                            XFontSource previousFontSource;
                            if (FontSourcesByName.TryGetValue(fontResolverInfo.FaceName, out previousFontSource))
                            {
                            }
                            else
                            {
                                byte[] bytes = customFontResolver.GetFont(fontResolverInfo.FaceName);
                                XFontSource fontSource = XFontSource.GetOrCreateFrom(bytes);

                                if (string.Compare(fontResolverInfo.FaceName, fontSource.FontName, StringComparison.OrdinalIgnoreCase) != 0)
                                    FontSourcesByName.Add(fontResolverInfo.FaceName, fontSource);
                            }
                        }
                    }
                }
                else
                {
                    fontResolverInfo = PlatformFontResolver.ResolveTypeface(familyName, fontResolvingOptions, typefaceKey);
                }

                return fontResolverInfo;
            }
            finally { Lock.ExitFontFactory(); }
        }


        public static XFontSource GetFontSourceByFontName(string fontName)
        {
            XFontSource fontSource;
            if (FontSourcesByName.TryGetValue(fontName, out fontSource))
                return fontSource;

            Debug.Assert(false, string.Format("An XFontSource with the name '{0}' does not exists.", fontName));
            return null;
        }

        public static XFontSource GetFontSourceByTypefaceKey(string typefaceKey)
        {
            XFontSource fontSource;
            if (FontSourcesByName.TryGetValue(typefaceKey, out fontSource))
                return fontSource;

            Debug.Assert(false, string.Format("An XFontSource with the typeface key '{0}' does not exists.", typefaceKey));
            return null;
        }

        public static bool TryGetFontSourceByKey(ulong key, out XFontSource fontSource)
        {
            return FontSourcesByKey.TryGetValue(key, out fontSource);
        }

        public static bool HasFontSources
        {
            get { return FontSourcesByName.Count > 0; }
        }

        public static bool TryGetFontResolverInfoByTypefaceKey(string typeFaceKey, out FontResolverInfo info)
        {
            return FontResolverInfosByName.TryGetValue(typeFaceKey, out info);
        }

        public static bool TryGetFontSourceByTypefaceKey(string typefaceKey, out XFontSource source)
        {
            return FontSourcesByName.TryGetValue(typefaceKey, out source);
        }

        internal static void CacheFontResolverInfo(string typefaceKey, FontResolverInfo fontResolverInfo)
        {
            FontResolverInfo existingfFontResolverInfo;
            if (FontResolverInfosByName.TryGetValue(typefaceKey, out existingfFontResolverInfo))
            {
                throw new InvalidOperationException(string.Format("A font file with different content already exists with the specified face name '{0}'.", typefaceKey));
            }
            if (FontResolverInfosByName.TryGetValue(fontResolverInfo.Key, out existingfFontResolverInfo))
            {
                throw new InvalidOperationException(string.Format("A font resolver already exists with the specified key '{0}'.", fontResolverInfo.Key));
            }
            FontResolverInfosByName.Add(typefaceKey, fontResolverInfo);
            FontResolverInfosByName.Add(fontResolverInfo.Key, fontResolverInfo);
        }

        public static XFontSource CacheFontSource(XFontSource fontSource)
        {
            try
            {
                Lock.EnterFontFactory();
                XFontSource existingFontSource;
                if (FontSourcesByKey.TryGetValue(fontSource.Key, out existingFontSource))
                {
                    return existingFontSource;

                }

                OpenTypeFontface fontface = fontSource.Fontface;
                if (fontface == null)
                {
                    fontSource.Fontface = new OpenTypeFontface(fontSource);
                }
                FontSourcesByKey.Add(fontSource.Key, fontSource);
                FontSourcesByName.Add(fontSource.FontName, fontSource);
                return fontSource;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static XFontSource CacheNewFontSource(string typefaceKey, XFontSource fontSource)
        {
            XFontSource existingFontSource;
            if (FontSourcesByKey.TryGetValue(fontSource.Key, out existingFontSource))
            {
                return existingFontSource;

            }

            OpenTypeFontface fontface = fontSource.Fontface;
            if (fontface == null)
            {
                fontface = new OpenTypeFontface(fontSource);
                fontSource.Fontface = fontface;
            }

            FontSourcesByName.Add(typefaceKey, fontSource);
            FontSourcesByName.Add(fontSource.FontName, fontSource);
            FontSourcesByKey.Add(fontSource.Key, fontSource);

            return fontSource;
        }

        public static void CacheExistingFontSourceWithNewTypefaceKey(string typefaceKey, XFontSource fontSource)
        {
            try
            {
                Lock.EnterFontFactory();
                FontSourcesByName.Add(typefaceKey, fontSource);
            }
            finally { Lock.ExitFontFactory(); }
        }

        internal static string GetFontCachesState()
        {
            StringBuilder state = new StringBuilder();
            string[] keys;
            int count;

            state.Append("====================\n");
            state.Append("Font resolver info by name\n");
            Dictionary<string, FontResolverInfo>.KeyCollection keyCollection = FontResolverInfosByName.Keys;
            count = keyCollection.Count;
            keys = new string[count];
            keyCollection.CopyTo(keys, 0);
            Array.Sort(keys, StringComparer.OrdinalIgnoreCase);
            foreach (string key in keys)
                state.AppendFormat("  {0}: {1}\n", key, FontResolverInfosByName[key].DebuggerDisplay);
            state.Append("\n");

            state.Append("Font source by key and name\n");
            Dictionary<ulong, XFontSource>.KeyCollection fontSourceKeys = FontSourcesByKey.Keys;
            count = fontSourceKeys.Count;
            ulong[] ulKeys = new ulong[count];
            fontSourceKeys.CopyTo(ulKeys, 0);
            Array.Sort(ulKeys, delegate (ulong x, ulong y) { return x == y ? 0 : (x > y ? 1 : -1); });
            foreach (ulong ul in ulKeys)
                state.AppendFormat("  {0}: {1}\n", ul, FontSourcesByKey[ul].DebuggerDisplay);
            Dictionary<string, XFontSource>.KeyCollection fontSourceNames = FontSourcesByName.Keys;
            count = fontSourceNames.Count;
            keys = new string[count];
            fontSourceNames.CopyTo(keys, 0);
            Array.Sort(keys, StringComparer.OrdinalIgnoreCase);
            foreach (string key in keys)
                state.AppendFormat("  {0}: {1}\n", key, FontSourcesByName[key].DebuggerDisplay);
            state.Append("--------------------\n\n");

            state.Append(FontFamilyCache.GetCacheState());
            state.Append(GlyphTypefaceCache.GetCacheState());
            state.Append(OpenTypeFontfaceCache.GetCacheState());
            return state.ToString();
        }

        static readonly Dictionary<string, FontResolverInfo> FontResolverInfosByName = new Dictionary<string, FontResolverInfo>(StringComparer.OrdinalIgnoreCase);

        static readonly Dictionary<string, XFontSource> FontSourcesByName = new Dictionary<string, XFontSource>(StringComparer.OrdinalIgnoreCase);

        static readonly Dictionary<ulong, XFontSource> FontSourcesByKey = new Dictionary<ulong, XFontSource>();
    }
    public class FontResolverInfo
    {
        private const string KeyPrefix = "frik:";

        public FontResolverInfo(string faceName) :
            this(faceName, false, false, 0)
        { }

        internal FontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic, int collectionNumber)
        {
            if (String.IsNullOrEmpty(faceName))
                throw new ArgumentNullException("faceName");
            if (collectionNumber != 0)
                throw new NotImplementedException("collectionNumber is not yet implemented and must be 0.");

            _faceName = faceName;
            _mustSimulateBold = mustSimulateBold;
            _mustSimulateItalic = mustSimulateItalic;
            _collectionNumber = collectionNumber;
        }

        public FontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic)
            : this(faceName, mustSimulateBold, mustSimulateItalic, 0)
        { }

        public FontResolverInfo(string faceName, XStyleSimulations styleSimulations)
            : this(faceName,
                  (styleSimulations & XStyleSimulations.BoldSimulation) == XStyleSimulations.BoldSimulation,
                  (styleSimulations & XStyleSimulations.ItalicSimulation) == XStyleSimulations.ItalicSimulation, 0)
        { }

        internal string Key
        {
            get
            {
                return _key ?? (_key = KeyPrefix + _faceName.ToLowerInvariant()
                                       + '/' + (_mustSimulateBold ? "b+" : "b-") + (_mustSimulateItalic ? "i+" : "i-"));
            }
        }
        string _key;

        public string FaceName
        {
            get { return _faceName; }
        }
        readonly string _faceName;

        public bool MustSimulateBold
        {
            get { return _mustSimulateBold; }
        }
        readonly bool _mustSimulateBold;

        public bool MustSimulateItalic
        {
            get { return _mustSimulateItalic; }
        }
        readonly bool _mustSimulateItalic;

        public XStyleSimulations StyleSimulations
        {
            get { return (_mustSimulateBold ? XStyleSimulations.BoldSimulation : 0) | (_mustSimulateItalic ? XStyleSimulations.ItalicSimulation : 0); }
        }

        internal int CollectionNumber
        {
            get { return _collectionNumber; }
        }
        readonly int _collectionNumber;

        internal string DebuggerDisplay
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, "FontResolverInfo: '{0}',{1}{2}", FaceName,
                    MustSimulateBold ? " simulate Bold" : "",
                    MustSimulateItalic ? " simulate Italic" : "");
            }
        }
    }
    class FontResolvingOptions
    {
        public FontResolvingOptions(XFontStyle fontStyle)
        {
            FontStyle = fontStyle;
        }

        public FontResolvingOptions(XFontStyle fontStyle, XStyleSimulations styleSimulations)
        {
            FontStyle = fontStyle;
            OverrideStyleSimulations = true;
            StyleSimulations = styleSimulations;
        }

        public bool IsBold
        {
            get { return (FontStyle & XFontStyle.Bold) == XFontStyle.Bold; }
        }

        public bool IsItalic
        {
            get { return (FontStyle & XFontStyle.Italic) == XFontStyle.Italic; }
        }

        public bool IsBoldItalic
        {
            get { return (FontStyle & XFontStyle.BoldItalic) == XFontStyle.BoldItalic; }
        }

        public bool MustSimulateBold
        {
            get { return (StyleSimulations & XStyleSimulations.BoldSimulation) == XStyleSimulations.BoldSimulation; }
        }

        public bool MustSimulateItalic
        {
            get { return (StyleSimulations & XStyleSimulations.ItalicSimulation) == XStyleSimulations.ItalicSimulation; }
        }

        public XFontStyle FontStyle;

        public bool OverrideStyleSimulations;

        public XStyleSimulations StyleSimulations;
    }
    internal class FontWriter
    {
        public FontWriter(Stream stream)
        {
            _stream = stream;
        }

        public void Close(bool closeUnderlyingStream)
        {
            if (_stream != null && closeUnderlyingStream)
            {
#if !UWP
                _stream.Close();
#endif
                _stream.Dispose();
            }
            _stream = null;
        }

        public void Close()
        {
            Close(true);
        }

        public int Position
        {
            get { return (int)_stream.Position; }
            set { _stream.Position = value; }
        }

        public void WriteByte(byte value)
        {
            _stream.WriteByte(value);
        }

        public void WriteByte(int value)
        {
            _stream.WriteByte((byte)value);
        }

        public void WriteShort(short value)
        {
            _stream.WriteByte((byte)(value >> 8));
            _stream.WriteByte((byte)value);
        }

        public void WriteShort(int value)
        {
            WriteShort((short)value);
        }

        public void WriteUShort(ushort value)
        {
            _stream.WriteByte((byte)(value >> 8));
            _stream.WriteByte((byte)value);
        }

        public void WriteUShort(int value)
        {
            WriteUShort((ushort)value);
        }

        public void WriteInt(int value)
        {
            _stream.WriteByte((byte)(value >> 24));
            _stream.WriteByte((byte)(value >> 16));
            _stream.WriteByte((byte)(value >> 8));
            _stream.WriteByte((byte)value);
        }

        public void WriteUInt(uint value)
        {
            _stream.WriteByte((byte)(value >> 24));
            _stream.WriteByte((byte)(value >> 16));
            _stream.WriteByte((byte)(value >> 8));
            _stream.WriteByte((byte)value);
        }

        public void Write(byte[] buffer)
        {
            _stream.Write(buffer, 0, buffer.Length);
        }

        public void Write(byte[] buffer, int offset, int count)
        {
            _stream.Write(buffer, offset, count);
        }

        internal Stream Stream
        {
            get { return _stream; }
        }
        Stream _stream;
    }
    public static class GlobalFontSettings
    {
        public const string DefaultFontName = "PlatformDefault";

        public static IFontResolver FontResolver
        {
            get { return _fontResolver; }
            set
            {
                if (value == null)
                    throw new ArgumentNullException();

                try
                {
                    Lock.EnterFontFactory();
                    if (ReferenceEquals(_fontResolver, value))
                        return;

                    if (FontFactory.HasFontSources)
                        throw new InvalidOperationException("Must not change font resolver after is was once used.");

                    _fontResolver = value;
                }
                finally { Lock.ExitFontFactory(); }
            }
        }
        static IFontResolver _fontResolver;

        public static PdfFontEncoding DefaultFontEncoding
        {
            get
            {
                if (!_fontEncodingInitialized)
                    DefaultFontEncoding = PdfFontEncoding.Unicode;
                return _fontEncoding;
            }
            set
            {
                try
                {
                    Lock.EnterFontFactory();
                    if (_fontEncodingInitialized)
                    {
                        if (_fontEncoding == value)
                            return;
                        throw new InvalidOperationException("Must not change DefaultFontEncoding after is was set once.");
                    }

                    _fontEncoding = value;
                    _fontEncodingInitialized = true;
                }
                finally { Lock.ExitFontFactory(); }
            }
        }
        static PdfFontEncoding _fontEncoding;
        static bool _fontEncodingInitialized;
    }
    public interface IFontResolver
    {
        FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic);

        byte[] GetFont(string faceName);
    }
    public static class PlatformFontResolver
    {
        public static FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic)
        {
            FontResolvingOptions fontResolvingOptions = new FontResolvingOptions(FontHelper.CreateStyle(isBold, isItalic));
            return ResolveTypeface(familyName, fontResolvingOptions, XGlyphTypeface.ComputeKey(familyName, fontResolvingOptions));
        }

        internal static FontResolverInfo ResolveTypeface(string familyName, FontResolvingOptions fontResolvingOptions, string typefaceKey)
        {
            if (string.IsNullOrEmpty(typefaceKey))
                typefaceKey = XGlyphTypeface.ComputeKey(familyName, fontResolvingOptions);

            FontResolverInfo fontResolverInfo;
            if (FontFactory.TryGetFontResolverInfoByTypefaceKey(typefaceKey, out fontResolverInfo))
                return fontResolverInfo;

#if (CORE || GDI) && !WPF
            GdiFont gdiFont;
            XFontSource fontSource = CreateFontSource(familyName, fontResolvingOptions, out gdiFont, typefaceKey);
#endif

            if (fontSource == null)
                return null;

            if (fontResolvingOptions.OverrideStyleSimulations)
            {
#if (CORE || GDI) && !WPF
                fontResolverInfo = new PlatformFontResolverInfo(typefaceKey, fontResolvingOptions.MustSimulateBold, fontResolvingOptions.MustSimulateItalic, gdiFont);
#endif
            }
            else
            {
#if (CORE || GDI) && !WPF
                bool mustSimulateBold = gdiFont.Bold && !fontSource.Fontface.os2.IsBold;
                bool mustSimulateItalic = gdiFont.Italic && !fontSource.Fontface.os2.IsItalic;
                fontResolverInfo = new PlatformFontResolverInfo(typefaceKey, mustSimulateBold, mustSimulateItalic, gdiFont);
#endif
            }

            FontFactory.CacheFontResolverInfo(typefaceKey, fontResolverInfo);

            return fontResolverInfo;
        }

#if (CORE_WITH_GDI || GDI) && !WPF
        internal static XFontSource CreateFontSource(string familyName, FontResolvingOptions fontResolvingOptions, out GdiFont font, string typefaceKey)
        {
            if (string.IsNullOrEmpty(typefaceKey))
                typefaceKey = XGlyphTypeface.ComputeKey(familyName, fontResolvingOptions);
            GdiFontStyle gdiStyle = (GdiFontStyle)(fontResolvingOptions.FontStyle & XFontStyle.BoldItalic);

            XFontSource fontSource;
            font = FontHelper.CreateFont(familyName, 10, gdiStyle, out fontSource);

            if (fontSource != null)
            {
                Debug.Assert(font != null);
            }
            else
            {
                fontSource = XFontSource.GetOrCreateFromGdi(typefaceKey, font);
            }
            return fontSource;
        }
#endif

    }
    internal class PlatformFontResolverInfo : FontResolverInfo
    {
#if CORE || GDI
        public PlatformFontResolverInfo(string faceName, bool mustSimulateBold, bool mustSimulateItalic, GdiFont gdiFont)
            : base(faceName, mustSimulateBold, mustSimulateItalic)
        {
            _gdiFont = gdiFont;
        }
#endif

#if CORE || GDI
        public Font GdiFont
        {
            get { return _gdiFont; }
        }
        readonly Font _gdiFont;
#endif
    }
    enum FontTechnology
    {
        PostscriptOutlines,

        TrueTypeOutlines,

        TrueTypeCollection
    }
    static class TableTagNames
    {
        public const string CMap = "cmap";

        public const string Head = "head";

        public const string HHea = "hhea";

        public const string HMtx = "hmtx";

        public const string MaxP = "maxp";

        public const string Name = "name";

        public const string OS2 = "OS/2";

        public const string Post = "post";

        public const string Cvt = "cvt ";

        public const string Fpgm = "fpgm";

        public const string Glyf = "glyf";

        public const string Loca = "loca";

        public const string Prep = "prep";

        public const string Cff = "CFF";

        public const string VOrg = "VORG";

        public const string EBDT = "EBDT";

        public const string EBLC = "EBLC";

        public const string EBSC = "EBSC";

        public const string BASE = "BASE";

        public const string GDEF = "GDEF";

        public const string GPOS = "GPOS";

        public const string GSUB = "GSUB";

        public const string JSTF = "JSTF";

        public const string DSIG = "DSIG";

        public const string Gasp = "gasp";

        public const string Hdmx = "hdmx";

        public const string Kern = "kern";

        public const string LTSH = "LTSH";

        public const string PCLT = "PCLT";

        public const string VDMX = "VDMX";

        public const string VHea = "vhea";

        public const string VMtx = "vmtx";
    }
    internal class FontDescriptor
    {
        protected FontDescriptor(string key)
        {
            _key = key;
        }

        public string Key
        {
            get { return _key; }
        }
        readonly string _key;







        public string FontName
        {
            get { return _fontName; }
            protected set { _fontName = value; }
        }
        string _fontName;

        public string Weight
        {
            get { return _weight; }
            private set { _weight = value; }
        }
        string _weight;

        public virtual bool IsBoldFace
        {
            get { return false; }
        }

        public float ItalicAngle
        {
            get { return _italicAngle; }
            protected set { _italicAngle = value; }
        }
        float _italicAngle;

        public virtual bool IsItalicFace
        {
            get { return false; }
        }

        public int XMin
        {
            get { return _xMin; }
            protected set { _xMin = value; }
        }
        int _xMin;

        public int YMin
        {
            get { return _yMin; }
            protected set { _yMin = value; }
        }
        int _yMin;

        public int XMax
        {
            get { return _xMax; }
            protected set { _xMax = value; }
        }
        int _xMax;

        public int YMax
        {
            get { return _yMax; }
            protected set { _yMax = value; }
        }
        int _yMax;

        public bool IsFixedPitch
        {
            get { return _isFixedPitch; }
            private set { _isFixedPitch = value; }
        }
        bool _isFixedPitch;

        public int UnderlinePosition
        {
            get { return _underlinePosition; }
            protected set { _underlinePosition = value; }
        }
        int _underlinePosition;

        public int UnderlineThickness
        {
            get { return _underlineThickness; }
            protected set { _underlineThickness = value; }
        }
        int _underlineThickness;

        public int StrikeoutPosition
        {
            get { return _strikeoutPosition; }
            protected set { _strikeoutPosition = value; }
        }
        int _strikeoutPosition;

        public int StrikeoutSize
        {
            get { return _strikeoutSize; }
            protected set { _strikeoutSize = value; }
        }
        int _strikeoutSize;

        public string Version
        {
            get { return _version; }
            private set { _version = value; }
        }
        string _version;

        public string EncodingScheme
        {
            get { return _encodingScheme; }
            private set { _encodingScheme = value; }
        }
        string _encodingScheme;

        public int UnitsPerEm
        {
            get { return _unitsPerEm; }
            protected set { _unitsPerEm = value; }
        }
        int _unitsPerEm;

        public int CapHeight
        {
            get { return _capHeight; }
            protected set { _capHeight = value; }
        }
        int _capHeight;

        public int XHeight
        {
            get { return _xHeight; }
            protected set { _xHeight = value; }
        }
        int _xHeight;

        public int Ascender
        {
            get { return _ascender; }
            protected set { _ascender = value; }
        }
        int _ascender;

        public int Descender
        {
            get { return _descender; }
            protected set { _descender = value; }
        }
        int _descender;

        public int Leading
        {
            get { return _leading; }
            protected set { _leading = value; }
        }
        int _leading;

        public int Flags
        {
            get { return _flags; }
            private set { _flags = value; }
        }
        int _flags;

        public int StemV
        {
            get { return _stemV; }
            protected set { _stemV = value; }
        }
        int _stemV;

        public int LineSpacing
        {
            get { return _lineSpacing; }
            protected set { _lineSpacing = value; }
        }
        int _lineSpacing;


        internal static string ComputeKey(XFont font)
        {
            return font.GlyphTypeface.Key;
        }

        internal static string ComputeKey(string name, XFontStyle style)
        {
            return ComputeKey(name,
                (style & XFontStyle.Bold) == XFontStyle.Bold,
                (style & XFontStyle.Italic) == XFontStyle.Italic);
        }

        internal static string ComputeKey(string name, bool isBold, bool isItalic)
        {
            string key = name.ToLowerInvariant() + '/'
                + (isBold ? "b" : "") + (isItalic ? "i" : "");
            return key;
        }

        internal static string ComputeKey(string name)
        {
            string key = name.ToLowerInvariant();
            return key;
        }
    }
    internal class GlyphDataTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Glyf;

        internal byte[] GlyphTable;

        public GlyphDataTable()
            : base(null, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.Glyf;
        }

        public GlyphDataTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.Glyf;
            Read();
        }

        public void Read()
        {
            try
            {
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        public byte[] GetGlyphData(int glyph)
        {
            IndexToLocationTable loca = _fontData.loca;
            int start = GetOffset(glyph);
            int next = GetOffset(glyph + 1);
            int count = next - start;
            byte[] bytes = new byte[count];
            Buffer.BlockCopy(_fontData.FontSource.Bytes, start, bytes, 0, count);
            return bytes;
        }

        public int GetGlyphSize(int glyph)
        {
            IndexToLocationTable loca = _fontData.loca;
            return GetOffset(glyph + 1) - GetOffset(glyph);
        }

        public int GetOffset(int glyph)
        {
            return DirectoryEntry.Offset + _fontData.loca.LocaTable[glyph];
        }

        public void CompleteGlyphClosure(Dictionary<int, object> glyphs)
        {
            int count = glyphs.Count;
            int[] glyphArray = new int[glyphs.Count];
            glyphs.Keys.CopyTo(glyphArray, 0);
            if (!glyphs.ContainsKey(0))
                glyphs.Add(0, null);
            for (int idx = 0; idx < count; idx++)
                AddCompositeGlyphs(glyphs, glyphArray[idx]);
        }

        void AddCompositeGlyphs(Dictionary<int, object> glyphs, int glyph)
        {
            int start = GetOffset(glyph);
            if (start == GetOffset(glyph + 1))
                return;
            _fontData.Position = start;
            int numContours = _fontData.ReadShort();
            if (numContours >= 0)
                return;
            _fontData.SeekOffset(8);
            for (; ; )
            {
                int flags = _fontData.ReadUFWord();
                int cGlyph = _fontData.ReadUFWord();
                if (!glyphs.ContainsKey(cGlyph))
                    glyphs.Add(cGlyph, null);
                if ((flags & MORE_COMPONENTS) == 0)
                    return;
                int offset = (flags & ARG_1_AND_2_ARE_WORDS) == 0 ? 2 : 4;
                if ((flags & WE_HAVE_A_SCALE) != 0)
                    offset += 2;
                else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)
                    offset += 4;
                if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)
                    offset += 8;
                _fontData.SeekOffset(offset);
            }
        }

        public override void PrepareForCompilation()
        {
            base.PrepareForCompilation();

            if (DirectoryEntry.Length == 0)
                DirectoryEntry.Length = GlyphTable.Length;
            DirectoryEntry.CheckSum = CalcChecksum(GlyphTable);
        }

        public override void Write(OpenTypeFontWriter writer)
        {
            writer.Write(GlyphTable, 0, DirectoryEntry.PaddedLength);
        }

        const int ARG_1_AND_2_ARE_WORDS = 1;
        const int WE_HAVE_A_SCALE = 8;
        const int MORE_COMPONENTS = 32;
        const int WE_HAVE_AN_X_AND_Y_SCALE = 64;
        const int WE_HAVE_A_TWO_BY_TWO = 128;
    }
    internal class GlyphTypefaceCache
    {
        GlyphTypefaceCache()
        {
            _glyphTypefacesByKey = new Dictionary<string, XGlyphTypeface>();
        }

        public static bool TryGetGlyphTypeface(string key, out XGlyphTypeface glyphTypeface)
        {
            try
            {
                Lock.EnterFontFactory();
                bool result = Singleton._glyphTypefacesByKey.TryGetValue(key, out glyphTypeface);
                return result;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static void AddGlyphTypeface(XGlyphTypeface glyphTypeface)
        {
            try
            {
                Lock.EnterFontFactory();
                GlyphTypefaceCache cache = Singleton;
                Debug.Assert(!cache._glyphTypefacesByKey.ContainsKey(glyphTypeface.Key));
                cache._glyphTypefacesByKey.Add(glyphTypeface.Key, glyphTypeface);
            }
            finally { Lock.ExitFontFactory(); }
        }

        static GlyphTypefaceCache Singleton
        {
            get
            {
                if (_singleton == null)
                {
                    try
                    {
                        Lock.EnterFontFactory();
                        if (_singleton == null)
                            _singleton = new GlyphTypefaceCache();
                    }
                    finally { Lock.ExitFontFactory(); }
                }
                return _singleton;
            }
        }
        static volatile GlyphTypefaceCache _singleton;

        internal static string GetCacheState()
        {
            StringBuilder state = new StringBuilder();
            state.Append("====================\n");
            state.Append("Glyph typefaces by name\n");
            Dictionary<string, XGlyphTypeface>.KeyCollection familyKeys = Singleton._glyphTypefacesByKey.Keys;
            int count = familyKeys.Count;
            string[] keys = new string[count];
            familyKeys.CopyTo(keys, 0);
            Array.Sort(keys, StringComparer.OrdinalIgnoreCase);
            foreach (string key in keys)
                state.AppendFormat("  {0}: {1}\n", key, Singleton._glyphTypefacesByKey[key].DebuggerDisplay);
            state.Append("\n");
            return state.ToString();
        }

        readonly Dictionary<string, XGlyphTypeface> _glyphTypefacesByKey;
    }
    internal class IndexToLocationTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Loca;

        internal int[] LocaTable;

        public IndexToLocationTable()
            : base(null, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.Loca;
        }

        public IndexToLocationTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            DirectoryEntry = _fontData.TableDictionary[TableTagNames.Loca];
            Read();
        }

        public bool ShortIndex;

        public void Read()
        {
            try
            {
                ShortIndex = _fontData.head.indexToLocFormat == 0;
                _fontData.Position = DirectoryEntry.Offset;
                if (ShortIndex)
                {
                    int entries = DirectoryEntry.Length / 2;
                    Debug.Assert(_fontData.maxp.numGlyphs + 1 == entries,
                        "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");
                    LocaTable = new int[entries];
                    for (int idx = 0; idx < entries; idx++)
                        LocaTable[idx] = 2 * _fontData.ReadUFWord();
                }
                else
                {
                    int entries = DirectoryEntry.Length / 4;
                    Debug.Assert(_fontData.maxp.numGlyphs + 1 == entries,
                        "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");
                    LocaTable = new int[entries];
                    for (int idx = 0; idx < entries; idx++)
                        LocaTable[idx] = _fontData.ReadLong();
                }
            }
            catch (Exception)
            {
                GetType();
                throw;
            }
        }

        public override void PrepareForCompilation()
        {
            DirectoryEntry.Offset = 0;
            if (ShortIndex)
                DirectoryEntry.Length = LocaTable.Length * 2;
            else
                DirectoryEntry.Length = LocaTable.Length * 4;

            _bytes = new byte[DirectoryEntry.PaddedLength];
            int length = LocaTable.Length;
            int byteIdx = 0;
            if (ShortIndex)
            {
                for (int idx = 0; idx < length; idx++)
                {
                    int value = LocaTable[idx] / 2;
                    _bytes[byteIdx++] = (byte)(value >> 8);
                    _bytes[byteIdx++] = (byte)(value);
                }
            }
            else
            {
                for (int idx = 0; idx < length; idx++)
                {
                    int value = LocaTable[idx];
                    _bytes[byteIdx++] = (byte)(value >> 24);
                    _bytes[byteIdx++] = (byte)(value >> 16);
                    _bytes[byteIdx++] = (byte)(value >> 8);
                    _bytes[byteIdx++] = (byte)value;
                }
            }
            DirectoryEntry.CheckSum = CalcChecksum(_bytes);
        }
        byte[] _bytes;

        public override void Write(OpenTypeFontWriter writer)
        {
            writer.Write(_bytes, 0, DirectoryEntry.PaddedLength);
        }
    }
    internal sealed class OpenTypeDescriptor : FontDescriptor
    {
        public OpenTypeDescriptor(string fontDescriptorKey, string name, XFontStyle stlye, OpenTypeFontface fontface, XPdfFontOptions options)
            : base(fontDescriptorKey)
        {
            FontFace = fontface;
            FontName = name;
            Initialize();
        }

        public OpenTypeDescriptor(string fontDescriptorKey, XFont font)
            : base(fontDescriptorKey)
        {
            try
            {
                FontFace = font.GlyphTypeface.Fontface;
                FontName = font.Name;
                Initialize();
            }
            catch
            {
                GetType();
                throw;
            }
        }

        internal OpenTypeDescriptor(string fontDescriptorKey, string idName, byte[] fontData)
            : base(fontDescriptorKey)
        {
            try
            {
                FontFace = new OpenTypeFontface(fontData, idName);
                if (idName.Contains("XPS-Font-") && FontFace.name != null && FontFace.name.Name.Length != 0)
                {
                    string tag = String.Empty;
                    if (idName.IndexOf('+') == 6)
                        tag = idName.Substring(0, 6);
                    idName = tag + "+" + FontFace.name.Name;
                    if (FontFace.name.Style.Length != 0)
                        idName += "," + FontFace.name.Style;
                }
                FontName = idName;
                Initialize();
            }
            catch (Exception)
            {
                GetType();
                throw;
            }
        }

        internal OpenTypeFontface FontFace;

        void Initialize()
        {
            ItalicAngle = FontFace.post.italicAngle;

            XMin = FontFace.head.xMin;
            YMin = FontFace.head.yMin;
            XMax = FontFace.head.xMax;
            YMax = FontFace.head.yMax;

            UnderlinePosition = FontFace.post.underlinePosition;
            UnderlineThickness = FontFace.post.underlineThickness;

            Debug.Assert(FontFace.os2 != null, "TrueType font has no OS/2 table.");

            StrikeoutPosition = FontFace.os2.yStrikeoutPosition;
            StrikeoutSize = FontFace.os2.yStrikeoutSize;

            StemV = 0;

            UnitsPerEm = FontFace.head.unitsPerEm;

            bool os2SeemsToBeEmpty = FontFace.os2.sTypoAscender == 0 && FontFace.os2.sTypoDescender == 0 && FontFace.os2.sTypoLineGap == 0;
            bool dontUseWinLineMetrics = (FontFace.os2.fsSelection & 128) != 0;
            if (!os2SeemsToBeEmpty && dontUseWinLineMetrics)
            {
                int typoAscender = FontFace.os2.sTypoAscender;
                int typoDescender = FontFace.os2.sTypoDescender;
                int typoLineGap = FontFace.os2.sTypoLineGap;

                Ascender = typoAscender + typoLineGap;
                Descender = -typoDescender;
                LineSpacing = typoAscender + typoLineGap - typoDescender;
            }
            else
            {
                int ascender = FontFace.hhea.ascender;
                int descender = Math.Abs(FontFace.hhea.descender);
                int lineGap = Math.Max((short)0, FontFace.hhea.lineGap);

                if (!os2SeemsToBeEmpty)
                {
                    int winAscent = FontFace.os2.usWinAscent;
                    int winDescent = Math.Abs(FontFace.os2.usWinDescent);

                    Ascender = winAscent;
                    Descender = winDescent;
                    LineSpacing = Math.Max(lineGap + ascender + descender, winAscent + winDescent);
                }
                else
                {
                    Ascender = ascender;
                    Descender = descender;
                    LineSpacing = ascender + descender + lineGap;
                }
            }

            Debug.Assert(Descender >= 0);

            int cellHeight = Ascender + Descender;
            int internalLeading = cellHeight - UnitsPerEm;
            int externalLeading = LineSpacing - cellHeight;
            Leading = externalLeading;

            if (FontFace.os2.version >= 2 && FontFace.os2.sCapHeight != 0)
                CapHeight = FontFace.os2.sCapHeight;
            else
                CapHeight = Ascender;

            if (FontFace.os2.version >= 2 && FontFace.os2.sxHeight != 0)
                XHeight = FontFace.os2.sxHeight;
            else
                XHeight = (int)(0.66 * Ascender);

#if !EDF_CORE
            Encoding ansi = PdfEncoders.WinAnsiEncoding;

#endif

            Encoding unicode = Encoding.Unicode;
            byte[] bytes = new byte[256];

            bool symbol = FontFace.cmap.symbol;
            Widths = new int[256];
            for (int idx = 0; idx < 256; idx++)
            {
                bytes[idx] = (byte)idx;
                char ch = (char)idx;
                string s = ansi.GetString(bytes, idx, 1);
                if (s.Length != 0)
                {
                    if (s[0] != ch)
                        ch = s[0];
                }

                if (symbol)
                {
                    ch = (char)(ch | (FontFace.os2.usFirstCharIndex & 0xFF00));
                }
                int glyphIndex = CharCodeToGlyphIndex(ch);
                Widths[idx] = GlyphIndexToPdfWidth(glyphIndex);
            }
        }
        public int[] Widths;

        public override bool IsBoldFace
        {
            get
            {
                return FontFace.os2.IsBold;
            }
        }

        public override bool IsItalicFace
        {
            get { return FontFace.os2.IsItalic; }
        }

        internal int DesignUnitsToPdf(double value)
        {
            return (int)Math.Round(value * 1000.0 / FontFace.head.unitsPerEm);
        }

        public int CharCodeToGlyphIndex(char value)
        {
            try
            {
                CMap4 cmap = FontFace.cmap.cmap4;
                int segCount = cmap.segCountX2 / 2;
                int seg;
                for (seg = 0; seg < segCount; seg++)
                {
                    if (value <= cmap.endCount[seg])
                        break;
                }
                Debug.Assert(seg < segCount);

                if (value < cmap.startCount[seg])
                    return 0;

                if (cmap.idRangeOffs[seg] == 0)
                    return (value + cmap.idDelta[seg]) & 0xFFFF;

                int idx = cmap.idRangeOffs[seg] / 2 + (value - cmap.startCount[seg]) - (segCount - seg);
                Debug.Assert(idx >= 0 && idx < cmap.glyphCount);

                if (cmap.glyphIdArray[idx] == 0)
                    return 0;

                return (cmap.glyphIdArray[idx] + cmap.idDelta[seg]) & 0xFFFF;
            }
            catch
            {
                GetType();
                throw;
            }
        }

        public int GlyphIndexToPdfWidth(int glyphIndex)
        {
            try
            {
                int numberOfHMetrics = FontFace.hhea.numberOfHMetrics;
                int unitsPerEm = FontFace.head.unitsPerEm;

                if (glyphIndex >= numberOfHMetrics)
                    glyphIndex = numberOfHMetrics - 1;

                int width = FontFace.hmtx.Metrics[glyphIndex].advanceWidth;

                if (unitsPerEm == 1000)
                    return width;
                return width * 1000 / unitsPerEm;
            }
            catch (Exception)
            {
                GetType();
                throw;
            }
        }

        public int PdfWidthFromCharCode(char ch)
        {
            int idx = CharCodeToGlyphIndex(ch);
            int width = GlyphIndexToPdfWidth(idx);
            return width;
        }

        public double GlyphIndexToEmfWidth(int glyphIndex, double emSize)
        {
            try
            {
                int numberOfHMetrics = FontFace.hhea.numberOfHMetrics;
                int unitsPerEm = FontFace.head.unitsPerEm;

                if (glyphIndex >= numberOfHMetrics)
                    glyphIndex = numberOfHMetrics - 1;

                int width = FontFace.hmtx.Metrics[glyphIndex].advanceWidth;

                return width * emSize / unitsPerEm;
            }
            catch (Exception)
            {
                GetType();
                throw;
            }
        }

        public int GlyphIndexToWidth(int glyphIndex)
        {
            try
            {
                int numberOfHMetrics = FontFace.hhea.numberOfHMetrics;

                if (glyphIndex >= numberOfHMetrics)
                    glyphIndex = numberOfHMetrics - 1;

                int width = FontFace.hmtx.Metrics[glyphIndex].advanceWidth;
                return width;
            }
            catch (Exception)
            {
                GetType();
                throw;
            }
        }
    }
    internal sealed class OpenTypeFontface
    {
        OpenTypeFontface(OpenTypeFontface fontface)
        {
            _offsetTable = fontface._offsetTable;
            _fullFaceName = fontface._fullFaceName;
        }

        public OpenTypeFontface(byte[] data, string faceName)
        {
            _fullFaceName = faceName;
            int length = data.Length;
            Array.Copy(data, FontSource.Bytes, length);
            Read();
        }

        public OpenTypeFontface(XFontSource fontSource)
        {
            FontSource = fontSource;
            Read();
            _fullFaceName = name.FullFontName;
        }

        public static OpenTypeFontface CetOrCreateFrom(XFontSource fontSource)
        {
            OpenTypeFontface fontface;
            if (OpenTypeFontfaceCache.TryGetFontface(fontSource.Key, out fontface))
            {
                return fontface;
            }
            Debug.Assert(fontSource.Fontface != null);
            fontface = OpenTypeFontfaceCache.AddFontface(fontSource.Fontface);
            Debug.Assert(ReferenceEquals(fontSource.Fontface, fontface));
            return fontface;
        }

        public string FullFaceName
        {
            get { return _fullFaceName; }
        }
        readonly string _fullFaceName;

        public ulong CheckSum
        {
            get
            {
                if (_checkSum == 0)
                    _checkSum = FontHelper.CalcChecksum(FontSource.Bytes);
                return _checkSum;
            }
        }
        ulong _checkSum;

        public XFontSource FontSource
        {
            get { return _fontSource; }
            private set
            {
                if (value == null)
                    throw new InvalidOperationException("Font cannot be resolved.");
                _fontSource = value;
            }
        }
        XFontSource _fontSource;

        internal FontTechnology _fontTechnology;

        internal OffsetTable _offsetTable;

        internal Dictionary<string, TableDirectoryEntry> TableDictionary = new Dictionary<string, TableDirectoryEntry>();

        internal CMapTable cmap;
        internal ControlValueTable cvt;
        internal FontProgram fpgm;
        internal MaximumProfileTable maxp;
        internal NameTable name;
        internal ControlValueProgram prep;
        internal FontHeaderTable head;
        internal HorizontalHeaderTable hhea;
        internal HorizontalMetricsTable hmtx;
        internal OS2Table os2;
        internal PostScriptTable post;
        internal GlyphDataTable glyf;
        internal IndexToLocationTable loca;
        internal GlyphSubstitutionTable gsub;
        internal VerticalHeaderTable vhea;
        internal VerticalMetricsTable vmtx;
        public bool CanRead
        {
            get { return FontSource != null; }
        }

        public bool CanWrite
        {
            get { return FontSource == null; }
        }

        public void AddTable(OpenTypeFontTable fontTable)
        {
            if (!CanWrite)
                throw new InvalidOperationException("Font image cannot be modified.");

            if (fontTable == null)
                throw new ArgumentNullException("fontTable");

            if (fontTable._fontData == null)
            {
                fontTable._fontData = this;
            }
            else
            {
                Debug.Assert(fontTable._fontData.CanRead);
                fontTable = new IRefFontTable(this, fontTable);
            }

            TableDictionary[fontTable.DirectoryEntry.Tag] = fontTable.DirectoryEntry;
            switch (fontTable.DirectoryEntry.Tag)
            {
                case TableTagNames.CMap:
                    cmap = fontTable as CMapTable;
                    break;

                case TableTagNames.Cvt:
                    cvt = fontTable as ControlValueTable;
                    break;

                case TableTagNames.Fpgm:
                    fpgm = fontTable as FontProgram;
                    break;

                case TableTagNames.MaxP:
                    maxp = fontTable as MaximumProfileTable;
                    break;

                case TableTagNames.Name:
                    name = fontTable as NameTable;
                    break;

                case TableTagNames.Head:
                    head = fontTable as FontHeaderTable;
                    break;

                case TableTagNames.HHea:
                    hhea = fontTable as HorizontalHeaderTable;
                    break;

                case TableTagNames.HMtx:
                    hmtx = fontTable as HorizontalMetricsTable;
                    break;

                case TableTagNames.OS2:
                    os2 = fontTable as OS2Table;
                    break;

                case TableTagNames.Post:
                    post = fontTable as PostScriptTable;
                    break;

                case TableTagNames.Glyf:
                    glyf = fontTable as GlyphDataTable;
                    break;

                case TableTagNames.Loca:
                    loca = fontTable as IndexToLocationTable;
                    break;

                case TableTagNames.GSUB:
                    gsub = fontTable as GlyphSubstitutionTable;
                    break;

                case TableTagNames.Prep:
                    prep = fontTable as ControlValueProgram;
                    break;
            }
        }

        internal void Read()
        {
            const uint OTTO = 0x4f54544f;
            const uint TTCF = 0x74746366;
            try
            {

                uint startTag = ReadULong();
                if (startTag == TTCF)
                {
                    _fontTechnology = FontTechnology.TrueTypeCollection;
                    throw new InvalidOperationException("TrueType collection fonts are not yet supported by PDFsharp.");
                }

                _offsetTable.Version = startTag;
                _offsetTable.TableCount = ReadUShort();
                _offsetTable.SearchRange = ReadUShort();
                _offsetTable.EntrySelector = ReadUShort();
                _offsetTable.RangeShift = ReadUShort();

                Debug.Assert(_pos == 12);
                if (_offsetTable.Version == OTTO)
                    _fontTechnology = FontTechnology.PostscriptOutlines;
                else
                    _fontTechnology = FontTechnology.TrueTypeOutlines;

                for (int idx = 0; idx < _offsetTable.TableCount; idx++)
                {
                    TableDirectoryEntry entry = TableDirectoryEntry.ReadFrom(this);
                    TableDictionary.Add(entry.Tag, entry);
                }

                if (TableDictionary.ContainsKey("bhed"))
                    throw new NotSupportedException("Bitmap fonts are not supported by PDFsharp.");

                if (Seek(CMapTable.Tag) != -1)
                    cmap = new CMapTable(this);

                if (Seek(ControlValueTable.Tag) != -1)
                    cvt = new ControlValueTable(this);

                if (Seek(FontProgram.Tag) != -1)
                    fpgm = new FontProgram(this);

                if (Seek(MaximumProfileTable.Tag) != -1)
                    maxp = new MaximumProfileTable(this);

                if (Seek(NameTable.Tag) != -1)
                    name = new NameTable(this);

                if (Seek(FontHeaderTable.Tag) != -1)
                    head = new FontHeaderTable(this);

                if (Seek(HorizontalHeaderTable.Tag) != -1)
                    hhea = new HorizontalHeaderTable(this);

                if (Seek(HorizontalMetricsTable.Tag) != -1)
                    hmtx = new HorizontalMetricsTable(this);

                if (Seek(OS2Table.Tag) != -1)
                    os2 = new OS2Table(this);

                if (Seek(PostScriptTable.Tag) != -1)
                    post = new PostScriptTable(this);

                if (Seek(GlyphDataTable.Tag) != -1)
                    glyf = new GlyphDataTable(this);

                if (Seek(IndexToLocationTable.Tag) != -1)
                    loca = new IndexToLocationTable(this);

                if (Seek(GlyphSubstitutionTable.Tag) != -1)
                    gsub = new GlyphSubstitutionTable(this);

                if (Seek(ControlValueProgram.Tag) != -1)
                    prep = new ControlValueProgram(this);
            }
            catch (Exception)
            {
                GetType();
                throw;
            }
        }

        public OpenTypeFontface CreateFontSubSet(Dictionary<int, object> glyphs, bool cidFont)
        {
            OpenTypeFontface fontData = new OpenTypeFontface(this);

            IndexToLocationTable locaNew = new IndexToLocationTable();
            locaNew.ShortIndex = loca.ShortIndex;
            GlyphDataTable glyfNew = new GlyphDataTable();

            if (!cidFont)
                fontData.AddTable(cmap);
            if (cvt != null)
                fontData.AddTable(cvt);
            if (fpgm != null)
                fontData.AddTable(fpgm);
            fontData.AddTable(glyfNew);
            fontData.AddTable(head);
            fontData.AddTable(hhea);
            fontData.AddTable(hmtx);
            fontData.AddTable(locaNew);
            if (maxp != null)
                fontData.AddTable(maxp);
            if (prep != null)
                fontData.AddTable(prep);

            glyf.CompleteGlyphClosure(glyphs);

            int glyphCount = glyphs.Count;
            int[] glyphArray = new int[glyphCount];
            glyphs.Keys.CopyTo(glyphArray, 0);
            Array.Sort(glyphArray);

            int size = 0;
            for (int idx = 0; idx < glyphCount; idx++)
                size += glyf.GetGlyphSize(glyphArray[idx]);
            glyfNew.DirectoryEntry.Length = size;

            int numGlyphs = maxp.numGlyphs;
            locaNew.LocaTable = new int[numGlyphs + 1];

            glyfNew.GlyphTable = new byte[glyfNew.DirectoryEntry.PaddedLength];

            int glyphOffset = 0;
            int glyphIndex = 0;
            for (int idx = 0; idx < numGlyphs; idx++)
            {
                locaNew.LocaTable[idx] = glyphOffset;
                if (glyphIndex < glyphCount && glyphArray[glyphIndex] == idx)
                {
                    glyphIndex++;
                    byte[] bytes = glyf.GetGlyphData(idx);
                    int length = bytes.Length;
                    if (length > 0)
                    {
                        Buffer.BlockCopy(bytes, 0, glyfNew.GlyphTable, glyphOffset, length);
                        glyphOffset += length;
                    }
                }
            }
            locaNew.LocaTable[numGlyphs] = glyphOffset;

            fontData.Compile();

            return fontData;
        }

        void Compile()
        {
            MemoryStream stream = new MemoryStream();
            OpenTypeFontWriter writer = new OpenTypeFontWriter(stream);

            int tableCount = TableDictionary.Count;
            int selector = _entrySelectors[tableCount];

            _offsetTable.Version = 0x00010000;
            _offsetTable.TableCount = tableCount;
            _offsetTable.SearchRange = (ushort)((1 << selector) * 16);
            _offsetTable.EntrySelector = (ushort)selector;
            _offsetTable.RangeShift = (ushort)((tableCount - (1 << selector)) * 16);
            _offsetTable.Write(writer);

            string[] tags = new string[tableCount];
            TableDictionary.Keys.CopyTo(tags, 0);
            Array.Sort(tags, StringComparer.Ordinal);

            int tablePosition = 12 + 16 * tableCount;
            for (int idx = 0; idx < tableCount; idx++)
            {
                TableDirectoryEntry entry = TableDictionary[tags[idx]];
                entry.FontTable.PrepareForCompilation();
                entry.Offset = tablePosition;
                writer.Position = tablePosition;
                entry.FontTable.Write(writer);
                int endPosition = writer.Position;
                tablePosition = endPosition;
                writer.Position = 12 + 16 * idx;
                entry.Write(writer);
            }
            writer.Stream.Flush();
            int l = (int)writer.Stream.Length;
            FontSource = XFontSource.CreateCompiledFont(stream.ToArray());
        }
        static readonly int[] _entrySelectors = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };

        public int Position
        {
            get { return _pos; }
            set { _pos = value; }
        }
        int _pos;

        public int Seek(string tag)
        {
            if (TableDictionary.ContainsKey(tag))
            {
                _pos = TableDictionary[tag].Offset;
                return _pos;
            }
            return -1;
        }

        public int SeekOffset(int offset)
        {
            _pos += offset;
            return _pos;
        }

        public byte ReadByte()
        {
            return _fontSource.Bytes[_pos++];
        }

        public short ReadShort()
        {
            int pos = _pos;
            _pos += 2;
            return (short)((_fontSource.Bytes[pos] << 8) | (_fontSource.Bytes[pos + 1]));
        }

        public ushort ReadUShort()
        {
            int pos = _pos;
            _pos += 2;
            return (ushort)((_fontSource.Bytes[pos] << 8) | (_fontSource.Bytes[pos + 1]));
        }

        public int ReadLong()
        {
            int pos = _pos;
            _pos += 4;
            return (_fontSource.Bytes[pos] << 24) | (_fontSource.Bytes[pos + 1] << 16) | (_fontSource.Bytes[pos + 2] << 8) | (_fontSource.Bytes[pos + 3]);
        }

        public uint ReadULong()
        {
            int pos = _pos;
            _pos += 4;
            return (uint)((_fontSource.Bytes[pos] << 24) | (_fontSource.Bytes[pos + 1] << 16) | (_fontSource.Bytes[pos + 2] << 8) | (_fontSource.Bytes[pos + 3]));
        }

        public Fixed ReadFixed()
        {
            int pos = _pos;
            _pos += 4;
            return (_fontSource.Bytes[pos] << 24) | (_fontSource.Bytes[pos + 1] << 16) | (_fontSource.Bytes[pos + 2] << 8) | (_fontSource.Bytes[pos + 3]);
        }

        public short ReadFWord()
        {
            int pos = _pos;
            _pos += 2;
            return (short)((_fontSource.Bytes[pos] << 8) | (_fontSource.Bytes[pos + 1]));
        }

        public ushort ReadUFWord()
        {
            int pos = _pos;
            _pos += 2;
            return (ushort)((_fontSource.Bytes[pos] << 8) | (_fontSource.Bytes[pos + 1]));
        }

        public long ReadLongDate()
        {
            int pos = _pos;
            _pos += 8;
            byte[] bytes = _fontSource.Bytes;
            return (((long)bytes[pos]) << 56) | (((long)bytes[pos + 1]) << 48) | (((long)bytes[pos + 2]) << 40) | (((long)bytes[pos + 3]) << 32) |
                   (((long)bytes[pos + 4]) << 24) | (((long)bytes[pos + 5]) << 16) | (((long)bytes[pos + 6]) << 8) | bytes[pos + 7];
        }

        public string ReadString(int size)
        {
            char[] chars = new char[size];
            for (int idx = 0; idx < size; idx++)
                chars[idx] = (char)_fontSource.Bytes[_pos++];
            return new string(chars);
        }

        public byte[] ReadBytes(int size)
        {
            byte[] bytes = new byte[size];
            for (int idx = 0; idx < size; idx++)
                bytes[idx] = _fontSource.Bytes[_pos++];
            return bytes;
        }

        public void Read(byte[] buffer)
        {
            Read(buffer, 0, buffer.Length);
        }

        public void Read(byte[] buffer, int offset, int length)
        {
            Buffer.BlockCopy(_fontSource.Bytes, _pos, buffer, offset, length);
            _pos += length;
        }

        public string ReadTag()
        {
            return ReadString(4);
        }

        internal string DebuggerDisplay
        {
            get { return string.Format(CultureInfo.InvariantCulture, "OpenType fontfaces: {0}", _fullFaceName); }
        }

        internal struct OffsetTable
        {
            public uint Version;

            public int TableCount;

            public ushort SearchRange;

            public ushort EntrySelector;

            public ushort RangeShift;

            public void Write(OpenTypeFontWriter writer)
            {
                writer.WriteUInt(Version);
                writer.WriteShort(TableCount);
                writer.WriteUShort(SearchRange);
                writer.WriteUShort(EntrySelector);
                writer.WriteUShort(RangeShift);
            }
        }
    }
    internal class OpenTypeFontfaceCache
    {
        OpenTypeFontfaceCache()
        {
            _fontfaceCache = new Dictionary<string, OpenTypeFontface>(StringComparer.OrdinalIgnoreCase);
            _fontfacesByCheckSum = new Dictionary<ulong, OpenTypeFontface>();
        }

        public static bool TryGetFontface(string key, out OpenTypeFontface fontface)
        {
            try
            {
                Lock.EnterFontFactory();
                bool result = Singleton._fontfaceCache.TryGetValue(key, out fontface);
                return result;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static bool TryGetFontface(ulong checkSum, out OpenTypeFontface fontface)
        {
            try
            {
                Lock.EnterFontFactory();
                bool result = Singleton._fontfacesByCheckSum.TryGetValue(checkSum, out fontface);
                return result;
            }
            finally { Lock.ExitFontFactory(); }
        }

        public static OpenTypeFontface AddFontface(OpenTypeFontface fontface)
        {
            try
            {
                Lock.EnterFontFactory();
                OpenTypeFontface fontfaceCheck;
                if (TryGetFontface(fontface.FullFaceName, out fontfaceCheck))
                {
                    if (fontfaceCheck.CheckSum != fontface.CheckSum)
                        throw new InvalidOperationException("OpenTypeFontface with same signature but different bytes.");
                    return fontfaceCheck;
                }
                Singleton._fontfaceCache.Add(fontface.FullFaceName, fontface);
                Singleton._fontfacesByCheckSum.Add(fontface.CheckSum, fontface);
                return fontface;
            }
            finally { Lock.ExitFontFactory(); }
        }

        static OpenTypeFontfaceCache Singleton
        {
            get
            {
                if (_singleton == null)
                {
                    try
                    {
                        Lock.EnterFontFactory();
                        if (_singleton == null)
                            _singleton = new OpenTypeFontfaceCache();
                    }
                    finally { Lock.ExitFontFactory(); }
                }
                return _singleton;
            }
        }
        static volatile OpenTypeFontfaceCache _singleton;

        internal static string GetCacheState()
        {
            StringBuilder state = new StringBuilder();
            state.Append("====================\n");
            state.Append("OpenType fontfaces by name\n");
            Dictionary<string, OpenTypeFontface>.KeyCollection familyKeys = Singleton._fontfaceCache.Keys;
            int count = familyKeys.Count;
            string[] keys = new string[count];
            familyKeys.CopyTo(keys, 0);
            Array.Sort(keys, StringComparer.OrdinalIgnoreCase);
            foreach (string key in keys)
                state.AppendFormat("  {0}: {1}\n", key, Singleton._fontfaceCache[key].DebuggerDisplay);
            state.Append("\n");
            return state.ToString();
        }

        readonly Dictionary<string, OpenTypeFontface> _fontfaceCache;

        readonly Dictionary<ulong, OpenTypeFontface> _fontfacesByCheckSum;

        string DebuggerDisplay
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Fontfaces: {0}", _fontfaceCache.Count); }
        }
    }
    internal class OpenTypeFontTable : ICloneable
    {
        public OpenTypeFontTable(OpenTypeFontface fontData, string tag)
        {
            _fontData = fontData;
            if (fontData != null && fontData.TableDictionary.ContainsKey(tag))
                DirectoryEntry = fontData.TableDictionary[tag];
            else
                DirectoryEntry = new TableDirectoryEntry(tag);
            DirectoryEntry.FontTable = this;
        }

        public object Clone()
        {
            return DeepCopy();
        }

        protected virtual OpenTypeFontTable DeepCopy()
        {
            OpenTypeFontTable fontTable = (OpenTypeFontTable)MemberwiseClone();
            fontTable.DirectoryEntry.Offset = 0;
            fontTable.DirectoryEntry.FontTable = fontTable;
            return fontTable;
        }

        public OpenTypeFontface FontData
        {
            get { return _fontData; }
        }
        internal OpenTypeFontface _fontData;

        public TableDirectoryEntry DirectoryEntry;

        public virtual void PrepareForCompilation()
        { }

        public virtual void Write(OpenTypeFontWriter writer)
        { }

        public static uint CalcChecksum(byte[] bytes)
        {
            Debug.Assert((bytes.Length & 3) == 0);
            uint byte3, byte2, byte1, byte0;
            byte3 = byte2 = byte1 = byte0 = 0;
            int length = bytes.Length;
            for (int idx = 0; idx < length;)
            {
                byte3 += bytes[idx++];
                byte2 += bytes[idx++];
                byte1 += bytes[idx++];
                byte0 += bytes[idx++];
            }
            return (byte3 << 24) + (byte2 << 16) + (byte1 << 8) + byte0;
        }
    }
    internal enum PlatformId
    {
        Apple, Mac, Iso, Win
    }

    internal enum WinEncodingId
    {
        Symbol, Unicode
    }

    internal class CMap4 : OpenTypeFontTable
    {
        public WinEncodingId encodingId;
        public ushort format;
        public ushort length;
        public ushort language;
        public ushort segCountX2;
        public ushort searchRange;
        public ushort entrySelector;
        public ushort rangeShift;
        public ushort[] endCount;
        public ushort[] startCount;
        public short[] idDelta;
        public ushort[] idRangeOffs;
        public int glyphCount;
        public ushort[] glyphIdArray;

        public CMap4(OpenTypeFontface fontData, WinEncodingId encodingId)
            : base(fontData, "----")
        {
            this.encodingId = encodingId;
            Read();
        }

        internal void Read()
        {
            try
            {
                format = _fontData.ReadUShort();
                Debug.Assert(format == 4, "Only format 4 expected.");
                length = _fontData.ReadUShort();
                language = _fontData.ReadUShort();
                segCountX2 = _fontData.ReadUShort();
                searchRange = _fontData.ReadUShort();
                entrySelector = _fontData.ReadUShort();
                rangeShift = _fontData.ReadUShort();

                int segCount = segCountX2 / 2;
                glyphCount = (length - (16 + 8 * segCount)) / 2;

                endCount = new ushort[segCount];
                startCount = new ushort[segCount];
                idDelta = new short[segCount];
                idRangeOffs = new ushort[segCount];

                glyphIdArray = new ushort[glyphCount];

                for (int idx = 0; idx < segCount; idx++)
                    endCount[idx] = _fontData.ReadUShort();

                _fontData.ReadUShort();

                for (int idx = 0; idx < segCount; idx++)
                    startCount[idx] = _fontData.ReadUShort();

                for (int idx = 0; idx < segCount; idx++)
                    idDelta[idx] = _fontData.ReadShort();

                for (int idx = 0; idx < segCount; idx++)
                    idRangeOffs[idx] = _fontData.ReadUShort();

                for (int idx = 0; idx < glyphCount; idx++)
                    glyphIdArray[idx] = _fontData.ReadUShort();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class CMapTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.CMap;

        public ushort version;
        public ushort numTables;

        public bool symbol;

        public CMap4 cmap4;

        public CMapTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        internal void Read()
        {
            try
            {
                int tableOffset = _fontData.Position;

                version = _fontData.ReadUShort();
                numTables = _fontData.ReadUShort();

                bool success = false;
                for (int idx = 0; idx < numTables; idx++)
                {
                    PlatformId platformId = (PlatformId)_fontData.ReadUShort();
                    WinEncodingId encodingId = (WinEncodingId)_fontData.ReadUShort();
                    int offset = _fontData.ReadLong();

                    int currentPosition = _fontData.Position;

                    if (platformId == PlatformId.Win && (encodingId == WinEncodingId.Symbol || encodingId == WinEncodingId.Unicode))
                    {
                        symbol = encodingId == WinEncodingId.Symbol;

                        _fontData.Position = tableOffset + offset;
                        cmap4 = new CMap4(_fontData, encodingId);
                        _fontData.Position = currentPosition;
                        success = true;
                        break;
                    }
                }
                if (!success)
                    throw new InvalidOperationException("Font has no usable platform or encoding ID. It cannot be used with PDFsharp.");
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class FontHeaderTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Head;

        public Fixed version;
        public Fixed fontRevision;
        public uint checkSumAdjustment;
        public uint magicNumber;
        public ushort flags;
        public ushort unitsPerEm;
        public long created;
        public long modified;
        public short xMin, yMin;
        public short xMax, yMax;
        public ushort macStyle;
        public ushort lowestRecPPEM;
        public short fontDirectionHint;
        public short indexToLocFormat;
        public short glyphDataFormat;

        public FontHeaderTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                version = _fontData.ReadFixed();
                fontRevision = _fontData.ReadFixed();
                checkSumAdjustment = _fontData.ReadULong();
                magicNumber = _fontData.ReadULong();
                flags = _fontData.ReadUShort();
                unitsPerEm = _fontData.ReadUShort();
                created = _fontData.ReadLongDate();
                modified = _fontData.ReadLongDate();
                xMin = _fontData.ReadShort();
                yMin = _fontData.ReadShort();
                xMax = _fontData.ReadShort();
                yMax = _fontData.ReadShort();
                macStyle = _fontData.ReadUShort();
                lowestRecPPEM = _fontData.ReadUShort();
                fontDirectionHint = _fontData.ReadShort();
                indexToLocFormat = _fontData.ReadShort();
                glyphDataFormat = _fontData.ReadShort();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class HorizontalHeaderTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.HHea;

        public Fixed version;
        public FWord ascender;
        public FWord descender;
        public FWord lineGap;
        public UFWord advanceWidthMax;
        public FWord minLeftSideBearing;
        public FWord minRightSideBearing;
        public FWord xMaxExtent;
        public short caretSlopeRise;
        public short caretSlopeRun;
        public short reserved1;
        public short reserved2;
        public short reserved3;
        public short reserved4;
        public short reserved5;
        public short metricDataFormat;
        public ushort numberOfHMetrics;

        public HorizontalHeaderTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                version = _fontData.ReadFixed();
                ascender = _fontData.ReadFWord();
                descender = _fontData.ReadFWord();
                lineGap = _fontData.ReadFWord();
                advanceWidthMax = _fontData.ReadUFWord();
                minLeftSideBearing = _fontData.ReadFWord();
                minRightSideBearing = _fontData.ReadFWord();
                xMaxExtent = _fontData.ReadFWord();
                caretSlopeRise = _fontData.ReadShort();
                caretSlopeRun = _fontData.ReadShort();
                reserved1 = _fontData.ReadShort();
                reserved2 = _fontData.ReadShort();
                reserved3 = _fontData.ReadShort();
                reserved4 = _fontData.ReadShort();
                reserved5 = _fontData.ReadShort();
                metricDataFormat = _fontData.ReadShort();
                numberOfHMetrics = _fontData.ReadUShort();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class HorizontalMetrics : OpenTypeFontTable
    {
        public const string Tag = "----";

        public ushort advanceWidth;
        public short lsb;

        public HorizontalMetrics(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                advanceWidth = _fontData.ReadUFWord();
                lsb = _fontData.ReadFWord();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class HorizontalMetricsTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.HMtx;

        public HorizontalMetrics[] Metrics;
        public FWord[] LeftSideBearing;

        public HorizontalMetricsTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                HorizontalHeaderTable hhea = _fontData.hhea;
                MaximumProfileTable maxp = _fontData.maxp;
                if (hhea != null && maxp != null)
                {
                    int numMetrics = hhea.numberOfHMetrics;
                    int numLsbs = maxp.numGlyphs - numMetrics;

                    Debug.Assert(numMetrics != 0);
                    Debug.Assert(numLsbs >= 0);

                    Metrics = new HorizontalMetrics[numMetrics];
                    for (int idx = 0; idx < numMetrics; idx++)
                        Metrics[idx] = new HorizontalMetrics(_fontData);

                    if (numLsbs > 0)
                    {
                        LeftSideBearing = new FWord[numLsbs];
                        for (int idx = 0; idx < numLsbs; idx++)
                            LeftSideBearing[idx] = _fontData.ReadFWord();
                    }
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class VerticalHeaderTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.VHea;

        public Fixed Version;
        public FWord Ascender;
        public FWord Descender;
        public FWord LineGap;
        public UFWord AdvanceWidthMax;
        public FWord MinLeftSideBearing;
        public FWord MinRightSideBearing;
        public FWord xMaxExtent;
        public short caretSlopeRise;
        public short caretSlopeRun;
        public short reserved1;
        public short reserved2;
        public short reserved3;
        public short reserved4;
        public short reserved5;
        public short metricDataFormat;
        public ushort numberOfHMetrics;

        public VerticalHeaderTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                Version = _fontData.ReadFixed();
                Ascender = _fontData.ReadFWord();
                Descender = _fontData.ReadFWord();
                LineGap = _fontData.ReadFWord();
                AdvanceWidthMax = _fontData.ReadUFWord();
                MinLeftSideBearing = _fontData.ReadFWord();
                MinRightSideBearing = _fontData.ReadFWord();
                xMaxExtent = _fontData.ReadFWord();
                caretSlopeRise = _fontData.ReadShort();
                caretSlopeRun = _fontData.ReadShort();
                reserved1 = _fontData.ReadShort();
                reserved2 = _fontData.ReadShort();
                reserved3 = _fontData.ReadShort();
                reserved4 = _fontData.ReadShort();
                reserved5 = _fontData.ReadShort();
                metricDataFormat = _fontData.ReadShort();
                numberOfHMetrics = _fontData.ReadUShort();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class VerticalMetrics : OpenTypeFontTable
    {
        public const string Tag = "----";

        public ushort advanceWidth;
        public short lsb;

        public VerticalMetrics(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                advanceWidth = _fontData.ReadUFWord();
                lsb = _fontData.ReadFWord();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class VerticalMetricsTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.VMtx;

        public HorizontalMetrics[] metrics;
        public FWord[] leftSideBearing;

        public VerticalMetricsTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
            throw new NotImplementedException("VerticalMetricsTable");
        }

        public void Read()
        {
            try
            {
                HorizontalHeaderTable hhea = _fontData.hhea;
                MaximumProfileTable maxp = _fontData.maxp;
                if (hhea != null && maxp != null)
                {
                    int numMetrics = hhea.numberOfHMetrics;
                    int numLsbs = maxp.numGlyphs - numMetrics;

                    Debug.Assert(numMetrics != 0);
                    Debug.Assert(numLsbs >= 0);

                    metrics = new HorizontalMetrics[numMetrics];
                    for (int idx = 0; idx < numMetrics; idx++)
                        metrics[idx] = new HorizontalMetrics(_fontData);

                    if (numLsbs > 0)
                    {
                        leftSideBearing = new FWord[numLsbs];
                        for (int idx = 0; idx < numLsbs; idx++)
                            leftSideBearing[idx] = _fontData.ReadFWord();
                    }
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class MaximumProfileTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.MaxP;

        public Fixed version;
        public ushort numGlyphs;
        public ushort maxPoints;
        public ushort maxContours;
        public ushort maxCompositePoints;
        public ushort maxCompositeContours;
        public ushort maxZones;
        public ushort maxTwilightPoints;
        public ushort maxStorage;
        public ushort maxFunctionDefs;
        public ushort maxInstructionDefs;
        public ushort maxStackElements;
        public ushort maxSizeOfInstructions;
        public ushort maxComponentElements;
        public ushort maxComponentDepth;

        public MaximumProfileTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                version = _fontData.ReadFixed();
                numGlyphs = _fontData.ReadUShort();
                maxPoints = _fontData.ReadUShort();
                maxContours = _fontData.ReadUShort();
                maxCompositePoints = _fontData.ReadUShort();
                maxCompositeContours = _fontData.ReadUShort();
                maxZones = _fontData.ReadUShort();
                maxTwilightPoints = _fontData.ReadUShort();
                maxStorage = _fontData.ReadUShort();
                maxFunctionDefs = _fontData.ReadUShort();
                maxInstructionDefs = _fontData.ReadUShort();
                maxStackElements = _fontData.ReadUShort();
                maxSizeOfInstructions = _fontData.ReadUShort();
                maxComponentElements = _fontData.ReadUShort();
                maxComponentDepth = _fontData.ReadUShort();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class NameTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Name;

        public string Name = String.Empty;

        public string Style = String.Empty;

        public string FullFontName = String.Empty;

        public ushort format;
        public ushort count;
        public ushort stringOffset;

        byte[] bytes;

        public NameTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                bytes = new byte[DirectoryEntry.PaddedLength];
                Buffer.BlockCopy(_fontData.FontSource.Bytes, DirectoryEntry.Offset, bytes, 0, DirectoryEntry.Length);

                format = _fontData.ReadUShort();
                count = _fontData.ReadUShort();
                stringOffset = _fontData.ReadUShort();

                for (int idx = 0; idx < count; idx++)
                {
                    NameRecord nrec = ReadNameRecord();
                    byte[] value = new byte[nrec.length];
                    Buffer.BlockCopy(_fontData.FontSource.Bytes, DirectoryEntry.Offset + stringOffset + nrec.offset, value, 0, nrec.length);

                    if (nrec.platformID == 0 || nrec.platformID == 3)
                    {
                        if (nrec.nameID == 1 && nrec.languageID == 0x0409)
                        {
                            if (String.IsNullOrEmpty(Name))
                                Name = Encoding.BigEndianUnicode.GetString(value, 0, value.Length);
                        }

                        if (nrec.nameID == 2 && nrec.languageID == 0x0409)
                        {
                            if (String.IsNullOrEmpty(Style))
                                Style = Encoding.BigEndianUnicode.GetString(value, 0, value.Length);
                        }

                        if (nrec.nameID == 4 && nrec.languageID == 0x0409)
                        {
                            if (String.IsNullOrEmpty(FullFontName))
                                FullFontName = Encoding.BigEndianUnicode.GetString(value, 0, value.Length);
                        }
                    }
                }
                Debug.Assert(!String.IsNullOrEmpty(Name));
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }

        NameRecord ReadNameRecord()
        {
            NameRecord nrec = new NameRecord();
            nrec.platformID = _fontData.ReadUShort();
            nrec.encodingID = _fontData.ReadUShort();
            nrec.languageID = _fontData.ReadUShort();
            nrec.nameID = _fontData.ReadUShort();
            nrec.length = _fontData.ReadUShort();
            nrec.offset = _fontData.ReadUShort();
            return nrec;
        }

        class NameRecord
        {
            public ushort platformID;
            public ushort encodingID;
            public ushort languageID;
            public ushort nameID;
            public ushort length;
            public ushort offset;
        }
    }

    internal class OS2Table : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.OS2;

        [Flags]
        public enum FontSelectionFlags : ushort
        {
            Italic = 1 << 0,
            Bold = 1 << 5,
            Regular = 1 << 6,
        }

        public ushort version;
        public short xAvgCharWidth;
        public ushort usWeightClass;
        public ushort usWidthClass;
        public ushort fsType;
        public short ySubscriptXSize;
        public short ySubscriptYSize;
        public short ySubscriptXOffset;
        public short ySubscriptYOffset;
        public short ySuperscriptXSize;
        public short ySuperscriptYSize;
        public short ySuperscriptXOffset;
        public short ySuperscriptYOffset;
        public short yStrikeoutSize;
        public short yStrikeoutPosition;
        public short sFamilyClass;
        public byte[] panose;
        public uint ulUnicodeRange1;
        public uint ulUnicodeRange2;
        public uint ulUnicodeRange3;
        public uint ulUnicodeRange4;
        public string achVendID;
        public ushort fsSelection;
        public ushort usFirstCharIndex;
        public ushort usLastCharIndex;
        public short sTypoAscender;
        public short sTypoDescender;
        public short sTypoLineGap;
        public ushort usWinAscent;
        public ushort usWinDescent;
        public uint ulCodePageRange1;
        public uint ulCodePageRange2;
        public short sxHeight;
        public short sCapHeight;
        public ushort usDefaultChar;
        public ushort usBreakChar;
        public ushort usMaxContext;

        public OS2Table(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                version = _fontData.ReadUShort();
                xAvgCharWidth = _fontData.ReadShort();
                usWeightClass = _fontData.ReadUShort();
                usWidthClass = _fontData.ReadUShort();
                fsType = _fontData.ReadUShort();
                ySubscriptXSize = _fontData.ReadShort();
                ySubscriptYSize = _fontData.ReadShort();
                ySubscriptXOffset = _fontData.ReadShort();
                ySubscriptYOffset = _fontData.ReadShort();
                ySuperscriptXSize = _fontData.ReadShort();
                ySuperscriptYSize = _fontData.ReadShort();
                ySuperscriptXOffset = _fontData.ReadShort();
                ySuperscriptYOffset = _fontData.ReadShort();
                yStrikeoutSize = _fontData.ReadShort();
                yStrikeoutPosition = _fontData.ReadShort();
                sFamilyClass = _fontData.ReadShort();
                panose = _fontData.ReadBytes(10);
                ulUnicodeRange1 = _fontData.ReadULong();
                ulUnicodeRange2 = _fontData.ReadULong();
                ulUnicodeRange3 = _fontData.ReadULong();
                ulUnicodeRange4 = _fontData.ReadULong();
                achVendID = _fontData.ReadString(4);
                fsSelection = _fontData.ReadUShort();
                usFirstCharIndex = _fontData.ReadUShort();
                usLastCharIndex = _fontData.ReadUShort();
                sTypoAscender = _fontData.ReadShort();
                sTypoDescender = _fontData.ReadShort();
                sTypoLineGap = _fontData.ReadShort();
                usWinAscent = _fontData.ReadUShort();
                usWinDescent = _fontData.ReadUShort();

                if (version >= 1)
                {
                    ulCodePageRange1 = _fontData.ReadULong();
                    ulCodePageRange2 = _fontData.ReadULong();

                    if (version >= 2)
                    {
                        sxHeight = _fontData.ReadShort();
                        sCapHeight = _fontData.ReadShort();
                        usDefaultChar = _fontData.ReadUShort();
                        usBreakChar = _fontData.ReadUShort();
                        usMaxContext = _fontData.ReadUShort();
                    }
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }

        public bool IsBold
        {
            get { return (fsSelection & (ushort)FontSelectionFlags.Bold) != 0; }
        }

        public bool IsItalic
        {
            get { return (fsSelection & (ushort)FontSelectionFlags.Italic) != 0; }
        }
    }

    internal class PostScriptTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Post;

        public Fixed formatType;
        public float italicAngle;
        public FWord underlinePosition;
        public FWord underlineThickness;
        public ulong isFixedPitch;
        public ulong minMemType42;
        public ulong maxMemType42;
        public ulong minMemType1;
        public ulong maxMemType1;

        public PostScriptTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            Read();
        }

        public void Read()
        {
            try
            {
                formatType = _fontData.ReadFixed();
                italicAngle = _fontData.ReadFixed() / 65536f;
                underlinePosition = _fontData.ReadFWord();
                underlineThickness = _fontData.ReadFWord();
                isFixedPitch = _fontData.ReadULong();
                minMemType42 = _fontData.ReadULong();
                maxMemType42 = _fontData.ReadULong();
                minMemType1 = _fontData.ReadULong();
                maxMemType1 = _fontData.ReadULong();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class ControlValueTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Cvt;

        FWord[] array;

        public ControlValueTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.Cvt;
            DirectoryEntry = fontData.TableDictionary[TableTagNames.Cvt];
            Read();
        }

        public void Read()
        {
            try
            {
                int length = DirectoryEntry.Length / 2;
                array = new FWord[length];
                for (int idx = 0; idx < length; idx++)
                    array[idx] = _fontData.ReadFWord();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class FontProgram : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Fpgm;

        byte[] bytes;

        public FontProgram(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.Fpgm;
            DirectoryEntry = fontData.TableDictionary[TableTagNames.Fpgm];
            Read();
        }

        public void Read()
        {
            try
            {
                int length = DirectoryEntry.Length;
                bytes = new byte[length];
                for (int idx = 0; idx < length; idx++)
                    bytes[idx] = _fontData.ReadByte();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class ControlValueProgram : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.Prep;

        byte[] bytes;

        public ControlValueProgram(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.Prep;
            DirectoryEntry = fontData.TableDictionary[TableTagNames.Prep];
            Read();
        }

        public void Read()
        {
            try
            {
                int length = DirectoryEntry.Length;
                bytes = new byte[length];
                for (int idx = 0; idx < length; idx++)
                    bytes[idx] = _fontData.ReadByte();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }

    internal class GlyphSubstitutionTable : OpenTypeFontTable
    {
        public const string Tag = TableTagNames.GSUB;

        public GlyphSubstitutionTable(OpenTypeFontface fontData)
            : base(fontData, Tag)
        {
            DirectoryEntry.Tag = TableTagNames.GSUB;
            DirectoryEntry = fontData.TableDictionary[TableTagNames.GSUB];
            Read();
        }

        public void Read()
        {
            try
            {
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException(PSSR.ErrorReadingFontData, ex);
            }
        }
    }
    internal class OpenTypeFontWriter : FontWriter
    {
        public OpenTypeFontWriter(Stream stream)
            : base(stream)
        { }

        public void WriteTag(string tag)
        {
            Debug.Assert(tag.Length == 4);
            WriteByte((byte)(tag[0]));
            WriteByte((byte)(tag[1]));
            WriteByte((byte)(tag[2]));
            WriteByte((byte)(tag[3]));
        }
    }
    internal class TableDirectoryEntry
    {
        public TableDirectoryEntry()
        { }

        public TableDirectoryEntry(string tag)
        {
            Debug.Assert(tag.Length == 4);
            Tag = tag;
        }

        public string Tag;

        public uint CheckSum;

        public int Offset;

        public int Length;

        public int PaddedLength
        {
            get { return (Length + 3) & ~3; }
        }

        public OpenTypeFontTable FontTable;

        public static TableDirectoryEntry ReadFrom(OpenTypeFontface fontData)
        {
            TableDirectoryEntry entry = new TableDirectoryEntry();
            entry.Tag = fontData.ReadTag();
            entry.CheckSum = fontData.ReadULong();
            entry.Offset = fontData.ReadLong();
            entry.Length = (int)fontData.ReadULong();
            return entry;
        }

        public void Read(OpenTypeFontface fontData)
        {
            Tag = fontData.ReadTag();
            CheckSum = fontData.ReadULong();
            Offset = fontData.ReadLong();
            Length = (int)fontData.ReadULong();
        }

        public void Write(OpenTypeFontWriter writer)
        {
            Debug.Assert(Tag.Length == 4);
            Debug.Assert(Offset != 0);
            Debug.Assert(Length != 0);
            writer.WriteTag(Tag);
            writer.WriteUInt(CheckSum);
            writer.WriteInt(Offset);
            writer.WriteUInt((uint)Length);
        }
    }
    internal static class Calc
    {
        public const double Deg2Rad = Math.PI / 180;

        public static XSize PageSizeToSize(PageSize value)
        {
            switch (value)
            {
                case PageSize.A0:
                    return new XSize(2380, 3368);

                case PageSize.A1:
                    return new XSize(1684, 2380);

                case PageSize.A2:
                    return new XSize(1190, 1684);

                case PageSize.A3:
                    return new XSize(842, 1190);

                case PageSize.A4:
                    return new XSize(595, 842);

                case PageSize.A5:
                    return new XSize(420, 595);

                case PageSize.B4:
                    return new XSize(729, 1032);

                case PageSize.B5:
                    return new XSize(516, 729);

                case PageSize.Letter:
                    return new XSize(612, 792);

                case PageSize.Legal:
                    return new XSize(612, 1008);

                case PageSize.Tabloid:
                    return new XSize(792, 1224);

                case PageSize.Ledger:
                    return new XSize(1224, 792);

                case PageSize.Statement:
                    return new XSize(396, 612);

                case PageSize.Executive:
                    return new XSize(540, 720);

                case PageSize.Folio:
                    return new XSize(612, 936);

                case PageSize.Quarto:
                    return new XSize(610, 780);

                case PageSize.Size10x14:
                    return new XSize(720, 1008);
            }
            throw new ArgumentException("Invalid PageSize.");
        }
    }
    struct SColor
    {
        public byte a;
        public byte r;
        public byte g;
        public byte b;
    }

    struct SCColor
    {
        public float a;
        public float r;
        public float g;
        public float b;
    }

    static class ColorHelper
    {
        public static float sRgbToScRgb(byte bval)
        {
            float num = ((float)bval) / 255f;
            if (num <= 0.0)
                return 0f;
            if (num <= 0.04045)
                return (num / 12.92f);
            if (num < 1f)
                return (float)Math.Pow((num + 0.055) / 1.055, 2.4);
            return 1f;
        }

        public static byte ScRgbTosRgb(float val)
        {
            if (val <= 0.0)
                return 0;
            if (val <= 0.0031308)
                return (byte)(((255f * val) * 12.92f) + 0.5f);
            if (val < 1.0)
                return (byte)((255f * ((1.055f * ((float)Math.Pow((double)val, 0.41666666666666669))) - 0.055f)) + 0.5f);
            return 0xff;
        }
    }
    enum NotImplementedBehaviour
    {
        DoNothing, Log, Throw
    }

    internal static class Diagnostics
    {
        public static NotImplementedBehaviour NotImplementedBehaviour
        {
            get { return _notImplementedBehaviour; }
            set { _notImplementedBehaviour = value; }
        }
        static NotImplementedBehaviour _notImplementedBehaviour;
    }

    internal static class ParserDiagnostics
    {
        public static void ThrowParserException(string message)
        {
            throw new PdfReaderException(message);
        }

        public static void ThrowParserException(string message, Exception innerException)
        {
            throw new PdfReaderException(message, innerException);
        }

        public static void HandleUnexpectedCharacter(char ch)
        {
            string message = string.Format(CultureInfo.InvariantCulture,
                "Unexpected character '0x{0:x4}' in PDF stream. The file may be corrupted. " +
                "If you think this is a bug in PDFsharp, please send us your PDF file.", (int)ch);
            ThrowParserException(message);
        }
        public static void HandleUnexpectedToken(string token)
        {
            string message = string.Format(CultureInfo.InvariantCulture,
                "Unexpected token '{0}' in PDF stream. The file may be corrupted. " +
                "If you think this is a bug in PDFsharp, please send us your PDF file.", token);
            ThrowParserException(message);
        }
    }

    internal static class ContentReaderDiagnostics
    {
        public static void ThrowContentReaderException(string message)
        {
            throw new ContentReaderException(message);
        }

        public static void ThrowContentReaderException(string message, Exception innerException)
        {
            throw new ContentReaderException(message, innerException);
        }

        public static void ThrowNumberOutOfIntegerRange(long value)
        {
            string message = string.Format(CultureInfo.InvariantCulture, "Number '{0}' out of integer range.", value);
            ThrowContentReaderException(message);
        }

        public static void HandleUnexpectedCharacter(char ch)
        {
            string message = string.Format(CultureInfo.InvariantCulture,
                "Unexpected character '0x{0:x4}' in content stream. The stream may be corrupted or the feature is not implemented. " +
                "If you think this is a bug in PDFsharp, please send us your PDF file.", (int)ch);
            ThrowContentReaderException(message);
        }
    }
    internal static class DiagnosticsHelper
    {
        public static void HandleNotImplemented(string message)
        {
            string text = "Not implemented: " + message;
            switch (Diagnostics.NotImplementedBehaviour)
            {
                case NotImplementedBehaviour.DoNothing:
                    break;

                case NotImplementedBehaviour.Log:
                    Logger.Log(text);
                    break;

                case NotImplementedBehaviour.Throw:
                    ThrowNotImplementedException(text);
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public static void ThrowNotImplementedException(string message)
        {
            throw new NotImplementedException(message);
        }
    }

    internal static class Logger
    {
        public static void Log(string format, params object[] args)
        {
            Debug.WriteLine("Log...");
        }
    }

    class Logging
    {

    }

    class Tracing
    {
        [Conditional("DEBUG")]
        public void Foo()
        { }
    }

    public static class DebugBreak
    {
        public static void Break()
        {
            Break(false);
        }

        public static void Break(bool always)
        {
        }
    }

    public static class FontsDevHelper
    {
        public static XFont CreateSpecialFont(string familyName, double emSize, XFontStyle style,
            XPdfFontOptions pdfOptions, XStyleSimulations styleSimulations)
        {
            return new XFont(familyName, emSize, style, pdfOptions, styleSimulations);
        }

        public static string GetFontCachesState()
        {
            return FontFactory.GetFontCachesState();
        }
    }
    internal static class DoubleUtil
    {
        const double Epsilon = 2.2204460492503131E-16;
        private const double TenTimesEpsilon = 10.0 * Epsilon;
        const float FloatMinimum = 1.175494E-38f;

        public static bool AreClose(double value1, double value2)
        {
            if (value1.Equals(value2))
                return true;
            double eps = (Math.Abs(value1) + Math.Abs(value2) + 10.0) * Epsilon;
            double delta = value1 - value2;
            return (-eps < delta) && (eps > delta);
        }

        public static bool AreRoughlyEqual(double value1, double value2, int decimalPlace)
        {
            if (value1 == value2)
                return true;
            return Math.Abs(value1 - value2) < decs[decimalPlace];
        }
        static readonly double[] decs = { 1, 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9, 1E-10, 1E-11, 1E-12, 1E-13, 1E-14, 1E-15, 1E-16 };

        public static bool AreClose(XPoint point1, XPoint point2)
        {
            return AreClose(point1.X, point2.X) && AreClose(point1.Y, point2.Y);
        }

        public static bool AreClose(XRect rect1, XRect rect2)
        {
            if (rect1.IsEmpty)
                return rect2.IsEmpty;
            return !rect2.IsEmpty && AreClose(rect1.X, rect2.X) && AreClose(rect1.Y, rect2.Y) &&
              AreClose(rect1.Height, rect2.Height) && AreClose(rect1.Width, rect2.Width);
        }

        public static bool AreClose(XSize size1, XSize size2)
        {
            return AreClose(size1.Width, size2.Width) && AreClose(size1.Height, size2.Height);
        }

        public static bool AreClose(XVector vector1, XVector vector2)
        {
            return AreClose(vector1.X, vector2.X) && AreClose(vector1.Y, vector2.Y);
        }

        public static bool GreaterThan(double value1, double value2)
        {
            return value1 > value2 && !AreClose(value1, value2);
        }

        public static bool GreaterThanOrClose(double value1, double value2)
        {
            return value1 > value2 || AreClose(value1, value2);
        }

        public static bool LessThan(double value1, double value2)
        {
            return value1 < value2 && !AreClose(value1, value2);
        }

        public static bool LessThanOrClose(double value1, double value2)
        {
            return value1 < value2 || AreClose(value1, value2);
        }

        public static bool IsBetweenZeroAndOne(double value)
        {
            return GreaterThanOrClose(value, 0) && LessThanOrClose(value, 1);
        }

        public static bool IsNaN(double value)
        {
            NanUnion t = new NanUnion();
            t.DoubleValue = value;

            ulong exp = t.UintValue & 0xfff0000000000000;
            ulong man = t.UintValue & 0x000fffffffffffff;

            return (exp == 0x7ff0000000000000 || exp == 0xfff0000000000000) && (man != 0);
        }

        public static bool RectHasNaN(XRect r)
        {
            return IsNaN(r.X) || IsNaN(r.Y) || IsNaN(r.Height) || IsNaN(r.Width);
        }

        public static bool IsOne(double value)
        {
            return Math.Abs(value - 1.0) < TenTimesEpsilon;
        }

        public static bool IsZero(double value)
        {
            return Math.Abs(value) < TenTimesEpsilon;
        }

        public static int DoubleToInt(double value)
        {
            return 0 < value ? (int)(value + 0.5) : (int)(value - 0.5);
        }

        [StructLayout(LayoutKind.Explicit)]
        struct NanUnion
        {
            [FieldOffset(0)]
            internal double DoubleValue;
            [FieldOffset(0)]
            internal readonly ulong UintValue;
        }
    }
    internal static class Lock
    {
        public static void EnterGdiPlus()
        {
            Monitor.Enter(GdiPlus);
            _gdiPlusLockCount++;
        }

        public static void ExitGdiPlus()
        {
            _gdiPlusLockCount--;
            Monitor.Exit(GdiPlus);
        }

        static readonly object GdiPlus = new object();
        static int _gdiPlusLockCount;

        public static void EnterFontFactory()
        {
            Monitor.Enter(FontFactory);
            _fontFactoryLockCount++;
        }

        public static void ExitFontFactory()
        {
            _fontFactoryLockCount--;
            Monitor.Exit(FontFactory);
        }
        static readonly object FontFactory = new object();
        [ThreadStatic]
        static int _fontFactoryLockCount;
    }
    static class NativeMethods
    {
        public const int GDI_ERROR = -1;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public class LOGFONT
        {
            LOGFONT(int dummy)
            {
                lfHeight = 0;
                lfWidth = 0;
                lfEscapement = 0;
                lfOrientation = 0;
                lfWeight = 0;
                lfItalic = 0;
                lfUnderline = 0;
                lfStrikeOut = 0;
                lfCharSet = 0;
                lfOutPrecision = 0;
                lfClipPrecision = 0;
                lfQuality = 0;
                lfPitchAndFamily = 0;
                lfFaceName = "";
            }
            public int lfHeight;
            public int lfWidth;
            public int lfEscapement;
            public int lfOrientation;
            public int lfWeight;
            public byte lfItalic;
            public byte lfUnderline;
            public byte lfStrikeOut;
            public byte lfCharSet;
            public byte lfOutPrecision;
            public byte lfClipPrecision;
            public byte lfQuality;
            public byte lfPitchAndFamily;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string lfFaceName;
            public override string ToString()
            {
                object[] objArray1 = new object[0x1c]
                {
                    "lfHeight=", lfHeight,
                    ", lfWidth=", lfWidth,
                    ", lfEscapement=", lfEscapement,
                    ", lfOrientation=", lfOrientation,
                    ", lfWeight=", lfWeight,
                    ", lfItalic=", lfItalic,
                    ", lfUnderline=", lfUnderline,
                    ", lfStrikeOut=", lfStrikeOut,
                    ", lfCharSet=", lfCharSet,
                    ", lfOutPrecision=", lfOutPrecision,
                    ", lfClipPrecision=", lfClipPrecision,
                    ", lfQuality=", lfQuality,
                    ", lfPitchAndFamily=", lfPitchAndFamily,
                    ", lfFaceName=", lfFaceName
                };
                return string.Concat(objArray1);
            }
            public LOGFONT() { }
        }

        [DllImport("user32.dll")]
        public static extern IntPtr GetDC(IntPtr hwnd);

        [DllImport("user32.dll")]
        public static extern IntPtr ReleaseDC(IntPtr hwnd, IntPtr hdc);

        [DllImport("gdi32.dll", SetLastError = true)]
        public static extern int GetFontData(
            IntPtr hdc,
            uint dwTable,
            uint dwOffset,
            byte[] lpvBuffer,
            int cbData
            );

        [DllImport("gdi32.dll", SetLastError = true)]
        public static extern IntPtr CreateDC(
            string driver,
            string device,
            string port,
            IntPtr data
            );

        [DllImport("gdi32.dll", SetLastError = true)]
        public static extern IntPtr CreateCompatibleDC(IntPtr hdc);

        [DllImport("gdi32.dll", EntryPoint = "CreateFontIndirectW")]
        public static extern IntPtr CreateFontIndirect(LOGFONT lpLogFont);

        [DllImport("gdi32.dll")]
        public static extern IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);

        [DllImport("gdi32.dll")]
        public static extern bool DeleteObject(IntPtr hgdiobj);

        public const int HORZSIZE = 4;
        public const int VERTSIZE = 6;
        public const int HORZRES = 8;
        public const int VERTRES = 10;
        public const int LOGPIXELSX = 88;
        public const int LOGPIXELSY = 90;
        [DllImport("gdi32.dll")]
        public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);
    }
    class TokenizerHelper
    {
        public TokenizerHelper(string str, IFormatProvider formatProvider)
        {
            char numericListSeparator = GetNumericListSeparator(formatProvider);
            Initialize(str, '\'', numericListSeparator);
        }

        public TokenizerHelper(string str, char quoteChar, char separator)
        {
            Initialize(str, quoteChar, separator);
        }

        void Initialize(string str, char quoteChar, char separator)
        {
            _str = str;
            _strLen = str == null ? 0 : str.Length;
            _currentTokenIndex = -1;
            _quoteChar = quoteChar;
            _argSeparator = separator;

            while (_charIndex < _strLen)
            {
                if (!char.IsWhiteSpace(_str, _charIndex))
                    return;
                _charIndex++;
            }
        }

        public string NextTokenRequired()
        {
            if (!NextToken(false))
                throw new InvalidOperationException("PrematureStringTermination");
            return GetCurrentToken();
        }

        public string NextTokenRequired(bool allowQuotedToken)
        {
            if (!NextToken(allowQuotedToken))
                throw new InvalidOperationException("PrematureStringTermination");
            return GetCurrentToken();
        }

        public string GetCurrentToken()
        {
            if (_currentTokenIndex < 0)
                return null;
            return _str.Substring(_currentTokenIndex, _currentTokenLength);
        }

        public void LastTokenRequired()
        {
            if (_charIndex != _strLen)
                throw new InvalidOperationException("Extra data encountered");
        }

        public bool NextToken()
        {
            return NextToken(false);
        }

        public bool NextToken(bool allowQuotedToken)
        {
            return NextToken(allowQuotedToken, _argSeparator);
        }

        public bool NextToken(bool allowQuotedToken, char separator)
        {
            _currentTokenIndex = -1;
            _foundSeparator = false;

            if (_charIndex >= _strLen)
                return false;

            char currentChar = _str[_charIndex];

            int quoteCount = 0;

            if (allowQuotedToken &&
                currentChar == _quoteChar)
            {
                quoteCount++;
                _charIndex++;
            }

            int newTokenIndex = _charIndex;
            int newTokenLength = 0;

            while (_charIndex < _strLen)
            {
                currentChar = _str[_charIndex];

                if (quoteCount > 0)
                {
                    if (currentChar == _quoteChar)
                    {
                        quoteCount--;

                        if (quoteCount == 0)
                        {
                            ++_charIndex;
                            break;
                        }
                    }
                }
                else if ((char.IsWhiteSpace(currentChar)) || (currentChar == separator))
                {
                    if (currentChar == separator)
                        _foundSeparator = true;
                    break;
                }

                _charIndex++;
                newTokenLength++;
            }

            if (quoteCount > 0)
                throw new InvalidOperationException("Missing end quote");

            ScanToNextToken(separator);

            _currentTokenIndex = newTokenIndex;
            _currentTokenLength = newTokenLength;

            if (_currentTokenLength < 1)
                throw new InvalidOperationException("Empty token");

            return true;
        }

        private void ScanToNextToken(char separator)
        {
            if (_charIndex < _strLen)
            {
                char currentChar = _str[_charIndex];

                if (currentChar != separator && !char.IsWhiteSpace(currentChar))
                    throw new InvalidOperationException("ExtraDataEncountered");

                int argSepCount = 0;
                while (_charIndex < _strLen)
                {
                    currentChar = _str[_charIndex];
                    if (currentChar == separator)
                    {
                        _foundSeparator = true;
                        argSepCount++;
                        _charIndex++;

                        if (argSepCount > 1)
                            throw new InvalidOperationException("EmptyToken");
                    }
                    else if (char.IsWhiteSpace(currentChar))
                    {
                        ++_charIndex;
                    }
                    else
                        break;
                }

                if (argSepCount > 0 && _charIndex >= _strLen)
                    throw new InvalidOperationException("EmptyToken");
            }
        }

        public static char GetNumericListSeparator(IFormatProvider provider)
        {
            char numericSeparator = ',';
            NumberFormatInfo numberFormat = NumberFormatInfo.GetInstance(provider);
            if (numberFormat.NumberDecimalSeparator.Length > 0 && numericSeparator == numberFormat.NumberDecimalSeparator[0])
                numericSeparator = ';';
            return numericSeparator;
        }

        public bool FoundSeparator
        {
            get { return _foundSeparator; }
        }
        bool _foundSeparator;

        char _argSeparator;
        int _charIndex;
        int _currentTokenIndex;
        int _currentTokenLength;
        char _quoteChar;
        string _str;
        int _strLen;
    }
    enum DocumentState
    {
        Created = 0x0001,

        Imported = 0x0002,

        Disposed = 0x8000,
    }
    public enum PdfColorMode
    {
        Undefined,

        Rgb,

        Cmyk,
    }
    public enum PdfCustomValueCompressionMode
    {
        Default,

        Uncompressed,

        Compressed,
    }
    public enum PdfFlateEncodeMode
    {
        Default,

        BestSpeed,

        BestCompression,
    }
    public enum PdfFontEmbedding
    {
        Always,

        [Obsolete("Fonts must always be embedded.")]
        None,

        [Obsolete("Fonts must always be embedded.")]
        Default,

        [Obsolete("Fonts must always be embedded.")]
        Automatic,
    }
    public enum PdfFontEncoding
    {
        WinAnsi = 0,

        Unicode = 1,

        [Obsolete("Use WinAnsi or Unicode")]
        Automatic = 1,

    }
    public enum PdfOutlineStyle
    {
        Regular = 0,

        Italic = 1,

        Bold = 2,

        BoldItalic = 3,
    }
    public enum PdfPageDestinationType
    {
        Xyz,

        Fit,

        FitH,

        FitV,

        FitR,

        FitB,

        FitBH,

        FitBV,
    }
    public enum PdfPageLayout
    {
        SinglePage,

        OneColumn,

        TwoColumnLeft,

        TwoColumnRight,

        TwoPageLeft,

        TwoPageRight,
    }
    public enum PdfPageMode
    {
        UseNone,

        UseOutlines,

        UseThumbs,

        FullScreen,

        UseOC,

        UseAttachments,
    }
    public enum PdfReadingDirection
    {
        LeftToRight,

        RightToLeft,
    }
    public enum PdfTextStringEncoding
    {
        PDFDocEncoding = 0,

        Unicode = 1,
    }
    public enum PdfUseFlateDecoderForJpegImages
    {
        Automatic,

        Never,

        Always,
    }
    internal enum KeyType
    {
        Name = 0x00000001,
        String = 0x00000002,
        Boolean = 0x00000003,
        Integer = 0x00000004,
        Real = 0x00000005,
        Date = 0x00000006,
        Rectangle = 0x00000007,
        Array = 0x00000008,
        Dictionary = 0x00000009,
        Stream = 0x0000000A,
        NumberTree = 0x0000000B,
        Function = 0x0000000C,
        TextString = 0x0000000D,
        ByteString = 0x0000000E,

        NameOrArray = 0x00000010,
        NameOrDictionary = 0x00000020,
        ArrayOrDictionary = 0x00000030,
        StreamOrArray = 0x00000040,
        StreamOrName = 0x00000050,
        ArrayOrNameOrString = 0x00000060,
        FunctionOrName = 0x000000070,
        Various = 0x000000080,

        TypeMask = 0x000000FF,

        Optional = 0x00000100,
        Required = 0x00000200,
        Inheritable = 0x00000400,
        MustBeIndirect = 0x00001000,
        MustNotBeIndirect = 0x00002000,
    }
    internal class KeyInfoAttribute : Attribute
    {
        public KeyInfoAttribute()
        { }

        public KeyInfoAttribute(KeyType keyType)
        {
            KeyType = keyType;
        }

        public KeyInfoAttribute(string version, KeyType keyType)
        {
            _version = version;
            KeyType = keyType;
        }

        public KeyInfoAttribute(KeyType keyType, Type objectType)
        {
            KeyType = keyType;
            _objectType = objectType;
        }

        public KeyInfoAttribute(string version, KeyType keyType, Type objectType)
        {
            KeyType = keyType;
            _objectType = objectType;
        }

        public string Version
        {
            get { return _version; }
            set { _version = value; }
        }
        string _version = "1.0";

        public KeyType KeyType
        {
            get { return _entryType; }
            set { _entryType = value; }
        }
        KeyType _entryType;

        public Type ObjectType
        {
            get { return _objectType; }
            set { _objectType = value; }
        }
        Type _objectType;

        public string FixedValue
        {
            get { return _fixedValue; }
            set { _fixedValue = value; }
        }
        string _fixedValue;
    }
    public class KeysBase
    {
        internal static DictionaryMeta CreateMeta(Type type)
        {
            return new DictionaryMeta(type);
        }
    }
    internal sealed class KeyDescriptor
    {
        public KeyDescriptor(KeyInfoAttribute attribute)
        {
            _version = attribute.Version;
            _keyType = attribute.KeyType;
            _fixedValue = attribute.FixedValue;
            _objectType = attribute.ObjectType;

            if (_version == "")
                _version = "1.0";
        }

        public string Version
        {
            get { return _version; }
            set { _version = value; }
        }
        string _version;

        public KeyType KeyType
        {
            get { return _keyType; }
            set { _keyType = value; }
        }
        KeyType _keyType;

        public string KeyValue
        {
            get { return _keyValue; }
            set { _keyValue = value; }
        }
        string _keyValue;

        public string FixedValue
        {
            get { return _fixedValue; }
        }
        readonly string _fixedValue;

        public Type ObjectType
        {
            get { return _objectType; }
            set { _objectType = value; }
        }
        Type _objectType;

        public bool CanBeIndirect
        {
            get { return (_keyType & KeyType.MustNotBeIndirect) == 0; }
        }

        public Type GetValueType()
        {
            Type type = _objectType;
            if (type == null)
            {
                switch (_keyType & KeyType.TypeMask)
                {
                    case KeyType.Name:
                        type = typeof(PdfName);
                        break;

                    case KeyType.String:
                        type = typeof(PdfString);
                        break;

                    case KeyType.Boolean:
                        type = typeof(PdfBoolean);
                        break;

                    case KeyType.Integer:
                        type = typeof(PdfInteger);
                        break;

                    case KeyType.Real:
                        type = typeof(PdfReal);
                        break;

                    case KeyType.Date:
                        type = typeof(PdfDate);
                        break;

                    case KeyType.Rectangle:
                        type = typeof(PdfRectangle);
                        break;

                    case KeyType.Array:
                        type = typeof(PdfArray);
                        break;

                    case KeyType.Dictionary:
                        type = typeof(PdfDictionary);
                        break;

                    case KeyType.Stream:
                        type = typeof(PdfDictionary);
                        break;

                    case KeyType.NumberTree:
                        throw new NotImplementedException("KeyType.NumberTree");

                    case KeyType.NameOrArray:
                        throw new NotImplementedException("KeyType.NameOrArray");

                    case KeyType.ArrayOrDictionary:
                        throw new NotImplementedException("KeyType.ArrayOrDictionary");

                    case KeyType.StreamOrArray:
                        throw new NotImplementedException("KeyType.StreamOrArray");

                    case KeyType.ArrayOrNameOrString:
                        return null;
                    default:
                        Debug.Assert(false, "Invalid KeyType: " + _keyType);
                        break;
                }
            }
            return type;
        }
    }
    internal class DictionaryMeta
    {
        public DictionaryMeta(Type type)
        {
#if !NETFX_CORE && !UWP
            FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);
            foreach (FieldInfo field in fields)
            {
                object[] attributes = field.GetCustomAttributes(typeof(KeyInfoAttribute), false);
                if (attributes.Length == 1)
                {
                    KeyInfoAttribute attribute = (KeyInfoAttribute)attributes[0];
                    KeyDescriptor descriptor = new KeyDescriptor(attribute);
                    descriptor.KeyValue = (string)field.GetValue(null);
                    _keyDescriptors[descriptor.KeyValue] = descriptor;
                }
            }
#endif
        }

        public KeyDescriptor this[string key]
        {
            get
            {
                KeyDescriptor keyDescriptor;
                _keyDescriptors.TryGetValue(key, out keyDescriptor);
                return keyDescriptor;
            }
        }

        readonly Dictionary<string, KeyDescriptor> _keyDescriptors = new Dictionary<string, KeyDescriptor>();
    }
    public class PdfArray : PdfObject, IEnumerable<PdfItem>
    {
        public PdfArray()
        { }

        public PdfArray(PdfDocument document)
            : base(document)
        { }

        public PdfArray(PdfDocument document, params PdfItem[] items)
            : base(document)
        {
            foreach (PdfItem item in items)
                Elements.Add(item);
        }

        protected PdfArray(PdfArray array)
            : base(array)
        {
            if (array._elements != null)
                array._elements.ChangeOwner(this);
        }

        public new PdfArray Clone()
        {
            return (PdfArray)Copy();
        }

        protected override object Copy()
        {
            PdfArray array = (PdfArray)base.Copy();
            if (array._elements != null)
            {
                array._elements = array._elements.Clone();
                int count = array._elements.Count;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfItem item = array._elements[idx];
                    if (item is PdfObject)
                        array._elements[idx] = item.Clone();
                }
            }
            return array;
        }

        public ArrayElements Elements
        {
            get { return _elements ?? (_elements = new ArrayElements(this)); }
        }

        public virtual IEnumerator<PdfItem> GetEnumerator()
        {
            return Elements.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override string ToString()
        {
            StringBuilder pdf = new StringBuilder();
            pdf.Append("[ ");
            int count = Elements.Count;
            for (int idx = 0; idx < count; idx++)
                pdf.Append(Elements[idx] + " ");
            pdf.Append("]");
            return pdf.ToString();
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            int count = Elements.Count;
            for (int idx = 0; idx < count; idx++)
            {
                PdfItem value = Elements[idx];
                value.WriteObject(writer);
            }
            writer.WriteEndObject();
        }

        public sealed class ArrayElements : IList<PdfItem>, ICloneable
        {
            internal ArrayElements(PdfArray array)
            {
                _elements = new List<PdfItem>();
                _ownerArray = array;
            }

            object ICloneable.Clone()
            {
                ArrayElements elements = (ArrayElements)MemberwiseClone();
                elements._elements = new List<PdfItem>(elements._elements);
                elements._ownerArray = null;
                return elements;
            }

            public ArrayElements Clone()
            {
                return (ArrayElements)((ICloneable)this).Clone();
            }

            internal void ChangeOwner(PdfArray array)
            {
                if (_ownerArray != null)
                {
                }

                _ownerArray = array;

                array._elements = this;
            }

            public bool GetBoolean(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                object obj = this[index];
                if (obj == null)
                    return false;

                PdfBoolean boolean = obj as PdfBoolean;
                if (boolean != null)
                    return boolean.Value;

                PdfBooleanObject booleanObject = obj as PdfBooleanObject;
                if (booleanObject != null)
                    return booleanObject.Value;

                throw new InvalidCastException("GetBoolean: Object is not a boolean.");
            }

            public int GetInteger(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                object obj = this[index];
                if (obj == null)
                    return 0;

                PdfInteger integer = obj as PdfInteger;
                if (integer != null)
                    return integer.Value;

                PdfIntegerObject integerObject = obj as PdfIntegerObject;
                if (integerObject != null)
                    return integerObject.Value;

                throw new InvalidCastException("GetInteger: Object is not an integer.");
            }

            public double GetReal(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                object obj = this[index];
                if (obj == null)
                    return 0;

                PdfReal real = obj as PdfReal;
                if (real != null)
                    return real.Value;

                PdfRealObject realObject = obj as PdfRealObject;
                if (realObject != null)
                    return realObject.Value;

                PdfInteger integer = obj as PdfInteger;
                if (integer != null)
                    return integer.Value;

                PdfIntegerObject integerObject = obj as PdfIntegerObject;
                if (integerObject != null)
                    return integerObject.Value;

                throw new InvalidCastException("GetReal: Object is not a number.");
            }

            public double? GetNullableReal(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                object obj = this[index];
                if (obj == null)
                    return null;

                PdfNull @null = obj as PdfNull;
                if (@null != null)
                    return null;

                PdfNullObject nullObject = obj as PdfNullObject;
                if (nullObject != null)
                    return null;

                PdfReal real = obj as PdfReal;
                if (real != null)
                    return real.Value;

                PdfRealObject realObject = obj as PdfRealObject;
                if (realObject != null)
                    return realObject.Value;

                PdfInteger integer = obj as PdfInteger;
                if (integer != null)
                    return integer.Value;

                PdfIntegerObject integerObject = obj as PdfIntegerObject;
                if (integerObject != null)
                    return integerObject.Value;

                throw new InvalidCastException("GetReal: Object is not a number.");
            }

            public string GetString(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                object obj = this[index];
                if (obj == null)
                    return String.Empty;

                PdfString str = obj as PdfString;
                if (str != null)
                    return str.Value;

                PdfStringObject strObject = obj as PdfStringObject;
                if (strObject != null)
                    return strObject.Value;

                throw new InvalidCastException("GetString: Object is not a string.");
            }

            public string GetName(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                object obj = this[index];
                if (obj == null)
                    return String.Empty;

                PdfName name = obj as PdfName;
                if (name != null)
                    return name.Value;

                PdfNameObject nameObject = obj as PdfNameObject;
                if (nameObject != null)
                    return nameObject.Value;

                throw new InvalidCastException("GetName: Object is not a name.");
            }

            [Obsolete("Use GetObject, GetDictionary, GetArray, or GetReference")]
            public PdfObject GetIndirectObject(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                PdfReference reference = this[index] as PdfReference;
                if (reference != null)
                    return reference.Value;

                return null;
            }

            public PdfObject GetObject(int index)
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.IndexOutOfRange);

                PdfItem item = this[index];
                PdfReference reference = item as PdfReference;
                if (reference != null)
                    return reference.Value;

                return item as PdfObject;
            }

            public PdfDictionary GetDictionary(int index)
            {
                return GetObject(index) as PdfDictionary;
            }

            public PdfArray GetArray(int index)
            {
                return GetObject(index) as PdfArray;
            }

            public PdfReference GetReference(int index)
            {
                PdfItem item = this[index];
                return item as PdfReference;
            }

            public PdfItem[] Items
            {
                get { return _elements.ToArray(); }
            }

            public bool IsReadOnly
            {
                get { return false; }
            }

            public PdfItem this[int index]
            {
                get { return _elements[index]; }
                set
                {
                    if (value == null)
                        throw new ArgumentNullException("value");
                    _elements[index] = value;
                }
            }

            public void RemoveAt(int index)
            {
                _elements.RemoveAt(index);
            }

            public bool Remove(PdfItem item)
            {
                return _elements.Remove(item);
            }

            public void Insert(int index, PdfItem value)
            {
                _elements.Insert(index, value);
            }

            public bool Contains(PdfItem value)
            {
                return _elements.Contains(value);
            }

            public void Clear()
            {
                _elements.Clear();
            }

            public int IndexOf(PdfItem value)
            {
                return _elements.IndexOf(value);
            }

            public void Add(PdfItem value)
            {
                PdfObject obj = value as PdfObject;
                if (obj != null && obj.IsIndirect)
                    _elements.Add(obj.Reference);
                else
                    _elements.Add(value);
            }

            public bool IsFixedSize
            {
                get { return false; }
            }

            public bool IsSynchronized
            {
                get { return false; }
            }

            public int Count
            {
                get { return _elements.Count; }
            }

            public void CopyTo(PdfItem[] array, int index)
            {
                _elements.CopyTo(array, index);
            }

            public object SyncRoot
            {
                get { return null; }
            }

            public IEnumerator<PdfItem> GetEnumerator()
            {
                return _elements.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return _elements.GetEnumerator();
            }

            List<PdfItem> _elements;

            PdfArray _ownerArray;
        }

        ArrayElements _elements;

        string DebuggerDisplay
        {
            get
            {
#if true
                return String.Format(CultureInfo.InvariantCulture, "array({0},[{1}])", ObjectID.DebuggerDisplay, _elements == null ? 0 : _elements.Count);
#endif
            }
        }
    }
    public sealed class PdfBoolean : PdfItem
    {
        public PdfBoolean()
        { }

        public PdfBoolean(bool value)
        {
            _value = value;
        }

        public bool Value
        {
            get { return _value; }
        }
        readonly bool _value;

        public static readonly PdfBoolean True = new PdfBoolean(true);

        public static readonly PdfBoolean False = new PdfBoolean(false);

        public override string ToString()
        {
            return _value ? bool.TrueString : bool.FalseString;
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }
    }
    public sealed class PdfBooleanObject : PdfObject
    {
        public PdfBooleanObject()
        { }

        public PdfBooleanObject(bool value)
        {
            _value = value;
        }

        public PdfBooleanObject(PdfDocument document, bool value)
            : base(document)
        {
            _value = value;
        }

        public bool Value
        {
            get { return _value; }
        }

        readonly bool _value;

        public override string ToString()
        {
            return _value ? bool.TrueString : bool.FalseString;
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.Write(_value);
            writer.WriteEndObject();
        }
    }
    public class PdfCustomValue : PdfDictionary
    {
        public PdfCustomValue()
        {
            CreateStream(new byte[] { });
        }

        public PdfCustomValue(byte[] bytes)
        {
            CreateStream(bytes);
        }

        internal PdfCustomValue(PdfDocument document)
            : base(document)
        {
            CreateStream(new byte[] { });
        }

        internal PdfCustomValue(PdfDictionary dict)
            : base(dict)
        {
        }

        public PdfCustomValueCompressionMode CompressionMode;

        public byte[] Value
        {
            get { return Stream.Value; }
            set { Stream.Value = value; }
        }
    }
    public class PdfCustomValues : PdfDictionary
    {
        internal PdfCustomValues()
        { }

        internal PdfCustomValues(PdfDocument document)
            : base(document)
        { }

        internal PdfCustomValues(PdfDictionary dict)
            : base(dict)
        { }

        public PdfCustomValueCompressionMode CompressionMode
        {
            set { throw new NotImplementedException(); }
        }

        public bool Contains(string key)
        {
            return Elements.ContainsKey(key);
        }

        public PdfCustomValue this[string key]
        {
            get
            {
                PdfDictionary dict = Elements.GetDictionary(key);
                if (dict == null)
                    return null;
                PdfCustomValue cust = dict as PdfCustomValue;
                if (cust == null)
                    cust = new PdfCustomValue(dict);
                return cust;
            }
            set
            {
                if (value == null)
                {
                    Elements.Remove(key);
                }
                else
                {
                    Owner.Internals.AddObject(value);
                    Elements.SetReference(key, value);
                }
            }
        }

        public static void ClearAllCustomValues(PdfDocument document)
        {
            document.CustomValues = null;
            foreach (PdfPage page in document.Pages)
                page.CustomValues = null;
        }

        internal static PdfCustomValues Get(DictionaryElements elem)
        {
            string key = elem.Owner.Owner.Internals.CustomValueKey;
            PdfCustomValues customValues;
            PdfDictionary dict = elem.GetDictionary(key);
            if (dict == null)
            {
                customValues = new PdfCustomValues();
                elem.Owner.Owner.Internals.AddObject(customValues);
                elem.Add(key, customValues);
            }
            else
            {
                customValues = dict as PdfCustomValues;
                if (customValues == null)
                    customValues = new PdfCustomValues(dict);
            }
            return customValues;
        }

        internal static void Remove(DictionaryElements elem)
        {
            elem.Remove(elem.Owner.Owner.Internals.CustomValueKey);
        }
    }
    public sealed class PdfDate : PdfItem
    {
        public PdfDate()
        { }

        public PdfDate(string value)
        {
            _value = Parser.ParseDateTime(value, DateTime.MinValue);
        }

        public PdfDate(DateTime value)
        {
            _value = value;
        }

        public DateTime Value
        {
            get { return _value; }
        }
        DateTime _value;

        public override string ToString()
        {
            string delta = _value.ToString("zzz").Replace(':', '\'');
            return String.Format("D:{0:yyyyMMddHHmmss}{1}'", _value, delta);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteDocString(ToString());
        }
    }
    public enum VCF
    {
        None,

        Create,

        CreateIndirect,
    }

    [DebuggerDisplay("{DebuggerDisplay}")]
    public class PdfDictionary : PdfObject, IEnumerable<KeyValuePair<string, PdfItem>>
    {
        public PdfDictionary()
        { }

        public PdfDictionary(PdfDocument document)
            : base(document)
        { }

        protected PdfDictionary(PdfDictionary dict)
            : base(dict)
        {
            if (dict._elements != null)
                dict._elements.ChangeOwner(this);
            if (dict._stream != null)
                dict._stream.ChangeOwner(this);
        }

        public new PdfDictionary Clone()
        {
            return (PdfDictionary)Copy();
        }

        protected override object Copy()
        {
            PdfDictionary dict = (PdfDictionary)base.Copy();
            if (dict._elements != null)
            {
                dict._elements = dict._elements.Clone();
                dict._elements.ChangeOwner(dict);
                PdfName[] names = dict._elements.KeyNames;
                foreach (PdfName name in names)
                {
                    PdfObject obj = dict._elements[name] as PdfObject;
                    if (obj != null)
                    {
                        obj = obj.Clone();
                        dict._elements[name] = obj;
                    }
                }
            }
            if (dict._stream != null)
            {
                dict._stream = dict._stream.Clone();
                dict._stream.ChangeOwner(dict);
            }
            return dict;
        }

        public DictionaryElements Elements
        {
            get { return _elements ?? (_elements = new DictionaryElements(this)); }
        }

        internal DictionaryElements _elements;

        public IEnumerator<KeyValuePair<string, PdfItem>> GetEnumerator()
        {
            return Elements.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override string ToString()
        {
            PdfName[] keys = Elements.KeyNames;
            List<PdfName> list = new List<PdfName>(keys);
            list.Sort(PdfName.Comparer);
            list.CopyTo(keys, 0);

            StringBuilder pdf = new StringBuilder();
            pdf.Append("<< ");
            foreach (PdfName key in keys)
                pdf.Append(key + " " + Elements[key] + " ");
            pdf.Append(">>");

            return pdf.ToString();
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            PdfName[] keys = Elements.KeyNames;

            foreach (PdfName key in keys)
                WriteDictionaryElement(writer, key);
            if (Stream != null)
                WriteDictionaryStream(writer);
            writer.WriteEndObject();
        }

        internal virtual void WriteDictionaryElement(PdfWriter writer, PdfName key)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            PdfItem item = Elements[key];
            key.WriteObject(writer);
            item.WriteObject(writer);
            writer.NewLine();
        }

        internal virtual void WriteDictionaryStream(PdfWriter writer)
        {
            writer.WriteStream(this, (writer.Options & PdfWriterOptions.OmitStream) == PdfWriterOptions.OmitStream);
        }

        public PdfStream Stream
        {
            get { return _stream; }
            set { _stream = value; }
        }
        PdfStream _stream;

        public PdfStream CreateStream(byte[] value)
        {
            if (_stream != null)
                throw new InvalidOperationException("The dictionary already has a stream.");

            _stream = new PdfStream(value, this);
            Elements[PdfStream.Keys.Length] = new PdfInteger(_stream.Length);
            return _stream;
        }

        internal virtual DictionaryMeta Meta
        {
            get { return null; }
        }

        [DebuggerDisplay("{DebuggerDisplay}")]
        public sealed class DictionaryElements : IDictionary<string, PdfItem>, ICloneable
        {
            internal DictionaryElements(PdfDictionary ownerDictionary)
            {
                _elements = new Dictionary<string, PdfItem>();
                _ownerDictionary = ownerDictionary;
            }

            object ICloneable.Clone()
            {
                DictionaryElements dictionaryElements = (DictionaryElements)MemberwiseClone();
                dictionaryElements._elements = new Dictionary<string, PdfItem>(dictionaryElements._elements);
                dictionaryElements._ownerDictionary = null;
                return dictionaryElements;
            }

            public DictionaryElements Clone()
            {
                return (DictionaryElements)((ICloneable)this).Clone();
            }

            internal void ChangeOwner(PdfDictionary ownerDictionary)
            {
                if (_ownerDictionary != null)
                {
                }

                _ownerDictionary = ownerDictionary;

                ownerDictionary._elements = this;
            }

            internal PdfDictionary Owner
            {
                get { return _ownerDictionary; }
            }

            public bool GetBoolean(string key, bool create)
            {
                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = new PdfBoolean();
                    return false;
                }

                if (obj is PdfReference)
                    obj = ((PdfReference)obj).Value;

                PdfBoolean boolean = obj as PdfBoolean;
                if (boolean != null)
                    return boolean.Value;

                PdfBooleanObject booleanObject = obj as PdfBooleanObject;
                if (booleanObject != null)
                    return booleanObject.Value;
                throw new InvalidCastException("GetBoolean: Object is not a boolean.");
            }

            public bool GetBoolean(string key)
            {
                return GetBoolean(key, false);
            }

            public void SetBoolean(string key, bool value)
            {
                this[key] = new PdfBoolean(value);
            }

            public int GetInteger(string key, bool create)
            {
                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = new PdfInteger();
                    return 0;
                }
                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfInteger integer = obj as PdfInteger;
                if (integer != null)
                    return integer.Value;

                PdfIntegerObject integerObject = obj as PdfIntegerObject;
                if (integerObject != null)
                    return integerObject.Value;

                throw new InvalidCastException("GetInteger: Object is not an integer.");
            }

            public int GetInteger(string key)
            {
                return GetInteger(key, false);
            }

            public void SetInteger(string key, int value)
            {
                this[key] = new PdfInteger(value);
            }

            public double GetReal(string key, bool create)
            {
                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = new PdfReal();
                    return 0;
                }

                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfReal real = obj as PdfReal;
                if (real != null)
                    return real.Value;

                PdfRealObject realObject = obj as PdfRealObject;
                if (realObject != null)
                    return realObject.Value;

                PdfInteger integer = obj as PdfInteger;
                if (integer != null)
                    return integer.Value;

                PdfIntegerObject integerObject = obj as PdfIntegerObject;
                if (integerObject != null)
                    return integerObject.Value;

                throw new InvalidCastException("GetReal: Object is not a number.");
            }

            public double GetReal(string key)
            {
                return GetReal(key, false);
            }

            public void SetReal(string key, double value)
            {
                this[key] = new PdfReal(value);
            }

            public string GetString(string key, bool create)
            {
                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = new PdfString();
                    return "";
                }

                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfString str = obj as PdfString;
                if (str != null)
                    return str.Value;

                PdfStringObject strObject = obj as PdfStringObject;
                if (strObject != null)
                    return strObject.Value;

                PdfName name = obj as PdfName;
                if (name != null)
                    return name.Value;

                PdfNameObject nameObject = obj as PdfNameObject;
                if (nameObject != null)
                    return nameObject.Value;

                throw new InvalidCastException("GetString: Object is not a string.");
            }

            public string GetString(string key)
            {
                return GetString(key, false);
            }

            public bool TryGetString(string key, out string value)
            {
                value = null;
                object obj = this[key];
                if (obj == null)
                    return false;

                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfString str = obj as PdfString;
                if (str != null)
                {
                    value = str.Value;
                    return true;
                }

                PdfStringObject strObject = obj as PdfStringObject;
                if (strObject != null)
                {
                    value = strObject.Value;
                    return true;
                }

                PdfName name = obj as PdfName;
                if (name != null)
                {
                    value = name.Value;
                    return true;
                }

                PdfNameObject nameObject = obj as PdfNameObject;
                if (nameObject != null)
                {
                    value = nameObject.Value;
                    return true;
                }

                return false;
            }

            public void SetString(string key, string value)
            {
                this[key] = new PdfString(value);
            }

            public string GetName(string key)
            {
                object obj = this[key];
                if (obj == null)
                {
                    return String.Empty;
                }

                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfName name = obj as PdfName;
                if (name != null)
                    return name.Value;

                PdfNameObject nameObject = obj as PdfNameObject;
                if (nameObject != null)
                    return nameObject.Value;

                throw new InvalidCastException("GetName: Object is not a name.");
            }

            public void SetName(string key, string value)
            {
                if (value == null)
                    throw new ArgumentNullException("value");

                if (value.Length == 0 || value[0] != '/')
                    value = "/" + value;

                this[key] = new PdfName(value);
            }

            public PdfRectangle GetRectangle(string key, bool create)
            {
                PdfRectangle value = new PdfRectangle();
                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = value = new PdfRectangle();
                    return value;
                }
                if (obj is PdfReference)
                    obj = ((PdfReference)obj).Value;

                PdfArray array = obj as PdfArray;
                if (array != null && array.Elements.Count == 4)
                {
                    value = new PdfRectangle(array.Elements.GetReal(0), array.Elements.GetReal(1),
                      array.Elements.GetReal(2), array.Elements.GetReal(3));
                    this[key] = value;
                }
                else
                    value = (PdfRectangle)obj;
                return value;
            }

            public PdfRectangle GetRectangle(string key)
            {
                return GetRectangle(key, false);
            }

            public void SetRectangle(string key, PdfRectangle rect)
            {
                _elements[key] = rect;
            }

            public XMatrix GetMatrix(string key, bool create)
            {
                XMatrix value = new XMatrix();
                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = new PdfLiteral("[1 0 0 1 0 0]");
                    return value;
                }
                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfArray array = obj as PdfArray;
                if (array != null && array.Elements.Count == 6)
                {
                    value = new XMatrix(array.Elements.GetReal(0), array.Elements.GetReal(1), array.Elements.GetReal(2),
                      array.Elements.GetReal(3), array.Elements.GetReal(4), array.Elements.GetReal(5));
                }
                else if (obj is PdfLiteral)
                {
                    throw new NotImplementedException("Parsing matrix from literal.");
                }
                else
                    throw new InvalidCastException("Element is not an array with 6 values.");
                return value;
            }

            public XMatrix GetMatrix(string key)
            {
                return GetMatrix(key, false);
            }

            public void SetMatrix(string key, XMatrix matrix)
            {
                _elements[key] = PdfLiteral.FromMatrix(matrix);
            }

            public DateTime GetDateTime(string key, DateTime defaultValue)
            {
                object obj = this[key];
                if (obj == null)
                {
                    return defaultValue;
                }

                PdfReference reference = obj as PdfReference;
                if (reference != null)
                    obj = reference.Value;

                PdfDate date = obj as PdfDate;
                if (date != null)
                    return date.Value;

                string strDate;
                PdfString pdfString = obj as PdfString;
                if (pdfString != null)
                    strDate = pdfString.Value;
                else
                {
                    PdfStringObject stringObject = obj as PdfStringObject;
                    if (stringObject != null)
                        strDate = stringObject.Value;
                    else
                        throw new InvalidCastException("GetName: Object is not a name.");
                }

                if (strDate != "")
                {
                    try
                    {
                        defaultValue = Parser.ParseDateTime(strDate, defaultValue);
                    }
                    catch { }
                }
                return defaultValue;
            }

            public void SetDateTime(string key, DateTime value)
            {
                _elements[key] = new PdfDate(value);
            }

            internal int GetEnumFromName(string key, object defaultValue, bool create)
            {
                if (!(defaultValue is Enum))
                    throw new ArgumentException("defaultValue");

                object obj = this[key];
                if (obj == null)
                {
                    if (create)
                        this[key] = new PdfName(defaultValue.ToString());

                    return (int)defaultValue;
                }
                Debug.Assert(obj is Enum);
                return (int)Enum.Parse(defaultValue.GetType(), obj.ToString().Substring(1), false);
            }

            internal int GetEnumFromName(string key, object defaultValue)
            {
                return GetEnumFromName(key, defaultValue, false);
            }

            internal void SetEnumAsName(string key, object value)
            {
                if (!(value is Enum))
                    throw new ArgumentException("value");
                _elements[key] = new PdfName("/" + value);
            }

            public PdfItem GetValue(string key, VCF options)
            {
                PdfObject obj;
                PdfDictionary dict;
                PdfArray array;
                PdfReference iref;
                PdfItem value = this[key];
                if (value == null ||
                    value is PdfNull ||
                    value is PdfReference && ((PdfReference)value).Value is PdfNullObject)
                {
                    if (options != VCF.None)
                    {
                        Type type = GetValueType(key);
                        if (type != null)
                        {
#if !NETFX_CORE
                            Debug.Assert(typeof(PdfItem).IsAssignableFrom(type), "Type not allowed.");
                            if (typeof(PdfDictionary).IsAssignableFrom(type))
                            {
                                value = obj = CreateDictionary(type, null);
                            }
                            else if (typeof(PdfArray).IsAssignableFrom(type))
                            {
                                value = obj = CreateArray(type, null);
                            }
                            else
                                throw new NotImplementedException("Type other than array or dictionary.");
#endif
                            if (options == VCF.CreateIndirect)
                            {
                                _ownerDictionary.Owner._irefTable.Add(obj);
                                this[key] = obj.Reference;
                            }
                            else
                                this[key] = obj;
                        }
                        else
                            throw new NotImplementedException("Cannot create value for key: " + key);
                    }
                }
                else
                {
                    if ((iref = value as PdfReference) != null)
                    {
                        value = iref.Value;
                        if (value == null)
                        {
                            throw new InvalidOperationException("Indirect reference without value.");
                        }

                        if (true)
                        {
                            Type type = GetValueType(key);
                            Debug.Assert(type != null, "No value type specified in meta information. Please send this file to PDFsharp support.");

#if !NETFX_CORE
                            if (type != null && type != value.GetType())
                            {
                                if (typeof(PdfDictionary).IsAssignableFrom(type))
                                {
                                    Debug.Assert(value is PdfDictionary, "Bug in PDFsharp. Please send this file to PDFsharp support.");
                                    value = CreateDictionary(type, (PdfDictionary)value);
                                }
                                else if (typeof(PdfArray).IsAssignableFrom(type))
                                {
                                    Debug.Assert(value is PdfArray, "Bug in PDFsharp. Please send this file to PDFsharp support.");
                                    value = CreateArray(type, (PdfArray)value);
                                }
                                else
                                    throw new NotImplementedException("Type other than array or dictionary.");
                            }
#endif
                        }
                        return value;
                    }

                    if (true)
                    {
                        if ((dict = value as PdfDictionary) != null)
                        {
                            Debug.Assert(!dict.IsIndirect);

                            Type type = GetValueType(key);
                            Debug.Assert(type != null, "No value type specified in meta information. Please send this file to PDFsharp support.");
                            if (dict.GetType() != type)
                                dict = CreateDictionary(type, dict);
                            return dict;
                        }

                        if ((array = value as PdfArray) != null)
                        {
                            Debug.Assert(!array.IsIndirect);

                            Type type = GetValueType(key);
                            if (type != null && type != array.GetType())
                                array = CreateArray(type, array);
                            return array;
                        }
                    }
                }
                return value;
            }

            public PdfItem GetValue(string key)
            {
                return GetValue(key, VCF.None);
            }

            Type GetValueType(string key)
            {
                Type type = null;
                DictionaryMeta meta = _ownerDictionary.Meta;
                if (meta != null)
                {
                    KeyDescriptor kd = meta[key];
                    if (kd != null)
                        type = kd.GetValueType();
                }
                return type;
            }

            PdfArray CreateArray(Type type, PdfArray oldArray)
            {
#if !NETFX_CORE && !UWP
                ConstructorInfo ctorInfo;
                PdfArray array;
                if (oldArray == null)
                {
                    ctorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,
                        null, new Type[] { typeof(PdfDocument) }, null);
                    Debug.Assert(ctorInfo != null, "No appropriate constructor found for type: " + type.Name);
                    array = ctorInfo.Invoke(new object[] { _ownerDictionary.Owner }) as PdfArray;
                }
                else
                {
                    ctorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,
                        null, new Type[] { typeof(PdfArray) }, null);
                    Debug.Assert(ctorInfo != null, "No appropriate constructor found for type: " + type.Name);
                    array = ctorInfo.Invoke(new object[] { oldArray }) as PdfArray;
                }
                return array;
#endif
            }

            PdfDictionary CreateDictionary(Type type, PdfDictionary oldDictionary)
            {
#if !NETFX_CORE && !UWP
                ConstructorInfo ctorInfo;
                PdfDictionary dict;
                if (oldDictionary == null)
                {
                    ctorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,
                        null, new Type[] { typeof(PdfDocument) }, null);
                    Debug.Assert(ctorInfo != null, "No appropriate constructor found for type: " + type.Name);
                    dict = ctorInfo.Invoke(new object[] { _ownerDictionary.Owner }) as PdfDictionary;
                }
                else
                {
                    ctorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,
                      null, new Type[] { typeof(PdfDictionary) }, null);
                    Debug.Assert(ctorInfo != null, "No appropriate constructor found for type: " + type.Name);
                    dict = ctorInfo.Invoke(new object[] { oldDictionary }) as PdfDictionary;
                }
                return dict;
#endif
            }

            PdfItem CreateValue(Type type, PdfDictionary oldValue)
            {
#if !NETFX_CORE && !UWP
                ConstructorInfo ctorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,
                    null, new Type[] { typeof(PdfDocument) }, null);
                PdfObject obj = ctorInfo.Invoke(new object[] { _ownerDictionary.Owner }) as PdfObject;
                if (oldValue != null)
                {
                    obj.Reference = oldValue.Reference;
                    obj.Reference.Value = obj;
                    if (obj is PdfDictionary)
                    {
                        PdfDictionary dict = (PdfDictionary)obj;
                        dict._elements = oldValue._elements;
                    }
                }
                return obj;
#endif
            }

            public void SetValue(string key, PdfItem value)
            {
                Debug.Assert((value is PdfObject && ((PdfObject)value).Reference == null) | !(value is PdfObject),
                    "You try to set an indirect object directly into a dictionary.");

                _elements[key] = value;
            }

            public PdfObject GetObject(string key)
            {
                PdfItem item = this[key];
                PdfReference reference = item as PdfReference;
                if (reference != null)
                    return reference.Value;
                return item as PdfObject;
            }

            public PdfDictionary GetDictionary(string key)
            {
                return GetObject(key) as PdfDictionary;
            }

            public PdfArray GetArray(string key)
            {
                return GetObject(key) as PdfArray;
            }

            public PdfReference GetReference(string key)
            {
                PdfItem item = this[key];
                return item as PdfReference;
            }

            public void SetObject(string key, PdfObject obj)
            {
                if (obj.Reference != null)
                    throw new ArgumentException("PdfObject must not be an indirect object.", "obj");
                this[key] = obj;
            }

            public void SetReference(string key, PdfObject obj)
            {
                if (obj.Reference == null)
                    throw new ArgumentException("PdfObject must be an indirect object.", "obj");
                this[key] = obj.Reference;
            }

            public void SetReference(string key, PdfReference iref)
            {
                if (iref == null)
                    throw new ArgumentNullException("iref");
                this[key] = iref;
            }

            public bool IsReadOnly
            {
                get { return false; }
            }

            public IEnumerator<KeyValuePair<string, PdfItem>> GetEnumerator()
            {
                return _elements.GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return ((ICollection)_elements).GetEnumerator();
            }

            public PdfItem this[string key]
            {
                get
                {
                    PdfItem item;
                    _elements.TryGetValue(key, out item);
                    return item;
                }
                set
                {
                    if (value == null)
                        throw new ArgumentNullException("value");
                    PdfObject obj = value as PdfObject;
                    if (obj != null && obj.IsIndirect)
                        value = obj.Reference;
                    _elements[key] = value;
                }
            }

            public PdfItem this[PdfName key]
            {
                get { return this[key.Value]; }
                set
                {
                    if (value == null)
                        throw new ArgumentNullException("value");

                    PdfObject obj = value as PdfObject;
                    if (obj != null && obj.IsIndirect)
                        value = obj.Reference;
                    _elements[key.Value] = value;
                }
            }

            public bool Remove(string key)
            {
                return _elements.Remove(key);
            }

            public bool Remove(KeyValuePair<string, PdfItem> item)
            {
                throw new NotImplementedException();
            }

            public bool ContainsKey(string key)
            {
                return _elements.ContainsKey(key);
            }

            public bool Contains(KeyValuePair<string, PdfItem> item)
            {
                throw new NotImplementedException();
            }

            public void Clear()
            {
                _elements.Clear();
            }

            public void Add(string key, PdfItem value)
            {
                if (String.IsNullOrEmpty(key))
                    throw new ArgumentNullException("key");

                if (key[0] != '/')
                    throw new ArgumentException("The key must start with a slash '/'.");

                PdfObject obj = value as PdfObject;
                if (obj != null && obj.IsIndirect)
                    value = obj.Reference;

                _elements.Add(key, value);
            }

            public void Add(KeyValuePair<string, PdfItem> item)
            {
                Add(item.Key, item.Value);
            }

            public PdfName[] KeyNames
            {
                get
                {
                    ICollection values = _elements.Keys;
                    int count = values.Count;
                    string[] strings = new string[count];
                    values.CopyTo(strings, 0);
                    PdfName[] names = new PdfName[count];
                    for (int idx = 0; idx < count; idx++)
                        names[idx] = new PdfName(strings[idx]);
                    return names;
                }
            }

            public ICollection<string> Keys
            {
                get
                {
                    ICollection values = _elements.Keys;
                    int count = values.Count;
                    string[] keys = new string[count];
                    values.CopyTo(keys, 0);
                    return keys;
                }
            }

            public bool TryGetValue(string key, out PdfItem value)
            {
                return _elements.TryGetValue(key, out value);
            }

            public ICollection<PdfItem> Values
            {
                get
                {
                    ICollection values = _elements.Values;
                    PdfItem[] items = new PdfItem[values.Count];
                    values.CopyTo(items, 0);
                    return items;
                }
            }

            public bool IsFixedSize
            {
                get { return false; }
            }

            public bool IsSynchronized
            {
                get { return false; }
            }

            public int Count
            {
                get { return _elements.Count; }
            }

            public void CopyTo(KeyValuePair<string, PdfItem>[] array, int arrayIndex)
            {
                throw new NotImplementedException();
            }

            public object SyncRoot
            {
                get { return null; }
            }

            internal string DebuggerDisplay
            {
                get
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat(CultureInfo.InvariantCulture, "key={0}:(", _elements.Count);
                    bool addSpace = false;
                    ICollection<string> keys = _elements.Keys;
                    foreach (string key in keys)
                    {
                        if (addSpace)
                            sb.Append(' ');
                        addSpace = true;
                        sb.Append(key);
                    }
                    sb.Append(")");
                    return sb.ToString();
                }
            }

            Dictionary<string, PdfItem> _elements;

            PdfDictionary _ownerDictionary;
        }

        public sealed class PdfStream
        {
            internal PdfStream(PdfDictionary ownerDictionary)
            {
                if (ownerDictionary == null)
                    throw new ArgumentNullException("ownerDictionary");
                _ownerDictionary = ownerDictionary;
            }

            internal PdfStream(byte[] value, PdfDictionary owner)
                : this(owner)
            {
                _value = value;
            }

            public PdfStream Clone()
            {
                PdfStream stream = (PdfStream)MemberwiseClone();
                stream._ownerDictionary = null;
                if (stream._value != null)
                {
                    stream._value = new byte[stream._value.Length];
                    _value.CopyTo(stream._value, 0);
                }
                return stream;
            }

            internal void ChangeOwner(PdfDictionary dict)
            {
                if (_ownerDictionary != null)
                {
                }

                _ownerDictionary = dict;

                _ownerDictionary._stream = this;
            }

            PdfDictionary _ownerDictionary;

            public int Length
            {
                get { return _value != null ? _value.Length : 0; }
            }

            internal bool HasDecodeParams
            {
                get
                {
                    PdfDictionary dictionary = _ownerDictionary.Elements.GetDictionary(Keys.DecodeParms);
                    if (dictionary != null)
                    {
                        return true;
                    }
                    return false;
                }
            }

            internal int DecodePredictor
            {
                get
                {
                    PdfDictionary dictionary = _ownerDictionary.Elements.GetDictionary(Keys.DecodeParms);
                    if (dictionary != null)
                    {
                        return dictionary.Elements.GetInteger("/Predictor");
                    }
                    return 0;
                }
            }

            internal int DecodeColumns
            {
                get
                {
                    PdfDictionary dictionary = _ownerDictionary.Elements.GetDictionary(Keys.DecodeParms);
                    if (dictionary != null)
                    {
                        return dictionary.Elements.GetInteger("/Columns");
                    }
                    return 0;
                }
            }

            public byte[] Value
            {
                get { return _value; }
                set
                {
                    if (value == null)
                        throw new ArgumentNullException("value");
                    _value = value;
                    _ownerDictionary.Elements.SetInteger(Keys.Length, value.Length);
                }
            }
            byte[] _value;

            public byte[] UnfilteredValue
            {
                get
                {
                    byte[] bytes = null;
                    if (_value != null)
                    {
                        PdfItem filter = _ownerDictionary.Elements["/Filter"];
                        if (filter != null)
                        {
                            bytes = Filtering.Decode(_value, filter);
                            if (bytes == null)
                            {
                                string message = String.Format("«Cannot decode filter '{0}'»", filter);
                                bytes = PdfEncoders.RawEncoding.GetBytes(message);
                            }
                        }
                        else
                        {
                            bytes = new byte[_value.Length];
                            _value.CopyTo(bytes, 0);
                        }
                    }
                    return bytes ?? new byte[0];
                }
            }

            public bool TryUnfilter()
            {
                if (_value != null)
                {
                    PdfItem filter = _ownerDictionary.Elements["/Filter"];
                    if (filter != null)
                    {
                        byte[] bytes = Filtering.Decode(_value, filter);
                        if (bytes != null)
                        {
                            _ownerDictionary.Elements.Remove(Keys.Filter);
                            Value = bytes;
                        }
                        else
                            return false;
                    }
                }
                return true;
            }

            public void Zip()
            {
                if (_value == null)
                    return;

                if (!_ownerDictionary.Elements.ContainsKey("/Filter"))
                {
                    _value = Filtering.FlateDecode.Encode(_value, _ownerDictionary._document.Options.FlateEncodeMode);
                    _ownerDictionary.Elements["/Filter"] = new PdfName("/FlateDecode");
                    _ownerDictionary.Elements["/Length"] = new PdfInteger(_value.Length);
                }
            }

            public override string ToString()
            {
                if (_value == null)
                    return "«null»";

                string stream;
                PdfItem filter = _ownerDictionary.Elements["/Filter"];
                if (filter != null)
                {
#if true
                    byte[] bytes = Filtering.Decode(_value, filter);
                    if (bytes != null)
                        stream = PdfEncoders.RawEncoding.GetString(bytes, 0, bytes.Length);
#endif
                    else
                        throw new NotImplementedException("Unknown filter");
                }
                else
                    stream = PdfEncoders.RawEncoding.GetString(_value, 0, _value.Length);

                return stream;
            }

            public class Keys : KeysBase
            {
                [KeyInfo(KeyType.Integer | KeyType.Required)]
                public const string Length = "/Length";

                [KeyInfo(KeyType.NameOrArray | KeyType.Optional)]
                public const string Filter = "/Filter";

                [KeyInfo(KeyType.ArrayOrDictionary | KeyType.Optional)]
                public const string DecodeParms = "/DecodeParms";

                [KeyInfo("1.2", KeyType.String | KeyType.Optional)]
                public const string F = "/F";

                [KeyInfo("1.2", KeyType.NameOrArray | KeyType.Optional)]
                public const string FFilter = "/FFilter";

                [KeyInfo("1.2", KeyType.ArrayOrDictionary | KeyType.Optional)]
                public const string FDecodeParms = "/FDecodeParms";

                [KeyInfo("1.5", KeyType.Integer | KeyType.Optional)]
                public const string DL = "/DL";

            }
        }

        string DebuggerDisplay
        {
            get
            {
#if true
                return String.Format(CultureInfo.InvariantCulture, "dictionary({0},[{1}])={2}",
                    ObjectID.DebuggerDisplay,
                    Elements.Count,
                    _elements.DebuggerDisplay);
#endif
            }
        }
    }
    public sealed class PdfDocument : PdfObject, IDisposable
    {
        internal DocumentState _state;
        internal PdfDocumentOpenMode _openMode;

        public PdfDocument()
        {
            _creation = DateTime.Now;
            _state = DocumentState.Created;
            _version = 14;
            Initialize();
            Info.CreationDate = _creation;
        }

        public PdfDocument(string filename)
        {
            _creation = DateTime.Now;
            _state = DocumentState.Created;
            _version = 14;
            Initialize();
            Info.CreationDate = _creation;

#if !NETFX_CORE
            _outStream = new FileStream(filename, FileMode.Create);
#endif
        }

        public PdfDocument(Stream outputStream)
        {
            _creation = DateTime.Now;
            _state = DocumentState.Created;
            Initialize();
            Info.CreationDate = _creation;

            _outStream = outputStream;
        }

        internal PdfDocument(Lexer lexer)
        {
            _creation = DateTime.Now;
            _state = DocumentState.Imported;

            _irefTable = new PdfCrossReferenceTable(this);
            _lexer = lexer;
        }

        void Initialize()
        {
            _fontTable = new PdfFontTable(this);
            _imageTable = new PdfImageTable(this);
            _trailer = new PdfTrailer(this);
            _irefTable = new PdfCrossReferenceTable(this);
            _trailer.CreateNewDocumentIDs();
        }

        public void Dispose()
        {
            Dispose(true);
        }

        void Dispose(bool disposing)
        {
            if (_state != DocumentState.Disposed)
            {
                if (disposing)
                {
                }
            }
            _state = DocumentState.Disposed;
        }

        public object Tag
        {
            get { return _tag; }
            set { _tag = value; }
        }
        object _tag;

        string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        string _name = NewName();

        static string NewName()
        {
            return "Document " + _nameCount++;
        }
        static int _nameCount;

        internal bool CanModify
        {
            get { return true; }
        }

        public void Close()
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);

            if (_outStream != null)
            {
                PdfStandardSecurityHandler securityHandler = null;
                if (SecuritySettings.DocumentSecurityLevel != PdfDocumentSecurityLevel.None)
                    securityHandler = SecuritySettings.SecurityHandler;

                PdfWriter writer = new PdfWriter(_outStream, securityHandler);
                try
                {
                    DoSave(writer);
                }
                finally
                {
                    writer.Close();
                }
            }
        }

#if true 
        public void Save(string path)
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);

#if !NETFX_CORE
            using (Stream stream = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                Save(stream);
            }
#endif
        }
#endif
        public void Save(Stream stream, bool closeStream)
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);

            string message = "";
            if (!CanSave(ref message))
                throw new PdfSharpException(message);

            PdfStandardSecurityHandler securityHandler = null;
            if (SecuritySettings.DocumentSecurityLevel != PdfDocumentSecurityLevel.None)
                securityHandler = SecuritySettings.SecurityHandler;

            PdfWriter writer = null;
            try
            {
                writer = new PdfWriter(stream, securityHandler);
                DoSave(writer);
            }
            finally
            {
                if (stream != null)
                {
                    if (closeStream)
#if UWP
 
#else
                        stream.Close();
#endif
                    else
                    {
                        if (stream.CanRead && stream.CanSeek)
                            stream.Position = 0;
                    }
                }
                if (writer != null)
                    writer.Close(closeStream);
            }
        }

        public void Save(Stream stream)
        {
            Save(stream, false);
        }

        void DoSave(PdfWriter writer)
        {
            if (_pages == null || _pages.Count == 0)
            {
                if (_outStream != null)
                {
                    throw new InvalidOperationException("Cannot save a PDF document with no pages. Do not use \"public PdfDocument(string filename)\" or \"public PdfDocument(Stream outputStream)\" if you want to open an existing PDF document from a file or stream; use PdfReader.Open() for that purpose.");
                }
                throw new InvalidOperationException("Cannot save a PDF document with no pages.");
            }

            try
            {
                if (_trailer is PdfCrossReferenceStream)
                {
                    PdfStandardSecurityHandler securityHandler = _securitySettings.SecurityHandler;
                    _trailer = new PdfTrailer((PdfCrossReferenceStream)_trailer);
                    _trailer._securityHandler = securityHandler;
                }

                bool encrypt = _securitySettings.DocumentSecurityLevel != PdfDocumentSecurityLevel.None;
                if (encrypt)
                {
                    PdfStandardSecurityHandler securityHandler = _securitySettings.SecurityHandler;
                    if (securityHandler.Reference == null)
                        _irefTable.Add(securityHandler);
                    else
                        Debug.Assert(_irefTable.Contains(securityHandler.ObjectID));
                    _trailer.Elements[PdfTrailer.Keys.Encrypt] = _securitySettings.SecurityHandler.Reference;
                }
                else
                    _trailer.Elements.Remove(PdfTrailer.Keys.Encrypt);

                PrepareForSave();

                if (encrypt)
                    _securitySettings.SecurityHandler.PrepareEncryption();

                writer.WriteFileHeader(this);
                PdfReference[] irefs = _irefTable.AllReferences;
                int count = irefs.Length;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfReference iref = irefs[idx];
                    iref.Position = writer.Position;
                    iref.Value.WriteObject(writer);
                }
                int startxref = writer.Position;
                _irefTable.WriteObject(writer);
                writer.WriteRaw("trailer\n");
                _trailer.Elements.SetInteger("/Size", count + 1);
                _trailer.WriteObject(writer);
                writer.WriteEof(this, startxref);

            }
            finally
            {
                if (writer != null)
                {
                    writer.Stream.Flush();
                }
            }
        }

        internal override void PrepareForSave()
        {
            PdfDocumentInformation info = Info;

            string pdfSharpProducer = VersionInfo.Producer;
            if (!ProductVersionInfo.VersionPatch.Equals("0"))
                pdfSharpProducer = ProductVersionInfo.Producer2;

            if (info.Elements[PdfDocumentInformation.Keys.Creator] == null)
                info.Creator = pdfSharpProducer;

            string producer = info.Producer;
            if (producer.Length == 0)
                producer = pdfSharpProducer;
            else
            {
                if (!producer.StartsWith(VersionInfo.Title))
                    producer = pdfSharpProducer + " (Original: " + producer + ")";
            }
            info.Elements.SetString(PdfDocumentInformation.Keys.Producer, producer);

            if (_fontTable != null)
                _fontTable.PrepareForSave();

            Catalog.PrepareForSave();

#if true
            int removed = _irefTable.Compact();
            if (removed != 0)
                Debug.WriteLine("PrepareForSave: Number of deleted unreachable objects: " + removed);
            _irefTable.Renumber();
#endif
        }

        public bool CanSave(ref string message)
        {
            if (!SecuritySettings.CanSave(ref message))
                return false;

            return true;
        }

        internal bool HasVersion(string version)
        {
            return String.Compare(Catalog.Version, version) >= 0;
        }

        public PdfDocumentOptions Options
        {
            get
            {
                if (_options == null)
                    _options = new PdfDocumentOptions(this);
                return _options;
            }
        }
        PdfDocumentOptions _options;

        public PdfDocumentSettings Settings
        {
            get
            {
                if (_settings == null)
                    _settings = new PdfDocumentSettings(this);
                return _settings;
            }
        }
        PdfDocumentSettings _settings;

        internal bool EarlyWrite
        {
            get { return false; }
        }

        public int Version
        {
            get { return _version; }
            set
            {
                if (!CanModify)
                    throw new InvalidOperationException(PSSR.CannotModify);
                if (value < 12 || value > 17)
                    throw new ArgumentException(PSSR.InvalidVersionNumber, "value");
                _version = value;
            }
        }
        internal int _version;

        public int PageCount
        {
            get
            {
                if (CanModify)
                    return Pages.Count;
                PdfDictionary pageTreeRoot = (PdfDictionary)Catalog.Elements.GetObject(PdfCatalog.Keys.Pages);
                return pageTreeRoot.Elements.GetInteger(PdfPages.Keys.Count);
            }
        }

        public long FileSize
        {
            get { return _fileSize; }
        }
        internal long _fileSize;

        public string FullPath
        {
            get { return _fullPath; }
        }
        internal string _fullPath = String.Empty;

        public Guid Guid
        {
            get { return _guid; }
        }
        Guid _guid = Guid.NewGuid();

        internal DocumentHandle Handle
        {
            get
            {
                if (_handle == null)
                    _handle = new DocumentHandle(this);
                return _handle;
            }
        }
        DocumentHandle _handle;

        public bool IsImported
        {
            get { return (_state & DocumentState.Imported) != 0; }
        }

        public bool IsReadOnly
        {
            get { return (_openMode != PdfDocumentOpenMode.Modify); }
        }

        internal Exception DocumentNotImported()
        {
            return new InvalidOperationException("Document not imported.");
        }

        public PdfDocumentInformation Info
        {
            get
            {
                if (_info == null)
                    _info = _trailer.Info;
                return _info;
            }
        }
        PdfDocumentInformation _info;

        public PdfCustomValues CustomValues
        {
            get
            {
                if (_customValues == null)
                    _customValues = PdfCustomValues.Get(Catalog.Elements);
                return _customValues;
            }
            set
            {
                if (value != null)
                    throw new ArgumentException("Only null is allowed to clear all custom values.");
                PdfCustomValues.Remove(Catalog.Elements);
                _customValues = null;
            }
        }
        PdfCustomValues _customValues;

        public PdfPages Pages
        {
            get
            {
                if (_pages == null)
                    _pages = Catalog.Pages;
                return _pages;
            }
        }
        PdfPages _pages;

        public PdfPageLayout PageLayout
        {
            get { return Catalog.PageLayout; }
            set
            {
                if (!CanModify)
                    throw new InvalidOperationException(PSSR.CannotModify);
                Catalog.PageLayout = value;
            }
        }

        public PdfPageMode PageMode
        {
            get { return Catalog.PageMode; }
            set
            {
                if (!CanModify)
                    throw new InvalidOperationException(PSSR.CannotModify);
                Catalog.PageMode = value;
            }
        }

        public PdfViewerPreferences ViewerPreferences
        {
            get { return Catalog.ViewerPreferences; }
        }

        public PdfOutlineCollection Outlines
        {
            get { return Catalog.Outlines; }
        }

        public PdfAcroForm AcroForm
        {
            get { return Catalog.AcroForm; }
        }

        public string Language
        {
            get { return Catalog.Language; }
            set { Catalog.Language = value; }
        }

        public PdfSecuritySettings SecuritySettings
        {
            get { return _securitySettings ?? (_securitySettings = new PdfSecuritySettings(this)); }
        }
        internal PdfSecuritySettings _securitySettings;

        internal PdfFontTable FontTable
        {
            get { return _fontTable ?? (_fontTable = new PdfFontTable(this)); }
        }
        PdfFontTable _fontTable;

        internal PdfImageTable ImageTable
        {
            get
            {
                if (_imageTable == null)
                    _imageTable = new PdfImageTable(this);
                return _imageTable;
            }
        }
        PdfImageTable _imageTable;

        internal PdfFormXObjectTable FormTable
        {
            get { return _formTable ?? (_formTable = new PdfFormXObjectTable(this)); }
        }
        PdfFormXObjectTable _formTable;

        internal PdfExtGStateTable ExtGStateTable
        {
            get { return _extGStateTable ?? (_extGStateTable = new PdfExtGStateTable(this)); }
        }
        PdfExtGStateTable _extGStateTable;

        internal PdfCatalog Catalog
        {
            get { return _catalog ?? (_catalog = _trailer.Root); }
        }
        PdfCatalog _catalog;

        public new PdfInternals Internals
        {
            get { return _internals ?? (_internals = new PdfInternals(this)); }
        }
        PdfInternals _internals;

        public PdfPage AddPage()
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);
            return Catalog.Pages.Add();
        }

        public PdfPage AddPage(PdfPage page)
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);
            return Catalog.Pages.Add(page);
        }

        public PdfPage InsertPage(int index)
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);
            return Catalog.Pages.Insert(index);
        }

        public PdfPage InsertPage(int index, PdfPage page)
        {
            if (!CanModify)
                throw new InvalidOperationException(PSSR.CannotModify);
            return Catalog.Pages.Insert(index, page);
        }

        public void Flatten()
        {
            for (int idx = 0; idx < AcroForm.Fields.Count; idx++)
            {
                AcroForm.Fields[idx].ReadOnly = true;
            }
        }

        public PdfStandardSecurityHandler SecurityHandler
        {
            get { return _trailer.SecurityHandler; }
        }

        internal PdfTrailer _trailer;
        internal PdfCrossReferenceTable _irefTable;
        internal Stream _outStream;

        internal Lexer _lexer;

        internal DateTime _creation;

        internal void OnExternalDocumentFinalized(PdfDocument.DocumentHandle handle)
        {
            if (tls != null)
            {
                tls.DetachDocument(handle);
            }

            if (_formTable != null)
                _formTable.DetachDocument(handle);
        }

        internal static ThreadLocalStorage Tls
        {
            get { return tls ?? (tls = new ThreadLocalStorage()); }
        }
        [ThreadStatic]
        static ThreadLocalStorage tls;

        [DebuggerDisplay("(ID={ID}, alive={IsAlive})")]
        internal class DocumentHandle
        {
            public DocumentHandle(PdfDocument document)
            {
                _weakRef = new WeakReference(document);
                ID = document._guid.ToString("B").ToUpper();
            }

            public bool IsAlive
            {
                get { return _weakRef.IsAlive; }
            }

            public PdfDocument Target
            {
                get { return _weakRef.Target as PdfDocument; }
            }
            readonly WeakReference _weakRef;

            public string ID;

            public override bool Equals(object obj)
            {
                DocumentHandle handle = obj as DocumentHandle;
                if (!ReferenceEquals(handle, null))
                    return ID == handle.ID;
                return false;
            }

            public override int GetHashCode()
            {
                return ID.GetHashCode();
            }

            public static bool operator ==(DocumentHandle left, DocumentHandle right)
            {
                if (ReferenceEquals(left, null))
                    return ReferenceEquals(right, null);
                return left.Equals(right);
            }

            public static bool operator !=(DocumentHandle left, DocumentHandle right)
            {
                return !(left == right);
            }
        }
    }
    public sealed class PdfDocumentInformation : PdfDictionary
    {
        public PdfDocumentInformation(PdfDocument document)
            : base(document)
        { }

        internal PdfDocumentInformation(PdfDictionary dict)
            : base(dict)
        { }

        public string Title
        {
            get { return Elements.GetString(Keys.Title); }
            set { Elements.SetString(Keys.Title, value); }
        }

        public string Author
        {
            get { return Elements.GetString(Keys.Author); }
            set { Elements.SetString(Keys.Author, value); }
        }

        public string Subject
        {
            get { return Elements.GetString(Keys.Subject); }
            set { Elements.SetString(Keys.Subject, value); }
        }

        public string Keywords
        {
            get { return Elements.GetString(Keys.Keywords); }
            set { Elements.SetString(Keys.Keywords, value); }
        }

        public string Creator
        {
            get { return Elements.GetString(Keys.Creator); }
            set { Elements.SetString(Keys.Creator, value); }
        }

        public string Producer
        {
            get { return Elements.GetString(Keys.Producer); }
        }

        public DateTime CreationDate
        {
            get { return Elements.GetDateTime(Keys.CreationDate, DateTime.MinValue); }
            set { Elements.SetDateTime(Keys.CreationDate, value); }
        }

        public DateTime ModificationDate
        {
            get { return Elements.GetDateTime(Keys.ModDate, DateTime.MinValue); }
            set { Elements.SetDateTime(Keys.ModDate, value); }
        }

        internal sealed class Keys : KeysBase
        {
            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string Title = "/Title";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string Author = "/Author";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string Subject = "/Subject";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string Keywords = "/Keywords";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string Creator = "/Creator";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string Producer = "/Producer";

            [KeyInfo(KeyType.Date | KeyType.Optional)]
            public const string CreationDate = "/CreationDate";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string ModDate = "/ModDate";

            [KeyInfo("1.3", KeyType.Name | KeyType.Optional)]
            public const string Trapped = "/Trapped";

            public static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfDocumentOptions
    {
        internal PdfDocumentOptions(PdfDocument document)
        {
        }

        public PdfColorMode ColorMode
        {
            get { return _colorMode; }
            set { _colorMode = value; }
        }
        PdfColorMode _colorMode = PdfColorMode.Rgb;

        public bool CompressContentStreams
        {
            get { return _compressContentStreams; }
            set { _compressContentStreams = value; }
        }
#if DEBUG

#else
        bool _compressContentStreams = true;
#endif

        public bool NoCompression
        {
            get { return _noCompression; }
            set { _noCompression = value; }
        }
        bool _noCompression;

        public PdfFlateEncodeMode FlateEncodeMode
        {
            get { return _flateEncodeMode; }
            set { _flateEncodeMode = value; }
        }
        PdfFlateEncodeMode _flateEncodeMode = PdfFlateEncodeMode.Default;

        public bool EnableCcittCompressionForBilevelImages
        {
            get { return _enableCcittCompressionForBilevelImages; }
            set { _enableCcittCompressionForBilevelImages = value; }
        }
        bool _enableCcittCompressionForBilevelImages = false;

        public PdfUseFlateDecoderForJpegImages UseFlateDecoderForJpegImages
        {
            get { return _useFlateDecoderForJpegImages; }
            set { _useFlateDecoderForJpegImages = value; }
        }
        PdfUseFlateDecoderForJpegImages _useFlateDecoderForJpegImages = PdfUseFlateDecoderForJpegImages.Never;
    }
    public sealed class PdfDocumentSettings
    {
        internal PdfDocumentSettings(PdfDocument document)
        { }

        public TrimMargins TrimMargins
        {
            get
            {
                if (_trimMargins == null)
                    _trimMargins = new TrimMargins();
                return _trimMargins;
            }
            set
            {
                if (_trimMargins == null)
                    _trimMargins = new TrimMargins();
                if (value != null)
                {
                    _trimMargins.Left = value.Left;
                    _trimMargins.Right = value.Right;
                    _trimMargins.Top = value.Top;
                    _trimMargins.Bottom = value.Bottom;
                }
                else
                    _trimMargins.All = 0;
            }
        }
        TrimMargins _trimMargins = new TrimMargins();
    }
    public sealed class PdfInteger : PdfNumber, IConvertible
    {
        public PdfInteger()
        { }

        public PdfInteger(int value)
        {
            _value = value;
        }

        public int Value
        {
            get { return _value; }
        }
        readonly int _value;

        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }

        ulong IConvertible.ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(_value);
        }

        sbyte IConvertible.ToSByte(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        double IConvertible.ToDouble(IFormatProvider provider)
        {
            return _value;
        }

        DateTime IConvertible.ToDateTime(IFormatProvider provider)
        {
            return new DateTime();
        }

        float IConvertible.ToSingle(IFormatProvider provider)
        {
            return _value;
        }

        bool IConvertible.ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(_value);
        }

        int IConvertible.ToInt32(IFormatProvider provider)
        {
            return _value;
        }

        ushort IConvertible.ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(_value);
        }

        short IConvertible.ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(_value);
        }

        string IConvertible.ToString(IFormatProvider provider)
        {
            return _value.ToString(provider);
        }

        byte IConvertible.ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(_value);
        }

        char IConvertible.ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(_value);
        }

        long IConvertible.ToInt64(IFormatProvider provider)
        {
            return _value;
        }

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        decimal IConvertible.ToDecimal(IFormatProvider provider)
        {
            return _value;
        }

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            return null;
        }

        uint IConvertible.ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(_value);
        }

    }
    public sealed class PdfIntegerObject : PdfNumberObject
    {
        public PdfIntegerObject()
        { }

        public PdfIntegerObject(int value)
        {
            _value = value;
        }

        public PdfIntegerObject(PdfDocument document, int value)
            : base(document)
        {
            _value = value;
        }

        public int Value
        {
            get { return _value; }
        }
        readonly int _value;

        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.Write(_value);
            writer.WriteEndObject();
        }
    }
    public abstract class PdfItem : ICloneable
    {
        object ICloneable.Clone()
        {
            return Copy();
        }

        public PdfItem Clone()
        {
            return (PdfItem)Copy();
        }

        protected virtual object Copy()
        {
            return MemberwiseClone();
        }

        internal abstract void WriteObject(PdfWriter writer);
    }
    public sealed class PdfLiteral : PdfItem
    {
        public PdfLiteral()
        { }

        public PdfLiteral(string value)
        {
            _value = value;
        }

        public PdfLiteral(string format, params object[] args)
        {
            _value = PdfEncoders.Format(format, args);
        }

        public static PdfLiteral FromMatrix(XMatrix matrix)
        {
            return new PdfLiteral("[" + PdfEncoders.ToString(matrix) + "]");
        }

        public string Value
        {
            get { return _value; }
        }
        readonly string _value = String.Empty;

        public override string ToString()
        {
            return _value;
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }
    }
    public sealed class PdfName : PdfItem
    {
        public PdfName()
        {
            _value = "/";
        }

        public PdfName(string value)
        {
            if (value == null)
                throw new ArgumentNullException("value");
            if (value.Length == 0 || value[0] != '/')
                throw new ArgumentException(PSSR.NameMustStartWithSlash);

            _value = value;
        }

        public override bool Equals(object obj)
        {
            return _value.Equals(obj);
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public string Value
        {
            get { return _value; }
        }
        readonly string _value;

        public override string ToString()
        {
            return _value;
        }

        public static bool operator ==(PdfName name, string str)
        {
            if (ReferenceEquals(name, null))
                return str == null;

            return name._value == str;
        }

        public static bool operator !=(PdfName name, string str)
        {
            if (ReferenceEquals(name, null))
                return str != null;

            return name._value != str;
        }

        public static readonly PdfName Empty = new PdfName("/");

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }

        public static PdfXNameComparer Comparer
        {
            get { return new PdfXNameComparer(); }
        }

        public class PdfXNameComparer : IComparer<PdfName>
        {
            public int Compare(PdfName l, PdfName r)
            {
#if true_
#else
                if (l != null)
                {
                    if (r != null)
                        return String.Compare(l._value, r._value, StringComparison.Ordinal);
                    return -1;
                }
                if (r != null)
                    return 1;
                return 0;
#endif
            }
        }
    }
    public sealed class PdfNameObject : PdfObject
    {
        public PdfNameObject()
        {
            _value = "/";
        }

        public PdfNameObject(PdfDocument document, string value)
            : base(document)
        {
            if (value == null)
                throw new ArgumentNullException("value");
            if (value.Length == 0 || value[0] != '/')
                throw new ArgumentException(PSSR.NameMustStartWithSlash);

            _value = value;
        }

        public override bool Equals(object obj)
        {
            return _value.Equals(obj);
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public string Value
        {
            get { return _value; }
            set { _value = value; }
        }
        string _value;

        public override string ToString()
        {
            return _value;
        }

        public static bool operator ==(PdfNameObject name, string str)
        {
            return name._value == str;
        }

        public static bool operator !=(PdfNameObject name, string str)
        {
            return name._value != str;
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.Write(new PdfName(_value));
            writer.WriteEndObject();
        }
    }
    public sealed class PdfNull : PdfItem
    {
        PdfNull()
        { }

        public override string ToString()
        {
            return "null";
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteRaw(" null ");
        }

        public static readonly PdfNull Value = new PdfNull();
    }
    public sealed class PdfNullObject : PdfObject
    {
        public PdfNullObject()
        { }

        public PdfNullObject(PdfDocument document)
            : base(document)
        { }

        public override string ToString()
        {
            return "null";
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.WriteRaw(" null ");
            writer.WriteEndObject();
        }
    }
    public abstract class PdfNumber : PdfItem
    {
    }
    public abstract class PdfNumberObject : PdfObject
    {
        protected PdfNumberObject()
        { }

        protected PdfNumberObject(PdfDocument document)
            : base(document)
        { }
    }
    public abstract class PdfObject : PdfItem
    {
        protected PdfObject()
        { }

        protected PdfObject(PdfDocument document)
        {
            Document = document;
        }

        protected PdfObject(PdfObject obj)
            : this(obj.Owner)
        {
            if (obj._iref != null)
                obj._iref.Value = this;
        }

        public new PdfObject Clone()
        {
            return (PdfObject)Copy();
        }

        protected override object Copy()
        {
            PdfObject obj = (PdfObject)base.Copy();
            obj._document = null;
            obj._iref = null;
            return obj;
        }


        internal void SetObjectID(int objectNumber, int generationNumber)
        {
            PdfObjectID objectID = new PdfObjectID(objectNumber, generationNumber);

            if (_iref == null)
                _iref = _document._irefTable[objectID];
            if (_iref == null)
            {
                new PdfReference(this);
                Debug.Assert(_iref != null);
                _iref.ObjectID = objectID;
            }
            _iref.Value = this;
            _iref.Document = _document;
        }

        public virtual PdfDocument Owner
        {
            get { return _document; }
        }

        internal virtual PdfDocument Document
        {
            set
            {
                if (!ReferenceEquals(_document, value))
                {
                    if (_document != null)
                        throw new InvalidOperationException("Cannot change document.");
                    _document = value;
                    if (_iref != null)
                        _iref.Document = value;
                }
            }
        }
        internal PdfDocument _document;

        public bool IsIndirect
        {
            get { return _iref != null; }
        }

        public PdfObjectInternals Internals
        {
            get { return _internals ?? (_internals = new PdfObjectInternals(this)); }
        }
        PdfObjectInternals _internals;

        internal virtual void PrepareForSave()
        { }

        internal override void WriteObject(PdfWriter writer)
        {
            Debug.Assert(false, "Must not come here!");
        }

        internal PdfObjectID ObjectID
        {
            get { return _iref != null ? _iref.ObjectID : PdfObjectID.Empty; }
        }

        internal int ObjectNumber
        {
            get { return ObjectID.ObjectNumber; }
        }

        internal int GenerationNumber
        {
            get { return ObjectID.GenerationNumber; }
        }

        internal static PdfObject DeepCopyClosure(PdfDocument owner, PdfObject externalObject)
        {
            PdfObject[] elements = externalObject.Owner.Internals.GetClosure(externalObject);
            int count = elements.Length;
            PdfImportedObjectTable iot = new PdfImportedObjectTable(owner, externalObject.Owner);
            for (int idx = 0; idx < count; idx++)
            {
                PdfObject obj = elements[idx];
                PdfObject clone = obj.Clone();
                Debug.Assert(clone.Reference == null);
                clone.Document = owner;
                if (obj.Reference != null)
                {
                    owner._irefTable.Add(clone);
                    Debug.Assert(clone.Reference != null);
                    iot.Add(obj.ObjectID, clone.Reference);
                }
                else
                {
                    Debug.Assert(idx == 0);
                }
                elements[idx] = clone;
            }

            for (int idx = 0; idx < count; idx++)
            {
                PdfObject obj = elements[idx];
                Debug.Assert(obj.Owner == owner);
                FixUpObject(iot, owner, obj);
            }

            return elements[0];
        }

        internal static PdfObject ImportClosure(PdfImportedObjectTable importedObjectTable, PdfDocument owner, PdfObject externalObject)
        {
            Debug.Assert(ReferenceEquals(importedObjectTable.Owner, owner), "importedObjectTable does not belong to the owner.");
            Debug.Assert(ReferenceEquals(importedObjectTable.ExternalDocument, externalObject.Owner),
                "The ExternalDocument of the importedObjectTable does not belong to the owner of object to be imported.");

            PdfObject[] elements = externalObject.Owner.Internals.GetClosure(externalObject);
            int count = elements.Length;

            for (int idx = 0; idx < count; idx++)
            {
                PdfObject obj = elements[idx];
                Debug.Assert(!ReferenceEquals(obj.Owner, owner));
                if (importedObjectTable.Contains(obj.ObjectID))
                {
                    PdfReference iref = importedObjectTable[obj.ObjectID];
                    Debug.Assert(iref != null);
                    Debug.Assert(iref.Value != null);
                    Debug.Assert(iref.Document == owner);
                    elements[idx] = iref.Value;
                }
                else
                {
                    PdfObject clone = obj.Clone();
                    Debug.Assert(clone.Reference == null);
                    clone.Document = owner;
                    if (obj.Reference != null)
                    {
                        owner._irefTable.Add(clone);
                        Debug.Assert(clone.Reference != null);
                        importedObjectTable.Add(obj.ObjectID, clone.Reference);
                    }
                    else
                    {
                        Debug.Assert(idx == 0);
                    }
                    elements[idx] = clone;
                }
            }
            for (int idx = 0; idx < count; idx++)
            {
                PdfObject obj = elements[idx];
                Debug.Assert(owner != null);
                FixUpObject(importedObjectTable, importedObjectTable.Owner, obj);
            }

            return elements[0];
        }

        static void FixUpObject(PdfImportedObjectTable iot, PdfDocument owner, PdfObject value)
        {
            Debug.Assert(ReferenceEquals(iot.Owner, owner));

            PdfDictionary dict;
            PdfArray array;
            if ((dict = value as PdfDictionary) != null)
            {
                if (dict.Owner == null)
                {
                    dict.Document = owner;
                }
                else
                {
                    Debug.Assert(dict.Owner == owner);
                }

                PdfName[] names = dict.Elements.KeyNames;
                foreach (PdfName name in names)
                {
                    PdfItem item = dict.Elements[name];
                    Debug.Assert(item != null, "A dictionary element cannot be null.");

                    PdfReference iref = item as PdfReference;
                    if (iref != null)
                    {
                        if (iref.Document == owner)
                        {
                            continue;
                        }

                        PdfReference newXRef = iot[iref.ObjectID];
                        Debug.Assert(newXRef != null);
                        Debug.Assert(newXRef.Document == owner);
                        dict.Elements[name] = newXRef;
                    }
                    else
                    {
                        PdfObject pdfObject = item as PdfObject;
                        if (pdfObject != null)
                        {
                            FixUpObject(iot, owner, pdfObject);
                        }
                        else
                        {
                            DebugCheckNonObjects(item);
                        }
                    }
                }
            }
            else if ((array = value as PdfArray) != null)
            {
                if (array.Owner == null)
                {
                    array.Document = owner;
                }
                else
                {
                    Debug.Assert(array.Owner == owner);
                }

                int count = array.Elements.Count;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfItem item = array.Elements[idx];
                    Debug.Assert(item != null, "An array element cannot be null.");

                    PdfReference iref = item as PdfReference;
                    if (iref != null)
                    {
                        if (iref.Document == owner)
                        {
                            continue;
                        }

                        Debug.Assert(iref.Document == iot.ExternalDocument);
                        PdfReference newXRef = iot[iref.ObjectID];
                        Debug.Assert(newXRef != null);
                        Debug.Assert(newXRef.Document == owner);
                        array.Elements[idx] = newXRef;
                    }
                    else
                    {
                        PdfObject pdfObject = item as PdfObject;
                        if (pdfObject != null)
                        {
                            FixUpObject(iot, owner, pdfObject);
                        }
                        else
                        {
                            DebugCheckNonObjects(item);
                        }
                    }
                }
            }
            else
            {
                if (value is PdfNameObject || value is PdfStringObject || value is PdfBooleanObject || value is PdfIntegerObject || value is PdfNumberObject)
                {
                    Debug.Assert(value.IsIndirect);
                    Debug.Assert(value.Owner == owner);
                }
                else
                    Debug.Assert(false, "Should not come here. Object is neither a dictionary nor an array.");
            }
        }

        [Conditional("DEBUG")]
        static void DebugCheckNonObjects(PdfItem item)
        {
            if (item is PdfName)
                return;
            if (item is PdfBoolean)
                return;
            if (item is PdfInteger)
                return;
            if (item is PdfNumber)
                return;
            if (item is PdfString)
                return;
            if (item is PdfRectangle)
                return;
            if (item is PdfNull)
                return;

            Type type = item.GetType();
            Debug.Assert(type != null, string.Format("CheckNonObjects: Add {0} to the list.", type.Name));
        }

        public PdfReference Reference
        {
            get { return _iref; }

            internal set { _iref = value; }
        }
        PdfReference _iref;
    }
    public struct PdfObjectID : IComparable
    {
        public PdfObjectID(int objectNumber)
        {
            Debug.Assert(objectNumber >= 1, "Object number out of range.");
            _objectNumber = objectNumber;
            _generationNumber = 0;
        }

        public PdfObjectID(int objectNumber, int generationNumber)
        {
            Debug.Assert(objectNumber >= 1, "Object number out of range.");
            _objectNumber = objectNumber;
            _generationNumber = (ushort)generationNumber;
        }

        public int ObjectNumber
        {
            get { return _objectNumber; }
        }
        readonly int _objectNumber;

        public int GenerationNumber
        {
            get { return _generationNumber; }
        }
        readonly ushort _generationNumber;

        public bool IsEmpty
        {
            get { return _objectNumber == 0; }
        }

        public override bool Equals(object obj)
        {
            if (obj is PdfObjectID)
            {
                PdfObjectID id = (PdfObjectID)obj;
                if (_objectNumber == id._objectNumber)
                    return _generationNumber == id._generationNumber;
            }
            return false;
        }

        public override int GetHashCode()
        {
            return _objectNumber ^ _generationNumber;
        }

        public static bool operator ==(PdfObjectID left, PdfObjectID right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(PdfObjectID left, PdfObjectID right)
        {
            return !left.Equals(right);
        }

        public override string ToString()
        {
            return _objectNumber.ToString(CultureInfo.InvariantCulture) + " " + _generationNumber.ToString(CultureInfo.InvariantCulture);
        }

        public static PdfObjectID Empty
        {
            get { return new PdfObjectID(); }
        }

        public int CompareTo(object obj)
        {
            if (obj is PdfObjectID)
            {
                PdfObjectID id = (PdfObjectID)obj;
                if (_objectNumber == id._objectNumber)
                    return _generationNumber - id._generationNumber;
                return _objectNumber - id._objectNumber;
            }
            return 1;
        }

        internal string DebuggerDisplay
        {
            get { return String.Format("id=({0})", ToString()); }
        }
    }
    public sealed class PdfOutline : PdfDictionary
    {
        public PdfOutline()
        {
        }

        internal PdfOutline(PdfDocument document)
            : base(document)
        {
        }

        public PdfOutline(PdfDictionary dict)
            : base(dict)
        {
            Initialize();
        }

        public PdfOutline(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style, XColor textColor)
        {
            Title = title;
            DestinationPage = destinationPage;
            Opened = opened;
            Style = style;
            TextColor = textColor;
        }

        public PdfOutline(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style)
        {
            Title = title;
            DestinationPage = destinationPage;
            Opened = opened;
            Style = style;
        }

        public PdfOutline(string title, PdfPage destinationPage, bool opened)
        {
            Title = title;
            DestinationPage = destinationPage;
            Opened = opened;
        }

        public PdfOutline(string title, PdfPage destinationPage)
        {
            Title = title;
            DestinationPage = destinationPage;
        }

        internal int Count
        {
            get { return _count; }
            set { _count = value; }
        }
        int _count;

        internal int OpenCount;

        internal int CountOpen()
        {
            int count = _opened ? 1 : 0;
            if (_outlines != null)
                count += _outlines.CountOpen();
            return count;
        }

        public PdfOutline Parent
        {
            get { return _parent; }
            internal set { _parent = value; }
        }
        PdfOutline _parent;

        public string Title
        {
            get { return Elements.GetString(Keys.Title); }
            set
            {
                PdfString s = new PdfString(value, PdfStringEncoding.Unicode);
                Elements.SetValue(Keys.Title, s);
            }
        }

        public PdfPage DestinationPage
        {
            get { return _destinationPage; }
            set { _destinationPage = value; }
        }
        PdfPage _destinationPage;

        public double? Left
        {
            get { return _left; }
            set { _left = value; }
        }
        double? _left = null;

        public double? Top
        {
            get { return _top; }
            set { _top = value; }
        }
        double? _top = null;

        public double Right
        {
            get { return _right; }
            set { _right = value; }
        }
        double _right = double.NaN;

        public double Bottom
        {
            get { return _bottom; }
            set { _bottom = value; }
        }
        double _bottom = double.NaN;

        public double? Zoom
        {
            get { return _zoom; }
            set
            {
                if (value.HasValue && value.Value == 0)
                    _zoom = null;
                else
                    _zoom = value;
            }
        }
        double? _zoom;

        public bool Opened
        {
            get { return _opened; }
#if true
            set { _opened = value; }
#endif
        }
        bool _opened;

        public PdfOutlineStyle Style
        {
            get { return (PdfOutlineStyle)Elements.GetInteger(Keys.F); }
            set { Elements.SetInteger(Keys.F, (int)value); }
        }

        public PdfPageDestinationType PageDestinationType
        {
            get { return _pageDestinationType; }
            set { _pageDestinationType = value; }
        }
        PdfPageDestinationType _pageDestinationType = PdfPageDestinationType.Xyz;

        public XColor TextColor
        {
            get { return _textColor; }
            set { _textColor = value; }
        }
        XColor _textColor;

        public bool HasChildren
        {
            get { return _outlines != null && _outlines.Count > 0; }
        }

        public PdfOutlineCollection Outlines
        {
            get { return _outlines ?? (_outlines = new PdfOutlineCollection(Owner, this)); }
        }
        PdfOutlineCollection _outlines;

        void Initialize()
        {
            string title;
            if (Elements.TryGetString(Keys.Title, out title))
                Title = title;

            PdfReference parentRef = Elements.GetReference(Keys.Parent);
            if (parentRef != null)
            {
                PdfOutline parent = parentRef.Value as PdfOutline;
                if (parent != null)
                    Parent = parent;
            }

            Count = Elements.GetInteger(Keys.Count);

            PdfArray colors = Elements.GetArray(Keys.C);
            if (colors != null && colors.Elements.Count == 3)
            {
                double r = colors.Elements.GetReal(0);
                double g = colors.Elements.GetReal(1);
                double b = colors.Elements.GetReal(2);
                TextColor = XColor.FromArgb((int)(r * 255), (int)(g * 255), (int)(b * 255));
            }

            PdfItem dest = Elements.GetValue(Keys.Dest);
            PdfItem a = Elements.GetValue(Keys.A);
            Debug.Assert(dest == null || a == null, "Either destination or goto action.");

            PdfArray destArray = null;
            if (dest != null)
            {
                destArray = dest as PdfArray;
                if (destArray != null)
                {
                    SplitDestinationPage(destArray);
                }
                else
                {
                    Debug.Assert(false, "See what to do when this happened.");
                }
            }
            else if (a != null)
            {
                PdfDictionary action = a as PdfDictionary;
                if (action != null && action.Elements.GetName(PdfAction.Keys.S) == "/GoTo")
                {
                    dest = action.Elements[PdfGoToAction.Keys.D];
                    destArray = dest as PdfArray;
                    if (destArray != null)
                    {
                        Elements.Remove(Keys.A);
                        Elements.Add(Keys.Dest, destArray);
                        SplitDestinationPage(destArray);
                    }
                    else
                    {
                        throw new Exception("Destination Array expected.");
                    }
                }
                else
                {
                    Debug.Assert(false, "See what to do when this happened.");
                }
            }
            else
            {
            }

            InitializeChildren();
        }

        void SplitDestinationPage(PdfArray destination)
        {

            PdfDictionary destPage = (PdfDictionary)((PdfReference)destination.Elements[0]).Value;
            PdfPage page = destPage as PdfPage;
            if (page == null)
                page = new PdfPage(destPage);

            DestinationPage = page;
            PdfName type = destination.Elements[1] as PdfName;
            if (type != null)
            {
                PageDestinationType = (PdfPageDestinationType)Enum.Parse(typeof(PdfPageDestinationType), type.Value.Substring(1), true);
                switch (PageDestinationType)
                {
                    case PdfPageDestinationType.Xyz:
                        Left = destination.Elements.GetNullableReal(2);
                        Top = destination.Elements.GetNullableReal(3);
                        Zoom = destination.Elements.GetNullableReal(4);
                        break;

                    case PdfPageDestinationType.Fit:
                        break;

                    case PdfPageDestinationType.FitH:
                        Top = destination.Elements.GetNullableReal(2);
                        break;

                    case PdfPageDestinationType.FitV:
                        Left = destination.Elements.GetNullableReal(2);
                        break;

                    case PdfPageDestinationType.FitR:
                        Left = destination.Elements.GetReal(2);
                        Bottom = destination.Elements.GetReal(3);
                        Right = destination.Elements.GetReal(4);
                        Top = destination.Elements.GetReal(5);
                        break;

                    case PdfPageDestinationType.FitB:
                        break;

                    case PdfPageDestinationType.FitBH:
                        Top = destination.Elements.GetReal(2);
                        break;

                    case PdfPageDestinationType.FitBV:
                        Left = destination.Elements.GetReal(2);
                        break;

                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

        }

        void InitializeChildren()
        {
            PdfReference firstRef = Elements.GetReference(Keys.First);
            PdfReference lastRef = Elements.GetReference(Keys.Last);
            PdfReference current = firstRef;
            while (current != null)
            {
                PdfOutline item = new PdfOutline((PdfDictionary)current.Value);
                Outlines.Add(item);

                current = item.Elements.GetReference(Keys.Next);
            }
        }

        internal override void PrepareForSave()
        {
            bool hasKids = HasChildren;
            if (_parent != null || hasKids)
            {
                if (_parent == null)
                {
                    Debug.Assert(_outlines != null && _outlines.Count > 0 && _outlines[0] != null);
                    Elements[Keys.First] = _outlines[0].Reference;
                    Elements[Keys.Last] = _outlines[_outlines.Count - 1].Reference;

                    if (OpenCount > 0)
                        Elements[Keys.Count] = new PdfInteger(OpenCount);
                }
                else
                {
                    Elements[Keys.Parent] = _parent.Reference;

                    int count = _parent._outlines.Count;
                    int index = _parent._outlines.IndexOf(this);
                    Debug.Assert(index != -1);

                    if (DestinationPage != null)
                        Elements[Keys.Dest] = CreateDestArray();

                    if (index > 0)
                        Elements[Keys.Prev] = _parent._outlines[index - 1].Reference;

                    if (index < count - 1)
                        Elements[Keys.Next] = _parent._outlines[index + 1].Reference;

                    if (hasKids)
                    {
                        Elements[Keys.First] = _outlines[0].Reference;
                        Elements[Keys.Last] = _outlines[_outlines.Count - 1].Reference;
                    }
                    if (OpenCount > 0)
                        Elements[Keys.Count] = new PdfInteger((_opened ? 1 : -1) * OpenCount);

                    if (_textColor != XColor.Empty && Owner.HasVersion("1.4"))
                        Elements[Keys.C] = new PdfLiteral("[{0}]", PdfEncoders.ToString(_textColor, PdfColorMode.Rgb));

                }

                if (hasKids)
                {
                    foreach (PdfOutline outline in _outlines)
                        outline.PrepareForSave();
                }
            }
        }

        PdfArray CreateDestArray()
        {
            PdfArray dest = null;
            switch (PageDestinationType)
            {
                case PdfPageDestinationType.Xyz:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral(String.Format("/XYZ {0} {1} {2}", Fd(Left), Fd(Top), Fd(Zoom))));
                    break;

                case PdfPageDestinationType.Fit:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral("/Fit"));
                    break;

                case PdfPageDestinationType.FitH:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral(String.Format("/FitH {0}", Fd(Top))));
                    break;

                case PdfPageDestinationType.FitV:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral(String.Format("/FitV {0}", Fd(Left))));
                    break;

                case PdfPageDestinationType.FitR:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral(String.Format("/FitR {0} {1} {2} {3}", Fd(Left), Fd(Bottom), Fd(Right), Fd(Top))));
                    break;

                case PdfPageDestinationType.FitB:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral("/FitB"));
                    break;

                case PdfPageDestinationType.FitBH:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral(String.Format("/FitBH {0}", Fd(Top))));
                    break;

                case PdfPageDestinationType.FitBV:
                    dest = new PdfArray(Owner,
                        DestinationPage.Reference, new PdfLiteral(String.Format("/FitBV {0}", Fd(Left))));
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }
            return dest;
        }

        string Fd(double value)
        {
            if (Double.IsNaN(value))
                throw new InvalidOperationException("Value is not a valid Double.");
            return value.ToString("#.##", CultureInfo.InvariantCulture);

        }

        string Fd(double? value)
        {
            return value.HasValue ? value.Value.ToString("#.##", CultureInfo.InvariantCulture) : "null";
        }

        internal override void WriteObject(PdfWriter writer)
        {
            bool hasKids = HasChildren;
            if (_parent != null || hasKids)
            {
                base.WriteObject(writer);
            }
        }


        internal sealed class Keys : KeysBase
        {
            [KeyInfo(KeyType.Name | KeyType.Optional, FixedValue = "Outlines")]
            public const string Type = "/Type";

            [KeyInfo(KeyType.String | KeyType.Required)]
            public const string Title = "/Title";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string Parent = "/Parent";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string Prev = "/Prev";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string Next = "/Next";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string First = "/First";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string Last = "/Last";

            [KeyInfo(KeyType.Integer | KeyType.Required)]
            public const string Count = "/Count";

            [KeyInfo(KeyType.ArrayOrNameOrString | KeyType.Optional)]
            public const string Dest = "/Dest";

            [KeyInfo(KeyType.Dictionary | KeyType.Optional)]
            public const string A = "/A";

            [KeyInfo(KeyType.Dictionary | KeyType.Optional)]
            public const string SE = "/SE";

            [KeyInfo(KeyType.Array | KeyType.Optional)]
            public const string C = "/C";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string F = "/F";

            public static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;

        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public class PdfOutlineCollection : PdfObject, ICollection<PdfOutline>, IList<PdfOutline>
    {
        internal PdfOutlineCollection(PdfDocument document, PdfOutline parent)
            : base(document)
        {
            _parent = parent;
        }

        [Obsolete("Use 'Count > 0' - HasOutline will throw exception.")]
        public bool HasOutline
        {
            get
            {
                throw new InvalidOperationException("Use 'Count > 0'");
            }
        }

        public bool Remove(PdfOutline item)
        {
            if (_outlines.Remove(item))
            {
                RemoveFromOutlinesTree(item);
                return true;
            }
            return false;
        }

        public int Count
        {
            get { return _outlines.Count; }
        }

        public bool IsReadOnly
        {
            get { return false; }
        }

        public void Add(PdfOutline outline)
        {
            if (outline == null)
                throw new ArgumentNullException("outline");

            if (outline.DestinationPage != null && !ReferenceEquals(Owner, outline.DestinationPage.Owner))
                throw new ArgumentException("Destination page must belong to this document.");

            AddToOutlinesTree(outline);
            _outlines.Add(outline);

            if (outline.Opened)
            {
                outline = _parent;
                while (outline != null)
                {
                    outline.OpenCount++;
                    outline = outline.Parent;
                }
            }
        }

        public void Clear()
        {
            if (Count > 0)
            {
                PdfOutline[] array = new PdfOutline[Count];
                _outlines.CopyTo(array);
                _outlines.Clear();
                foreach (PdfOutline item in array)
                {
                    RemoveFromOutlinesTree(item);
                }
            }
        }

        public bool Contains(PdfOutline item)
        {
            return _outlines.Contains(item);
        }

        public void CopyTo(PdfOutline[] array, int arrayIndex)
        {
            _outlines.CopyTo(array, arrayIndex);
        }

        public PdfOutline Add(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style, XColor textColor)
        {
            PdfOutline outline = new PdfOutline(title, destinationPage, opened, style, textColor);
            Add(outline);
            return outline;
        }

        public PdfOutline Add(string title, PdfPage destinationPage, bool opened, PdfOutlineStyle style)
        {
            PdfOutline outline = new PdfOutline(title, destinationPage, opened, style);
            Add(outline);
            return outline;
        }

        public PdfOutline Add(string title, PdfPage destinationPage, bool opened)
        {
            PdfOutline outline = new PdfOutline(title, destinationPage, opened);
            Add(outline);
            return outline;
        }

        public PdfOutline Add(string title, PdfPage destinationPage)
        {
            PdfOutline outline = new PdfOutline(title, destinationPage);
            Add(outline);
            return outline;
        }

        public int IndexOf(PdfOutline item)
        {
            return _outlines.IndexOf(item);
        }

        public void Insert(int index, PdfOutline outline)
        {
            if (outline == null)
                throw new ArgumentNullException("outline");
            if (index < 0 || index >= _outlines.Count)
                throw new ArgumentOutOfRangeException("index", index, PSSR.OutlineIndexOutOfRange);

            AddToOutlinesTree(outline);
            _outlines.Insert(index, outline);
        }

        public void RemoveAt(int index)
        {
            PdfOutline outline = _outlines[index];
            _outlines.RemoveAt(index);
            RemoveFromOutlinesTree(outline);
        }

        public PdfOutline this[int index]
        {
            get
            {
                if (index < 0 || index >= _outlines.Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.OutlineIndexOutOfRange);
                return _outlines[index];
            }
            set
            {
                if (index < 0 || index >= _outlines.Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.OutlineIndexOutOfRange);
                if (value == null)
                    throw new ArgumentOutOfRangeException("value", null, PSSR.SetValueMustNotBeNull);

                AddToOutlinesTree(value);
                _outlines[index] = value;
            }
        }

        public IEnumerator<PdfOutline> GetEnumerator()
        {
            return _outlines.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        internal int CountOpen()
        {
            int count = 0;
            return count;
        }

        void AddToOutlinesTree(PdfOutline outline)
        {
            if (outline == null)
                throw new ArgumentNullException("outline");

            if (outline.DestinationPage != null && !ReferenceEquals(Owner, outline.DestinationPage.Owner))
                throw new ArgumentException("Destination page must belong to this document.");

            outline.Document = Owner;
            outline.Parent = _parent;

            if (!Owner._irefTable.Contains(outline.ObjectID))
                Owner._irefTable.Add(outline);
            else
            {
                outline.GetType();
            }

        }

        void RemoveFromOutlinesTree(PdfOutline outline)
        {
            if (outline == null)
                throw new ArgumentNullException("outline");

            outline.Parent = null;

            Owner._irefTable.Remove(outline.Reference);
        }

        readonly PdfOutline _parent;

        readonly List<PdfOutline> _outlines = new List<PdfOutline>();
    }
    public sealed class PdfPage : PdfDictionary, IContentStream
    {
        public PdfPage()
        {
            Elements.SetName(Keys.Type, "/Page");
            Initialize();
        }

        public PdfPage(PdfDocument document)
            : base(document)
        {
            Elements.SetName(Keys.Type, "/Page");
            Elements[Keys.Parent] = document.Pages.Reference;
            Initialize();
        }

        internal PdfPage(PdfDictionary dict)
            : base(dict)
        {
            int rotate = Elements.GetInteger(InheritablePageKeys.Rotate);
            if (Math.Abs((rotate / 90)) % 2 == 1)
            {
#if true
                _orientation = PageOrientation.Landscape;
                _orientationSetByCodeForRotatedDocument = true;
#endif
            }
        }

        void Initialize()
        {
            Size = RegionInfo.CurrentRegion.IsMetric ? PageSize.A4 : PageSize.Letter;
            PdfRectangle rect = MediaBox;
        }

        public object Tag
        {
            get { return _tag; }
            set { _tag = value; }
        }
        object _tag;

        public void Close()
        {
            _closed = true;
        }
        bool _closed;

        internal bool IsClosed
        {
            get { return _closed; }
        }

        internal override PdfDocument Document
        {
            set
            {
                if (!ReferenceEquals(_document, value))
                {
                    if (_document != null)
                        throw new InvalidOperationException("Cannot change document.");
                    _document = value;
                    if (Reference != null)
                        Reference.Document = value;
                    Elements[Keys.Parent] = _document.Pages.Reference;
                }
            }
        }

        public PageOrientation Orientation
        {
            get { return _orientation; }
            set
            {
                _orientation = value;
                _orientationSetByCodeForRotatedDocument = false;
            }
        }
        PageOrientation _orientation;
        bool _orientationSetByCodeForRotatedDocument;
        public PageSize Size
        {
            get { return _pageSize; }
            set
            {
                if (!Enum.IsDefined(typeof(PageSize), value))
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(PageSize));

                XSize size = PageSizeConverter.ToSize(value);
                MediaBox = new PdfRectangle(0, 0, size.Width, size.Height);
                _pageSize = value;
            }
        }
        PageSize _pageSize;

        public TrimMargins TrimMargins
        {
            get
            {
                if (_trimMargins == null)
                    _trimMargins = new TrimMargins();
                return _trimMargins;
            }
            set
            {
                if (_trimMargins == null)
                    _trimMargins = new TrimMargins();
                if (value != null)
                {
                    _trimMargins.Left = value.Left;
                    _trimMargins.Right = value.Right;
                    _trimMargins.Top = value.Top;
                    _trimMargins.Bottom = value.Bottom;
                }
                else
                    _trimMargins.All = 0;
            }
        }
        TrimMargins _trimMargins = new TrimMargins();

        public PdfRectangle MediaBox
        {
            get { return Elements.GetRectangle(Keys.MediaBox, true); }
            set { Elements.SetRectangle(Keys.MediaBox, value); }
        }

        public PdfRectangle CropBox
        {
            get { return Elements.GetRectangle(Keys.CropBox, true); }
            set { Elements.SetRectangle(Keys.CropBox, value); }
        }

        public PdfRectangle BleedBox
        {
            get { return Elements.GetRectangle(Keys.BleedBox, true); }
            set { Elements.SetRectangle(Keys.BleedBox, value); }
        }

        public PdfRectangle ArtBox
        {
            get { return Elements.GetRectangle(Keys.ArtBox, true); }
            set { Elements.SetRectangle(Keys.ArtBox, value); }
        }

        public PdfRectangle TrimBox
        {
            get { return Elements.GetRectangle(Keys.TrimBox, true); }
            set { Elements.SetRectangle(Keys.TrimBox, value); }
        }

        public XUnit Height
        {
            get
            {
                PdfRectangle rect = MediaBox;
                return _orientation == PageOrientation.Portrait ? rect.Height : rect.Width;
            }
            set
            {
                PdfRectangle rect = MediaBox;
                if (_orientation == PageOrientation.Portrait)
                    MediaBox = new PdfRectangle(rect.X1, 0, rect.X2, value);
                else
                    MediaBox = new PdfRectangle(0, rect.Y1, value, rect.Y2);
                _pageSize = PageSize.Undefined;
            }
        }

        public XUnit Width
        {
            get
            {
                PdfRectangle rect = MediaBox;
                return _orientation == PageOrientation.Portrait ? rect.Width : rect.Height;
            }
            set
            {
                PdfRectangle rect = MediaBox;
                if (_orientation == PageOrientation.Portrait)
                    MediaBox = new PdfRectangle(0, rect.Y1, value, rect.Y2);
                else
                    MediaBox = new PdfRectangle(rect.X1, 0, rect.X2, value);
                _pageSize = PageSize.Undefined;
            }
        }

        public int Rotate
        {
            get { return _elements.GetInteger(InheritablePageKeys.Rotate); }
            set
            {
                if (value % 90 != 0)
                    throw new ArgumentException("Value must be a multiple of 90.");
                _elements.SetInteger(InheritablePageKeys.Rotate, value);
            }
        }

        internal PdfContent RenderContent;

        public PdfContents Contents
        {
            get
            {
                if (_contents == null)
                {
                    if (true)
                    {
                        PdfItem item = Elements[Keys.Contents];
                        if (item == null)
                        {
                            _contents = new PdfContents(Owner);
                        }
                        else
                        {
                            if (item is PdfReference)
                                item = ((PdfReference)item).Value;

                            PdfArray array = item as PdfArray;
                            if (array != null)
                            {
                                if (array.IsIndirect)
                                {
                                    array = array.Clone();
                                    array.Document = Owner;
                                }
                                _contents = new PdfContents(array);
                            }
                            else
                            {
                                _contents = new PdfContents(Owner);
                                PdfContent content = new PdfContent((PdfDictionary)item);
                                _contents.Elements.Add(content.Reference);
                            }
                        }
                    }
                    Debug.Assert(_contents.Reference == null);
                    Elements[Keys.Contents] = _contents;
                }
                return _contents;
            }
        }
        PdfContents _contents;

        public bool HasAnnotations
        {
            get
            {
                if (_annotations == null)
                {
                    _annotations = (PdfAnnotations)Elements.GetValue(Keys.Annots);
                    _annotations.Page = this;
                }
                return _annotations != null;
            }
        }

        public PdfAnnotations Annotations
        {
            get
            {
                if (_annotations == null)
                {
                    _annotations = (PdfAnnotations)Elements.GetValue(Keys.Annots, VCF.Create);
                    _annotations.Page = this;
                }
                return _annotations;
            }
        }
        PdfAnnotations _annotations;

        public PdfLinkAnnotation AddDocumentLink(PdfRectangle rect, int destinationPage)
        {
            PdfLinkAnnotation annotation = PdfLinkAnnotation.CreateDocumentLink(rect, destinationPage);
            Annotations.Add(annotation);
            return annotation;
        }

        public PdfLinkAnnotation AddWebLink(PdfRectangle rect, string url)
        {
            PdfLinkAnnotation annotation = PdfLinkAnnotation.CreateWebLink(rect, url);
            Annotations.Add(annotation);
            return annotation;
        }

        public PdfLinkAnnotation AddFileLink(PdfRectangle rect, string fileName)
        {
            PdfLinkAnnotation annotation = PdfLinkAnnotation.CreateFileLink(rect, fileName);
            Annotations.Add(annotation);
            return annotation;
        }

        public PdfCustomValues CustomValues
        {
            get
            {
                if (_customValues == null)
                    _customValues = PdfCustomValues.Get(Elements);
                return _customValues;
            }
            set
            {
                if (value != null)
                    throw new ArgumentException("Only null is allowed to clear all custom values.");
                PdfCustomValues.Remove(Elements);
                _customValues = null;
            }
        }
        PdfCustomValues _customValues;

        public PdfResources Resources
        {
            get
            {
                if (_resources == null)
                    _resources = (PdfResources)Elements.GetValue(Keys.Resources, VCF.Create);
                return _resources;
            }
        }
        PdfResources _resources;

        PdfResources IContentStream.Resources
        {
            get { return Resources; }
        }

        internal string GetFontName(XFont font, out PdfFont pdfFont)
        {
            pdfFont = _document.FontTable.GetFont(font);
            Debug.Assert(pdfFont != null);
            string name = Resources.AddFont(pdfFont);
            return name;
        }

        string IContentStream.GetFontName(XFont font, out PdfFont pdfFont)
        {
            return GetFontName(font, out pdfFont);
        }

        internal string TryGetFontName(string idName, out PdfFont pdfFont)
        {
            pdfFont = _document.FontTable.TryGetFont(idName);
            string name = null;
            if (pdfFont != null)
                name = Resources.AddFont(pdfFont);
            return name;
        }

        internal string GetFontName(string idName, byte[] fontData, out PdfFont pdfFont)
        {
            pdfFont = _document.FontTable.GetFont(idName, fontData);
            Debug.Assert(pdfFont != null);
            string name = Resources.AddFont(pdfFont);
            return name;
        }

        string IContentStream.GetFontName(string idName, byte[] fontData, out PdfFont pdfFont)
        {
            return GetFontName(idName, fontData, out pdfFont);
        }

        internal string GetImageName(XImage image)
        {
            PdfImage pdfImage = _document.ImageTable.GetImage(image);
            Debug.Assert(pdfImage != null);
            string name = Resources.AddImage(pdfImage);
            return name;
        }

        string IContentStream.GetImageName(XImage image)
        {
            return GetImageName(image);
        }

        internal string GetFormName(XForm form)
        {
            PdfFormXObject pdfForm = _document.FormTable.GetForm(form);
            Debug.Assert(pdfForm != null);
            string name = Resources.AddForm(pdfForm);
            return name;
        }

        string IContentStream.GetFormName(XForm form)
        {
            return GetFormName(form);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            PdfRectangle mediaBox = MediaBox;
            if (_orientation == PageOrientation.Landscape && !_orientationSetByCodeForRotatedDocument)
                MediaBox = new PdfRectangle(mediaBox.X1, mediaBox.Y1, mediaBox.Y2, mediaBox.X2);

#if true
            TransparencyUsed = true;
            if (TransparencyUsed && !Elements.ContainsKey(Keys.Group) &&
                _document.Options.ColorMode != PdfColorMode.Undefined)
            {
                PdfDictionary group = new PdfDictionary();
                _elements["/Group"] = group;
                if (_document.Options.ColorMode != PdfColorMode.Cmyk)
                    group.Elements.SetName("/CS", "/DeviceRGB");
                else
                    group.Elements.SetName("/CS", "/DeviceCMYK");
                group.Elements.SetName("/S", "/Transparency");
            }
#endif

            base.WriteObject(writer);

            if (_orientation == PageOrientation.Landscape && !_orientationSetByCodeForRotatedDocument)
                MediaBox = mediaBox;
        }

        internal bool TransparencyUsed;

        internal static void InheritValues(PdfDictionary page, InheritedValues values)
        {
            if (values.Resources != null)
            {
                PdfDictionary resources;
                PdfItem res = page.Elements[InheritablePageKeys.Resources];
                if (res is PdfReference)
                {
                    resources = (PdfDictionary)((PdfReference)res).Value.Clone();
                    resources.Document = page.Owner;
                }
                else
                    resources = (PdfDictionary)res;

                if (resources == null)
                {
                    resources = values.Resources.Clone();
                    resources.Document = page.Owner;
                    page.Elements.Add(InheritablePageKeys.Resources, resources);
                }
                else
                {
                    foreach (PdfName name in values.Resources.Elements.KeyNames)
                    {
                        if (!resources.Elements.ContainsKey(name.Value))
                        {
                            PdfItem item = values.Resources.Elements[name];
                            if (item is PdfObject)
                                item = item.Clone();
                            resources.Elements.Add(name.ToString(), item);
                        }
                    }
                }
            }

            if (values.MediaBox != null && page.Elements[InheritablePageKeys.MediaBox] == null)
                page.Elements[InheritablePageKeys.MediaBox] = values.MediaBox;

            if (values.CropBox != null && page.Elements[InheritablePageKeys.CropBox] == null)
                page.Elements[InheritablePageKeys.CropBox] = values.CropBox;

            if (values.Rotate != null && page.Elements[InheritablePageKeys.Rotate] == null)
                page.Elements[InheritablePageKeys.Rotate] = values.Rotate;
        }

        internal static void InheritValues(PdfDictionary page, ref InheritedValues values)
        {
            PdfItem item = page.Elements[InheritablePageKeys.Resources];
            if (item != null)
            {
                PdfReference reference = item as PdfReference;
                if (reference != null)
                    values.Resources = (PdfDictionary)(reference.Value);
                else
                    values.Resources = (PdfDictionary)item;
            }

            item = page.Elements[InheritablePageKeys.MediaBox];
            if (item != null)
                values.MediaBox = new PdfRectangle(item);

            item = page.Elements[InheritablePageKeys.CropBox];
            if (item != null)
                values.CropBox = new PdfRectangle(item);

            item = page.Elements[InheritablePageKeys.Rotate];
            if (item != null)
            {
                if (item is PdfReference)
                    item = ((PdfReference)item).Value;
                values.Rotate = (PdfInteger)item;
            }
        }

        internal override void PrepareForSave()
        {
            if (_trimMargins.AreSet)
            {
                double width = _trimMargins.Left.Point + Width.Point + _trimMargins.Right.Point;
                double height = _trimMargins.Top.Point + Height.Point + _trimMargins.Bottom.Point;

                MediaBox = new PdfRectangle(0, 0, width, height);
                CropBox = new PdfRectangle(0, 0, width, height);
                BleedBox = new PdfRectangle(0, 0, width, height);

                PdfRectangle rect = new PdfRectangle(_trimMargins.Left.Point, _trimMargins.Top.Point,
                  width - _trimMargins.Right.Point, height - _trimMargins.Bottom.Point);
                TrimBox = rect;
                ArtBox = rect.Clone();
            }
        }

        internal sealed class Keys : InheritablePageKeys
        {
            [KeyInfo(KeyType.Name | KeyType.Required, FixedValue = "Page")]
            public const string Type = "/Type";

            [KeyInfo(KeyType.Dictionary | KeyType.Required | KeyType.MustBeIndirect)]
            public const string Parent = "/Parent";

            [KeyInfo(KeyType.Date)]
            public const string LastModified = "/LastModified";

            [KeyInfo("1.3", KeyType.Rectangle | KeyType.Optional)]
            public const string BleedBox = "/BleedBox";

            [KeyInfo("1.3", KeyType.Rectangle | KeyType.Optional)]
            public const string TrimBox = "/TrimBox";

            [KeyInfo("1.3", KeyType.Rectangle | KeyType.Optional)]
            public const string ArtBox = "/ArtBox";

            [KeyInfo("1.4", KeyType.Dictionary | KeyType.Optional)]
            public const string BoxColorInfo = "/BoxColorInfo";

            [KeyInfo(KeyType.Array | KeyType.Stream | KeyType.Optional)]
            public const string Contents = "/Contents";

            [KeyInfo("1.4", KeyType.Dictionary | KeyType.Optional)]
            public const string Group = "/Group";

            [KeyInfo(KeyType.Stream | KeyType.Optional)]
            public const string Thumb = "/Thumb";

            [KeyInfo("1.1", KeyType.Array | KeyType.Optional)]
            public const string B = "/B";

            [KeyInfo("1.1", KeyType.Real | KeyType.Optional)]
            public const string Dur = "/Dur";

            [KeyInfo("1.1", KeyType.Dictionary | KeyType.Optional)]
            public const string Trans = "/Trans";

            [KeyInfo(KeyType.Array | KeyType.Optional, typeof(PdfAnnotations))]
            public const string Annots = "/Annots";

            [KeyInfo("1.2", KeyType.Dictionary | KeyType.Optional)]
            public const string AA = "/AA";

            [KeyInfo("1.4", KeyType.Stream | KeyType.Optional)]
            public const string Metadata = "/Metadata";

            [KeyInfo("1.3", KeyType.Dictionary | KeyType.Optional)]
            public const string PieceInfo = "/PieceInfo";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string StructParents = "/StructParents";

            [KeyInfo("1.3", KeyType.String | KeyType.Optional)]
            public const string ID = "/ID";

            [KeyInfo("1.3", KeyType.Real | KeyType.Optional)]
            public const string PZ = "/PZ";

            [KeyInfo("1.3", KeyType.Dictionary | KeyType.Optional)]
            public const string SeparationInfo = "/SeparationInfo";

            [KeyInfo("1.5", KeyType.Name | KeyType.Optional)]
            public const string Tabs = "/Tabs";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string TemplateInstantiated = "/TemplateInstantiated";

            [KeyInfo("1.5", KeyType.Dictionary | KeyType.Optional)]
            public const string PresSteps = "/PresSteps";

            [KeyInfo("1.6", KeyType.Real | KeyType.Optional)]
            public const string UserUnit = "/UserUnit";

            [KeyInfo("1.6", KeyType.Dictionary | KeyType.Optional)]
            public const string VP = "/VP";

            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }

        internal class InheritablePageKeys : KeysBase
        {
            [KeyInfo(KeyType.Dictionary | KeyType.Required | KeyType.Inheritable, typeof(PdfResources))]
            public const string Resources = "/Resources";

            [KeyInfo(KeyType.Rectangle | KeyType.Required | KeyType.Inheritable)]
            public const string MediaBox = "/MediaBox";

            [KeyInfo(KeyType.Rectangle | KeyType.Optional | KeyType.Inheritable)]
            public const string CropBox = "/CropBox";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string Rotate = "/Rotate";
        }

        internal struct InheritedValues
        {
            public PdfDictionary Resources;
            public PdfRectangle MediaBox;
            public PdfRectangle CropBox;
            public PdfInteger Rotate;
        }
    }
    public sealed class PdfPages : PdfDictionary, IEnumerable<PdfPage>
    {
        internal PdfPages(PdfDocument document)
            : base(document)
        {
            Elements.SetName(Keys.Type, "/Pages");
            Elements[Keys.Count] = new PdfInteger(0);
        }

        internal PdfPages(PdfDictionary dictionary)
            : base(dictionary)
        { }

        public int Count
        {
            get { return PagesArray.Elements.Count; }
        }

        public PdfPage this[int index]
        {
            get
            {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException("index", index, PSSR.PageIndexOutOfRange);

                PdfDictionary dict = (PdfDictionary)((PdfReference)PagesArray.Elements[index]).Value;
                if (!(dict is PdfPage))
                    dict = new PdfPage(dict);
                return (PdfPage)dict;
            }
        }

        internal PdfPage FindPage(PdfObjectID id)
        {
            PdfPage page = null;
            foreach (PdfItem item in PagesArray)
            {
                PdfReference reference = item as PdfReference;
                if (reference != null)
                {
                    PdfDictionary dictionary = reference.Value as PdfDictionary;
                    if (dictionary != null && dictionary.ObjectID == id)
                    {
                        page = dictionary as PdfPage ?? new PdfPage(dictionary);
                        break;
                    }
                }
            }
            return page;
        }

        public PdfPage Add()
        {
            PdfPage page = new PdfPage();
            Insert(Count, page);
            return page;
        }

        public PdfPage Add(PdfPage page)
        {
            return Insert(Count, page);
        }

        public PdfPage Insert(int index)
        {
            PdfPage page = new PdfPage();
            Insert(index, page);
            return page;
        }

        public PdfPage Insert(int index, PdfPage page)
        {
            if (page == null)
                throw new ArgumentNullException("page");

            if (page.Owner == Owner)
            {
                int count = Count;
                for (int idx = 0; idx < count; idx++)
                {
                    if (ReferenceEquals(this[idx], page))
                        throw new InvalidOperationException(PSSR.MultiplePageInsert);
                }

                Owner._irefTable.Add(page);
                Debug.Assert(page.Owner == Owner);

                PagesArray.Elements.Insert(index, page.Reference);

                Elements.SetInteger(Keys.Count, PagesArray.Elements.Count);

                return page;
            }

            if (page.Owner == null)
            {
                page.Document = Owner;

                Owner._irefTable.Add(page);
                Debug.Assert(page.Owner == Owner);
                PagesArray.Elements.Insert(index, page.Reference);
                Elements.SetInteger(Keys.Count, PagesArray.Elements.Count);
            }
            else
            {
                PdfPage importPage = page;
                page = ImportExternalPage(importPage);
                Owner._irefTable.Add(page);

                PdfImportedObjectTable importedObjectTable = Owner.FormTable.GetImportedObjectTable(importPage);
                importedObjectTable.Add(importPage.ObjectID, page.Reference);

                PagesArray.Elements.Insert(index, page.Reference);
                Elements.SetInteger(Keys.Count, PagesArray.Elements.Count);
                PdfAnnotations.FixImportedAnnotation(page);
            }
            if (Owner.Settings.TrimMargins.AreSet)
                page.TrimMargins = Owner.Settings.TrimMargins;

            return page;
        }

        public void InsertRange(int index, PdfDocument document, int startIndex, int pageCount)
        {
            if (document == null)
                throw new ArgumentNullException("document");

            if (index < 0 || index > Count)
                throw new ArgumentOutOfRangeException("index", "Argument 'index' out of range.");

            int importDocumentPageCount = document.PageCount;

            if (startIndex < 0 || startIndex + pageCount > importDocumentPageCount)
                throw new ArgumentOutOfRangeException("startIndex", "Argument 'startIndex' out of range.");

            if (pageCount > importDocumentPageCount)
                throw new ArgumentOutOfRangeException("pageCount", "Argument 'pageCount' out of range.");

            PdfPage[] insertPages = new PdfPage[pageCount];
            PdfPage[] importPages = new PdfPage[pageCount];

            for (int idx = 0, insertIndex = index, importIndex = startIndex;
                importIndex < startIndex + pageCount;
                idx++, insertIndex++, importIndex++)
            {
                PdfPage importPage = document.Pages[importIndex];
                PdfPage page = ImportExternalPage(importPage);
                insertPages[idx] = page;
                importPages[idx] = importPage;

                Owner._irefTable.Add(page);

                PdfImportedObjectTable importedObjectTable = Owner.FormTable.GetImportedObjectTable(importPage);
                importedObjectTable.Add(importPage.ObjectID, page.Reference);

                PagesArray.Elements.Insert(insertIndex, page.Reference);

                if (Owner.Settings.TrimMargins.AreSet)
                    page.TrimMargins = Owner.Settings.TrimMargins;
            }
            Elements.SetInteger(Keys.Count, PagesArray.Elements.Count);

            for (int idx = 0, importIndex = startIndex;
                importIndex < startIndex + pageCount;
                idx++, importIndex++)
            {
                PdfPage importPage = document.Pages[importIndex];
                PdfPage page = insertPages[idx];

                PdfArray annots = importPage.Elements.GetArray(PdfPage.Keys.Annots);
                if (annots != null)
                {
                    PdfAnnotations annotations = new PdfAnnotations(Owner);

                    int count = annots.Elements.Count;
                    for (int idxAnnotation = 0; idxAnnotation < count; idxAnnotation++)
                    {
                        PdfDictionary annot = annots.Elements.GetDictionary(idxAnnotation);
                        if (annot != null)
                        {
                            string subtype = annot.Elements.GetString(PdfAnnotation.Keys.Subtype);
                            if (subtype == "/Link")
                            {
                                bool addAnnotation = false;
                                PdfLinkAnnotation newAnnotation = new PdfLinkAnnotation(Owner);

                                PdfName[] importAnnotationKeyNames = annot.Elements.KeyNames;
                                foreach (PdfName pdfItem in importAnnotationKeyNames)
                                {
                                    PdfItem impItem;
                                    switch (pdfItem.Value)
                                    {
                                        case "/BS":
                                            newAnnotation.Elements.Add("/BS", new PdfLiteral("<</W 0>>"));
                                            break;

                                        case "/F":
                                            impItem = annot.Elements.GetValue("/F");
                                            Debug.Assert(impItem is PdfInteger);
                                            newAnnotation.Elements.Add("/F", impItem.Clone());
                                            break;

                                        case "/Rect":
                                            impItem = annot.Elements.GetValue("/Rect");
                                            Debug.Assert(impItem is PdfArray);
                                            newAnnotation.Elements.Add("/Rect", impItem.Clone());
                                            break;

                                        case "/StructParent":
                                            impItem = annot.Elements.GetValue("/StructParent");
                                            Debug.Assert(impItem is PdfInteger);
                                            newAnnotation.Elements.Add("/StructParent", impItem.Clone());
                                            break;

                                        case "/Subtype":
                                            break;

                                        case "/Dest":
                                            impItem = annot.Elements.GetValue("/Dest");
                                            impItem = impItem.Clone();

                                            PdfArray destArray = impItem as PdfArray;
                                            if (destArray != null && destArray.Elements.Count == 5)
                                            {
                                                PdfReference iref = destArray.Elements[0] as PdfReference;
                                                if (iref != null)
                                                {
                                                    iref = RemapReference(insertPages, importPages, iref);
                                                    if (iref != null)
                                                    {
                                                        destArray.Elements[0] = iref;
                                                        newAnnotation.Elements.Add("/Dest", destArray);
                                                        addAnnotation = true;
                                                    }
                                                }
                                            }
                                            break;

                                        default:
                                            break;

                                    }
                                }
                                if (addAnnotation)
                                    annotations.Add(newAnnotation);
                            }
                        }
                    }

                    if (annotations.Count > 0)
                    {
                        page.Elements.Add(PdfPage.Keys.Annots, annotations);
                    }
                }

            }
        }

        public void InsertRange(int index, PdfDocument document)
        {
            if (document == null)
                throw new ArgumentNullException("document");

            InsertRange(index, document, 0, document.PageCount);
        }

        public void InsertRange(int index, PdfDocument document, int startIndex)
        {
            if (document == null)
                throw new ArgumentNullException("document");

            InsertRange(index, document, startIndex, document.PageCount - startIndex);
        }

        public void Remove(PdfPage page)
        {
            PagesArray.Elements.Remove(page.Reference);
            Elements.SetInteger(Keys.Count, PagesArray.Elements.Count);
        }

        public void RemoveAt(int index)
        {
            PagesArray.Elements.RemoveAt(index);
            Elements.SetInteger(Keys.Count, PagesArray.Elements.Count);
        }

        public void MovePage(int oldIndex, int newIndex)
        {
            if (oldIndex < 0 || oldIndex >= Count)
                throw new ArgumentOutOfRangeException("oldIndex");
            if (newIndex < 0 || newIndex >= Count)
                throw new ArgumentOutOfRangeException("newIndex");
            if (oldIndex == newIndex)
                return;

            PdfReference page = (PdfReference)_pagesArray.Elements[oldIndex];
            _pagesArray.Elements.RemoveAt(oldIndex);
            _pagesArray.Elements.Insert(newIndex, page);
        }

        PdfPage ImportExternalPage(PdfPage importPage)
        {
            if (importPage.Owner._openMode != PdfDocumentOpenMode.Import)
                throw new InvalidOperationException("A PDF document must be opened with PdfDocumentOpenMode.Import to import pages from it.");

            PdfPage page = new PdfPage(_document);

            CloneElement(page, importPage, PdfPage.Keys.Resources, false);
            CloneElement(page, importPage, PdfPage.Keys.Contents, false);
            CloneElement(page, importPage, PdfPage.Keys.MediaBox, true);
            CloneElement(page, importPage, PdfPage.Keys.CropBox, true);
            CloneElement(page, importPage, PdfPage.Keys.Rotate, true);
            CloneElement(page, importPage, PdfPage.Keys.BleedBox, true);
            CloneElement(page, importPage, PdfPage.Keys.TrimBox, true);
            CloneElement(page, importPage, PdfPage.Keys.ArtBox, true);
#if true
            CloneElement(page, importPage, PdfPage.Keys.Annots, false);
#endif
            return page;
        }

        void CloneElement(PdfPage page, PdfPage importPage, string key, bool deepcopy)
        {
            Debug.Assert(page != null);
            Debug.Assert(page.Owner == _document);
            Debug.Assert(importPage.Owner != null);
            Debug.Assert(importPage.Owner != _document);

            PdfItem item = importPage.Elements[key];
            if (item != null)
            {
                PdfImportedObjectTable importedObjectTable = null;
                if (!deepcopy)
                    importedObjectTable = Owner.FormTable.GetImportedObjectTable(importPage);

                if (item is PdfReference)
                    item = ((PdfReference)item).Value;
                if (item is PdfObject)
                {
                    PdfObject root = (PdfObject)item;
                    if (deepcopy)
                    {
                        Debug.Assert(root.Owner != null, "See 'else' case for details");
                        root = DeepCopyClosure(_document, root);
                    }
                    else
                    {
                        if (root.Owner == null)
                            root.Document = importPage.Owner;
                        root = ImportClosure(importedObjectTable, page.Owner, root);
                    }

                    if (root.Reference == null)
                        page.Elements[key] = root;
                    else
                        page.Elements[key] = root.Reference;
                }
                else
                {
                    page.Elements[key] = item.Clone();
                }
            }
        }

        static PdfReference RemapReference(PdfPage[] newPages, PdfPage[] impPages, PdfReference iref)
        {
            for (int idx = 0; idx < newPages.Length; idx++)
            {
                if (impPages[idx].Reference == iref)
                    return newPages[idx].Reference;
            }
            return null;
        }

        public PdfArray PagesArray
        {
            get
            {
                if (_pagesArray == null)
                    _pagesArray = (PdfArray)Elements.GetValue(Keys.Kids, VCF.Create);
                return _pagesArray;
            }
        }
        PdfArray _pagesArray;

        internal void FlattenPageTree()
        {
            PdfPage.InheritedValues values = new PdfPage.InheritedValues();
            PdfPage.InheritValues(this, ref values);
            PdfDictionary[] pages = GetKids(Reference, values, null);

            PdfArray array = new PdfArray(Owner);
            foreach (PdfDictionary page in pages)
            {
                page.Elements[PdfPage.Keys.Parent] = Reference;
                array.Elements.Add(page.Reference);
            }

            Elements.SetName(Keys.Type, "/Pages");
#if true
            Elements.SetValue(Keys.Kids, array);
#endif
            Elements.SetInteger(Keys.Count, array.Elements.Count);
        }

        PdfDictionary[] GetKids(PdfReference iref, PdfPage.InheritedValues values, PdfDictionary parent)
        {
            PdfDictionary kid = (PdfDictionary)iref.Value;

#if true
            string type = kid.Elements.GetName(Keys.Type);
            if (type == "/Page")
            {
                PdfPage.InheritValues(kid, values);
                return new PdfDictionary[] { kid };
            }

            if (string.IsNullOrEmpty(type))
            {
                PdfPage.InheritValues(kid, values);
                return new PdfDictionary[] { kid };
            }

#endif

            Debug.Assert(kid.Elements.GetName(Keys.Type) == "/Pages");
            PdfPage.InheritValues(kid, ref values);
            List<PdfDictionary> list = new List<PdfDictionary>();
            PdfArray kids = kid.Elements["/Kids"] as PdfArray;

            if (kids == null)
            {
                PdfReference xref3 = kid.Elements["/Kids"] as PdfReference;
                if (xref3 != null)
                    kids = xref3.Value as PdfArray;
            }

            foreach (PdfReference xref2 in kids)
                list.AddRange(GetKids(xref2, values, kid));
            int count = list.Count;
            Debug.Assert(count == kid.Elements.GetInteger("/Count"));
            return list.ToArray();
        }

        internal override void PrepareForSave()
        {
            int count = _pagesArray.Elements.Count;
            for (int idx = 0; idx < count; idx++)
            {
                PdfPage page = this[idx];
                page.PrepareForSave();
            }
        }

        public new IEnumerator<PdfPage> GetEnumerator()
        {
            return new PdfPagesEnumerator(this);
        }

        class PdfPagesEnumerator : IEnumerator<PdfPage>
        {
            internal PdfPagesEnumerator(PdfPages list)
            {
                _list = list;
                _index = -1;
            }

            public bool MoveNext()
            {
                if (_index < _list.Count - 1)
                {
                    _index++;
                    _currentElement = _list[_index];
                    return true;
                }
                _index = _list.Count;
                return false;
            }

            public void Reset()
            {
                _currentElement = null;
                _index = -1;
            }

            object IEnumerator.Current
            {
                get { return Current; }
            }

            public PdfPage Current
            {
                get
                {
                    if (_index == -1 || _index >= _list.Count)
                        throw new InvalidOperationException(PSSR.ListEnumCurrentOutOfRange);
                    return _currentElement;
                }
            }

            public void Dispose()
            {
            }

            PdfPage _currentElement;
            int _index;
            readonly PdfPages _list;
        }

        internal sealed class Keys : PdfPage.InheritablePageKeys
        {
            [KeyInfo(KeyType.Name | KeyType.Required, FixedValue = "Pages")]
            public const string Type = "/Type";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string Parent = "/Parent";

            [KeyInfo(KeyType.Array | KeyType.Required)]
            public const string Kids = "/Kids";

            [KeyInfo(KeyType.Integer | KeyType.Required)]
            public const string Count = "/Count";

            public static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfReal : PdfNumber
    {
        public PdfReal()
        { }

        public PdfReal(double value)
        {
            _value = value;
        }

        public double Value
        {
            get { return _value; }
        }
        readonly double _value;

        public override string ToString()
        {
            return _value.ToString(Config.SignificantFigures3, CultureInfo.InvariantCulture);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }
    }
    public sealed class PdfRealObject : PdfNumberObject
    {
        public PdfRealObject()
        { }

        public PdfRealObject(double value)
        {
            _value = value;
        }

        public PdfRealObject(PdfDocument document, double value)
            : base(document)
        {
            _value = value;
        }

        public double Value
        {
            get { return _value; }
            set { _value = value; }
        }
        double _value;

        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.Write(_value);
            writer.WriteEndObject();
        }
    }
    public sealed class PdfRectangle : PdfItem
    {
        public PdfRectangle()
        { }

        internal PdfRectangle(double x1, double y1, double x2, double y2)
        {
            _x1 = x1;
            _y1 = y1;
            _x2 = x2;
            _y2 = y2;
        }

        public PdfRectangle(XPoint pt1, XPoint pt2)
        {
            _x1 = pt1.X;
            _y1 = pt1.Y;
            _x2 = pt2.X;
            _y2 = pt2.Y;
        }

        public PdfRectangle(XPoint pt, XSize size)
        {
            _x1 = pt.X;
            _y1 = pt.Y;
            _x2 = pt.X + size.Width;
            _y2 = pt.Y + size.Height;
        }

        public PdfRectangle(XRect rect)
        {
            _x1 = rect.X;
            _y1 = rect.Y;
            _x2 = rect.X + rect.Width;
            _y2 = rect.Y + rect.Height;
        }

        internal PdfRectangle(PdfItem item)
        {
            if (item == null || item is PdfNull)
                return;

            if (item is PdfReference)
                item = ((PdfReference)item).Value;

            PdfArray array = item as PdfArray;
            if (array == null)
                throw new InvalidOperationException(PSSR.UnexpectedTokenInPdfFile);

            _x1 = array.Elements.GetReal(0);
            _y1 = array.Elements.GetReal(1);
            _x2 = array.Elements.GetReal(2);
            _y2 = array.Elements.GetReal(3);
        }

        public new PdfRectangle Clone()
        {
            return (PdfRectangle)Copy();
        }

        protected override object Copy()
        {
            PdfRectangle rect = (PdfRectangle)base.Copy();
            return rect;
        }

        public bool IsEmpty
        {
            get { return _x1 == 0 && _y1 == 0 && _x2 == 0 && _y2 == 0; }
        }

        public override bool Equals(object obj)
        {
            PdfRectangle rectangle = obj as PdfRectangle;
            if (rectangle != null)
            {
                PdfRectangle rect = rectangle;
                return rect._x1 == _x1 && rect._y1 == _y1 && rect._x2 == _x2 && rect._y2 == _y2;
            }
            return false;
        }

        public override int GetHashCode()
        {
            return (int)(((((uint)_x1) ^ ((((uint)_y1) << 13) |
              (((uint)_y1) >> 0x13))) ^ ((((uint)_x2) << 0x1a) |
              (((uint)_x2) >> 6))) ^ ((((uint)_y2) << 7) |
              (((uint)_y2) >> 0x19)));
        }

        public static bool operator ==(PdfRectangle left, PdfRectangle right)
        {
            if ((object)left != null)
            {
                if ((object)right != null)
                    return left._x1 == right._x1 && left._y1 == right._y1 && left._x2 == right._x2 && left._y2 == right._y2;
                return false;
            }
            return (object)right == null;
        }

        public static bool operator !=(PdfRectangle left, PdfRectangle right)
        {
            return !(left == right);
        }

        public double X1
        {
            get { return _x1; }
        }
        readonly double _x1;

        public double Y1
        {
            get { return _y1; }
        }
        readonly double _y1;

        public double X2
        {
            get { return _x2; }
        }
        readonly double _x2;

        public double Y2
        {
            get { return _y2; }
        }
        readonly double _y2;

        public double Width
        {
            get { return _x2 - _x1; }
        }

        public double Height
        {
            get { return _y2 - _y1; }
        }

        public XPoint Location
        {
            get { return new XPoint(_x1, _y1); }
        }

        public XSize Size
        {
            get { return new XSize(_x2 - _x1, _y2 - _y1); }
        }

        public bool Contains(XPoint pt)
        {
            return Contains(pt.X, pt.Y);
        }

        public bool Contains(double x, double y)
        {
            return _x1 <= x && x <= _x2 && _y1 <= y && y <= _y2;
        }


        public bool Contains(XRect rect)
        {
            return _x1 <= rect.X && (rect.X + rect.Width) <= _x2 &&
              _y1 <= rect.Y && (rect.Y + rect.Height) <= _y2;
        }

        public bool Contains(PdfRectangle rect)
        {
            return _x1 <= rect._x1 && rect._x2 <= _x2 &&
              _y1 <= rect._y1 && rect._y2 <= _y2;
        }

        public XRect ToXRect()
        {
            return new XRect(_x1, _y1, Width, Height);
        }

        public override string ToString()
        {
            const string format = Config.SignificantFigures3;
            return PdfEncoders.Format("[{0:" + format + "} {1:" + format + "} {2:" + format + "} {3:" + format + "}]", _x1, _y1, _x2, _y2);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }

        string DebuggerDisplay
        {
            get
            {
                const string format = Config.SignificantFigures10;
                return String.Format(CultureInfo.InvariantCulture,
                    "X1={0:" + format + "}, Y1={1:" + format + "}, X2={2:" + format + "}, Y2={3:" + format + "}", _x1, _y1, _x2, _y2);
            }
        }
        public static readonly PdfRectangle Empty = new PdfRectangle();
    }
    internal sealed class PdfReferenceTable_old
    {
        public PdfReferenceTable_old(PdfDocument document)
        {
            _document = document;
        }
        readonly PdfDocument _document;

        public Dictionary<PdfObjectID, PdfReference> ObjectTable = new Dictionary<PdfObjectID, PdfReference>();

        internal bool IsUnderConstruction
        {
            get { return _isUnderConstruction; }
            set { _isUnderConstruction = value; }
        }
        bool _isUnderConstruction;

        public void Add(PdfReference iref)
        {
            if (iref.ObjectID.IsEmpty)
                iref.ObjectID = new PdfObjectID(GetNewObjectNumber());

            if (ObjectTable.ContainsKey(iref.ObjectID))
                throw new InvalidOperationException("Object already in table.");

            ObjectTable.Add(iref.ObjectID, iref);
        }

        public void Add(PdfObject value)
        {
            if (value.Owner == null)
                value.Document = _document;
            else
                Debug.Assert(value.Owner == _document);

            if (value.ObjectID.IsEmpty)
                value.SetObjectID(GetNewObjectNumber(), 0);

            if (ObjectTable.ContainsKey(value.ObjectID))
                throw new InvalidOperationException("Object already in table.");

            ObjectTable.Add(value.ObjectID, value.Reference);
        }

        public void Remove(PdfReference iref)
        {
            ObjectTable.Remove(iref.ObjectID);
        }

        public PdfReference this[PdfObjectID objectID]
        {
            get
            {
                PdfReference iref;
                ObjectTable.TryGetValue(objectID, out iref);
                return iref;
            }
        }

        public bool Contains(PdfObjectID objectID)
        {
            return ObjectTable.ContainsKey(objectID);
        }

        public int GetNewObjectNumber()
        {
            return ++_maxObjectNumber;
        }
        internal int _maxObjectNumber;

        internal void WriteObject(PdfWriter writer)
        {
            writer.WriteRaw("xref\n");

            PdfReference[] irefs = AllReferences;

            int count = irefs.Length;
            writer.WriteRaw(String.Format("0 {0}\n", count + 1));
            writer.WriteRaw(String.Format("{0:0000000000} {1:00000} {2} \n", 0, 65535, "f"));
            for (int idx = 0; idx < count; idx++)
            {
                PdfReference iref = irefs[idx];

                writer.WriteRaw(String.Format("{0:0000000000} {1:00000} {2} \n", iref.Position, iref.GenerationNumber, "n"));
            }
        }

        internal PdfObjectID[] AllObjectIDs
        {
            get
            {
                ICollection collection = ObjectTable.Keys;
                PdfObjectID[] objectIDs = new PdfObjectID[collection.Count];
                collection.CopyTo(objectIDs, 0);
                return objectIDs;
            }
        }

        internal PdfReference[] AllReferences
        {
            get
            {
                Dictionary<PdfObjectID, PdfReference>.ValueCollection collection = ObjectTable.Values;
                List<PdfReference> list = new List<PdfReference>(collection);
                list.Sort(PdfReference.Comparer);
                PdfReference[] irefs = new PdfReference[collection.Count];
                list.CopyTo(irefs, 0);
                return irefs;
            }
        }

        internal void HandleOrphanedReferences()
        { }

        internal int Compact()
        {
            int removed = ObjectTable.Count;
            PdfReference[] irefs = TransitiveClosure(_document._trailer);



            _maxObjectNumber = 0;
            ObjectTable.Clear();
            foreach (PdfReference iref in irefs)
            {
                if (!ObjectTable.ContainsKey(iref.ObjectID))
                {
                    ObjectTable.Add(iref.ObjectID, iref);
                    _maxObjectNumber = Math.Max(_maxObjectNumber, iref.ObjectNumber);
                }
            }
            removed -= ObjectTable.Count;
            return removed;
        }

        internal void Renumber()
        {
            PdfReference[] irefs = AllReferences;
            ObjectTable.Clear();
            int count = irefs.Length;
            for (int idx = 0; idx < count; idx++)
            {
                PdfReference iref = irefs[idx];

                iref.ObjectID = new PdfObjectID(idx + 1);
                ObjectTable.Add(iref.ObjectID, iref);
            }
            _maxObjectNumber = count;
        }

        [Conditional("DEBUG_")]
        public void CheckConsistence()
        {
            Dictionary<PdfReference, object> ht1 = new Dictionary<PdfReference, object>();
            foreach (PdfReference iref in ObjectTable.Values)
            {
                Debug.Assert(!ht1.ContainsKey(iref), "Duplicate iref.");
                Debug.Assert(iref.Value != null);
                ht1.Add(iref, null);
            }

            Dictionary<PdfObjectID, object> ht2 = new Dictionary<PdfObjectID, object>();
            foreach (PdfReference iref in ObjectTable.Values)
            {
                Debug.Assert(!ht2.ContainsKey(iref.ObjectID), "Duplicate iref.");
                ht2.Add(iref.ObjectID, null);
            }

            ICollection collection = ObjectTable.Values;
            int count = collection.Count;
            PdfReference[] irefs = new PdfReference[count];
            collection.CopyTo(irefs, 0);
#if true
            for (int i = 0; i < count; i++)
                for (int j = 0; j < count; j++)
                    if (i != j)
                    {
                        Debug.Assert(ReferenceEquals(irefs[i].Document, _document));
                        Debug.Assert(irefs[i] != irefs[j]);
                        Debug.Assert(!ReferenceEquals(irefs[i], irefs[j]));
                        Debug.Assert(!ReferenceEquals(irefs[i].Value, irefs[j].Value));
                        Debug.Assert(!Equals(irefs[i].ObjectID, irefs[j].Value.ObjectID));
                        Debug.Assert(irefs[i].ObjectNumber != irefs[j].Value.ObjectNumber);
                        Debug.Assert(ReferenceEquals(irefs[i].Document, irefs[j].Document));
                        GetType();
                    }
#endif
        }

        public PdfReference[] TransitiveClosure(PdfObject pdfObject)
        {
            return TransitiveClosure(pdfObject, Int16.MaxValue);
        }

        public PdfReference[] TransitiveClosure(PdfObject pdfObject, int depth)
        {
            CheckConsistence();
            Dictionary<PdfItem, object> objects = new Dictionary<PdfItem, object>();
            _overflow = new Dictionary<PdfItem, object>();
            TransitiveClosureImplementation(objects, pdfObject);
        TryAgain:
            if (_overflow.Count > 0)
            {
                PdfObject[] array = new PdfObject[_overflow.Count];
                _overflow.Keys.CopyTo(array, 0);
                _overflow = new Dictionary<PdfItem, object>();
                for (int idx = 0; idx < array.Length; idx++)
                {
                    PdfObject obj = array[idx];
                    TransitiveClosureImplementation(objects, obj);
                }
                goto TryAgain;
            }

            CheckConsistence();

            ICollection collection = objects.Keys;
            int count = collection.Count;
            PdfReference[] irefs = new PdfReference[count];
            collection.CopyTo(irefs, 0);

            return irefs;
        }

        static int _nestingLevel;
        Dictionary<PdfItem, object> _overflow = new Dictionary<PdfItem, object>();

        void TransitiveClosureImplementation(Dictionary<PdfItem, object> objects, PdfObject pdfObject)
        {
            try
            {
                _nestingLevel++;
                if (_nestingLevel >= 1000)
                {
                    if (!_overflow.ContainsKey(pdfObject))
                        _overflow.Add(pdfObject, null);
                    return;
                }

                IEnumerable enumerable = null;
                PdfDictionary dict;
                PdfArray array;
                if ((dict = pdfObject as PdfDictionary) != null)
                    enumerable = dict.Elements.Values;
                else if ((array = pdfObject as PdfArray) != null)
                    enumerable = array.Elements;
                else
                    Debug.Assert(false, "Should not come here.");

                if (enumerable != null)
                {
                    foreach (PdfItem item in enumerable)
                    {
                        PdfReference iref = item as PdfReference;
                        if (iref != null)
                        {
                            if (!ReferenceEquals(iref.Document, _document))
                            {
                                GetType();
                                Debug.WriteLine(String.Format("Bad iref: {0}", iref.ObjectID.ToString()));
                            }
                            Debug.Assert(ReferenceEquals(iref.Document, _document) || iref.Document == null, "External object detected!");

                            if (!objects.ContainsKey(iref))
                            {
                                PdfObject value = iref.Value;

                                if (iref.Document != null)
                                {
                                    if (value == null)
                                    {
                                        iref = ObjectTable[iref.ObjectID];
                                        Debug.Assert(iref.Value != null);
                                        value = iref.Value;
                                    }
                                    Debug.Assert(ReferenceEquals(iref.Document, _document));
                                    objects.Add(iref, null);
                                    if (value is PdfArray || value is PdfDictionary)
                                        TransitiveClosureImplementation(objects, value);
                                }
                            }
                        }
                        else
                        {
                            PdfObject pdfObject28 = item as PdfObject;
                            if (pdfObject28 != null && (pdfObject28 is PdfDictionary || pdfObject28 is PdfArray))
                                TransitiveClosureImplementation(objects, pdfObject28);
                        }
                    }
                }
            }
            finally
            {
                _nestingLevel--;
            }
        }

        public PdfReference DeadObject
        {
            get
            {
                if (_deadObject == null)
                {
                    _deadObject = new PdfDictionary(_document);
                    Add(_deadObject);
                    _deadObject.Elements.Add("/DeadObjectCount", new PdfInteger());
                }
                return _deadObject.Reference;
            }
        }
        PdfDictionary _deadObject;
    }
    public enum PdfStringEncoding
    {
        RawEncoding = PdfStringFlags.RawEncoding,

        StandardEncoding = PdfStringFlags.StandardEncoding,

        PDFDocEncoding = PdfStringFlags.PDFDocEncoding,
        WinAnsiEncoding = PdfStringFlags.WinAnsiEncoding,

        MacRomanEncoding = PdfStringFlags.MacExpertEncoding,

        MacExpertEncoding = PdfStringFlags.MacExpertEncoding,

        Unicode = PdfStringFlags.Unicode,
    }

    [Flags]
    enum PdfStringFlags
    {
        RawEncoding = 0x00,
        StandardEncoding = 0x01,
        PDFDocEncoding = 0x02,
        WinAnsiEncoding = 0x03,
        MacRomanEncoding = 0x04,
        MacExpertEncoding = 0x05,
        Unicode = 0x06,
        EncodingMask = 0x0F,

        HexLiteral = 0x80,
    }

    [DebuggerDisplay("({Value})")]
    public sealed class PdfString : PdfItem
    {
        public PdfString()
        {
        }

        public PdfString(string value)
        {
#if true
            if (!IsRawEncoding(value))
                _flags = PdfStringFlags.Unicode;
            _value = value;
#endif
        }

        public PdfString(string value, PdfStringEncoding encoding)
        {
            switch (encoding)
            {
                case PdfStringEncoding.RawEncoding:
                    CheckRawEncoding(value);
                    break;

                case PdfStringEncoding.StandardEncoding:
                    break;

                case PdfStringEncoding.PDFDocEncoding:
                    break;

                case PdfStringEncoding.WinAnsiEncoding:
                    CheckRawEncoding(value);
                    break;

                case PdfStringEncoding.MacRomanEncoding:
                    break;

                case PdfStringEncoding.Unicode:
                    break;

                default:
                    throw new ArgumentOutOfRangeException("encoding");
            }
            _value = value;
            _flags = (PdfStringFlags)encoding;
        }

        internal PdfString(string value, PdfStringFlags flags)
        {
            _value = value;
            _flags = flags;
        }

        public int Length
        {
            get { return _value == null ? 0 : _value.Length; }
        }

        public PdfStringEncoding Encoding
        {
            get { return (PdfStringEncoding)(_flags & PdfStringFlags.EncodingMask); }
        }

        public bool HexLiteral
        {
            get { return (_flags & PdfStringFlags.HexLiteral) != 0; }
        }

        internal PdfStringFlags Flags
        {
            get { return _flags; }
        }
        readonly PdfStringFlags _flags;

        public string Value
        {
            get { return _value ?? ""; }
        }
        string _value;

        internal byte[] EncryptionValue
        {
            get { return _value == null ? new byte[0] : PdfEncoders.RawEncoding.GetBytes(_value); }
            set { _value = PdfEncoders.RawEncoding.GetString(value, 0, value.Length); }
        }

        public override string ToString()
        {
#if true
            PdfStringEncoding encoding = (PdfStringEncoding)(_flags & PdfStringFlags.EncodingMask);
            string pdf = (_flags & PdfStringFlags.HexLiteral) == 0 ?
                PdfEncoders.ToStringLiteral(_value, encoding, null) :
                PdfEncoders.ToHexStringLiteral(_value, encoding, null);
            return pdf;
#endif
        }

        public string ToStringFromPdfDocEncoded()
        {
            int length = _value.Length;
            char[] bytes = new char[length];
            for (int idx = 0; idx < length; idx++)
            {
                char ch = _value[idx];
                if (ch <= 255)
                {
                    bytes[idx] = Encode[ch];
                }
                else
                {
                    throw new InvalidOperationException("DocEncoded string contains char greater 255.");
                }
            }
            StringBuilder sb = new StringBuilder(length);
            for (int idx = 0; idx < length; idx++)
                sb.Append((char)bytes[idx]);
            return sb.ToString();
        }
        static readonly char[] Encode =
        {
            '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\x09', '\x0A', '\x0B', '\x0C', '\x0D', '\x0E', '\x0F',
            '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18', '\x19', '\x1A', '\x1B', '\x1C', '\x1D', '\x1E', '\x1F',
            '\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27', '\x28', '\x29', '\x2A', '\x2B', '\x2C', '\x2D', '\x2E', '\x2F',
            '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37', '\x38', '\x39', '\x3A', '\x3B', '\x3C', '\x3D', '\x3E', '\x3F',
            '\x40', '\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47', '\x48', '\x49', '\x4A', '\x4B', '\x4C', '\x4D', '\x4E', '\x4F',
            '\x50', '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57', '\x58', '\x59', '\x5A', '\x5B', '\x5C', '\x5D', '\x5E', '\x5F',
            '\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67', '\x68', '\x69', '\x6A', '\x6B', '\x6C', '\x6D', '\x6E', '\x6F',
            '\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77', '\x78', '\x79', '\x7A', '\x7B', '\x7C', '\x7D', '\x7E', '\x7F',
            '\x2022', '\x2020', '\x2021', '\x2026', '\x2014', '\x2013', '\x0192', '\x2044', '\x2039', '\x203A', '\x2212', '\x2030', '\x201E', '\x201C', '\x201D', '\x2018',
            '\x2019', '\x201A', '\x2122', '\xFB01', '\xFB02', '\x0141', '\x0152', '\x0160', '\x0178', '\x017D', '\x0131', '\x0142', '\x0153', '\x0161', '\x017E', '\xFFFD',
            '\x20AC', '\xA1', '\xA2', '\xA3', '\xA4', '\xA5', '\xA6', '\xA7', '\xA8', '\xA9', '\xAA', '\xAB', '\xAC', '\xAD', '\xAE', '\xAF',
            '\xB0', '\xB1', '\xB2', '\xB3', '\xB4', '\xB5', '\xB6', '\xB7', '\xB8', '\xB9', '\xBA', '\xBB', '\xBC', '\xBD', '\xBE', '\xBF',
            '\xC0', '\xC1', '\xC2', '\xC3', '\xC4', '\xC5', '\xC6', '\xC7', '\xC8', '\xC9', '\xCA', '\xCB', '\xCC', '\xCD', '\xCE', '\xCF',
            '\xD0', '\xD1', '\xD2', '\xD3', '\xD4', '\xD5', '\xD6', '\xD7', '\xD8', '\xD9', '\xDA', '\xDB', '\xDC', '\xDD', '\xDE', '\xDF',
            '\xE0', '\xE1', '\xE2', '\xE3', '\xE4', '\xE5', '\xE6', '\xE7', '\xE8', '\xE9', '\xEA', '\xEB', '\xEC', '\xED', '\xEE', '\xEF',
            '\xF0', '\xF1', '\xF2', '\xF3', '\xF4', '\xF5', '\xF6', '\xF7', '\xF8', '\xF9', '\xFA', '\xFB', '\xFC', '\xFD', '\xFE', '\xFF',
        };

        static void CheckRawEncoding(string s)
        {
            if (String.IsNullOrEmpty(s))
                return;

            int length = s.Length;
            for (int idx = 0; idx < length; idx++)
            {
                Debug.Assert(s[idx] < 256, "RawString contains invalid character.");
            }
        }

        static bool IsRawEncoding(string s)
        {
            if (String.IsNullOrEmpty(s))
                return true;

            int length = s.Length;
            for (int idx = 0; idx < length; idx++)
            {
                if (!(s[idx] < 256))
                    return false;
            }
            return true;
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }
    }
    public sealed class PdfStringObject : PdfObject
    {
        public PdfStringObject()
        {
            _flags = PdfStringFlags.RawEncoding;
        }

        public PdfStringObject(PdfDocument document, string value)
            : base(document)
        {
            _value = value;
            _flags = PdfStringFlags.RawEncoding;
        }

        public PdfStringObject(string value, PdfStringEncoding encoding)
        {
            _value = value;
            _flags = (PdfStringFlags)encoding;
        }

        internal PdfStringObject(string value, PdfStringFlags flags)
        {
            _value = value;
            _flags = flags;
        }

        public int Length
        {
            get { return _value == null ? 0 : _value.Length; }
        }

        public PdfStringEncoding Encoding
        {
            get { return (PdfStringEncoding)(_flags & PdfStringFlags.EncodingMask); }
            set { _flags = (_flags & ~PdfStringFlags.EncodingMask) | ((PdfStringFlags)value & PdfStringFlags.EncodingMask); }
        }

        public bool HexLiteral
        {
            get { return (_flags & PdfStringFlags.HexLiteral) != 0; }
            set { _flags = value ? _flags | PdfStringFlags.HexLiteral : _flags & ~PdfStringFlags.HexLiteral; }
        }
        PdfStringFlags _flags;

        public string Value
        {
            get { return _value ?? ""; }
            set { _value = value ?? ""; }
        }
        string _value;

        internal byte[] EncryptionValue
        {
            get { return _value == null ? new byte[0] : PdfEncoders.RawEncoding.GetBytes(_value); }
            set { _value = PdfEncoders.RawEncoding.GetString(value, 0, value.Length); }
        }

        public override string ToString()
        {
            return _value;
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.Write(new PdfString(_value, _flags));
            writer.WriteEndObject();
        }
    }
    public sealed class PdfUInteger : PdfNumber, IConvertible
    {
        public PdfUInteger()
        { }

        public PdfUInteger(uint value)
        {
            _value = value;
        }

        public uint Value
        {
            get { return _value; }
        }
        readonly uint _value;

        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.Write(this);
        }

        public ulong ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64(_value);
        }

        public sbyte ToSByte(IFormatProvider provider)
        {
            throw new InvalidCastException();
        }

        public double ToDouble(IFormatProvider provider)
        {
            return _value;
        }

        public DateTime ToDateTime(IFormatProvider provider)
        {
            return new DateTime();
        }

        public float ToSingle(IFormatProvider provider)
        {
            return _value;
        }

        public bool ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean(_value);
        }

        public int ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32(_value);
        }

        public ushort ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16(_value);
        }

        public short ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16(_value);
        }

        string IConvertible.ToString(IFormatProvider provider)
        {
            return _value.ToString(provider);
        }

        public byte ToByte(IFormatProvider provider)
        {
            return Convert.ToByte(_value);
        }

        public char ToChar(IFormatProvider provider)
        {
            return Convert.ToChar(_value);
        }

        public long ToInt64(IFormatProvider provider)
        {
            return _value;
        }

        public TypeCode GetTypeCode()
        {
            return TypeCode.Int32;
        }

        public decimal ToDecimal(IFormatProvider provider)
        {
            return _value;
        }

        public object ToType(Type conversionType, IFormatProvider provider)
        {
            return null;
        }

        public uint ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32(_value);
        }

    }
    public sealed class PdfUIntegerObject : PdfNumberObject
    {
        public PdfUIntegerObject()
        { }

        public PdfUIntegerObject(uint value)
        {
            _value = value;
        }

        public PdfUIntegerObject(PdfDocument document, uint value)
            : base(document)
        {
            _value = value;
        }

        public uint Value
        {
            get { return _value; }
        }
        readonly uint _value;

        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        internal override void WriteObject(PdfWriter writer)
        {
            writer.WriteBeginObject(this);
            writer.Write(_value);
            writer.WriteEndObject();
        }
    }
    public sealed class PdfViewerPreferences : PdfDictionary
    {
        internal PdfViewerPreferences(PdfDocument document)
            : base(document)
        { }

        PdfViewerPreferences(PdfDictionary dict)
            : base(dict)
        { }

        public bool HideToolbar
        {
            get { return Elements.GetBoolean(Keys.HideToolbar); }
            set { Elements.SetBoolean(Keys.HideToolbar, value); }
        }

        public bool HideMenubar
        {
            get { return Elements.GetBoolean(Keys.HideMenubar); }
            set { Elements.SetBoolean(Keys.HideMenubar, value); }
        }

        public bool HideWindowUI
        {
            get { return Elements.GetBoolean(Keys.HideWindowUI); }
            set { Elements.SetBoolean(Keys.HideWindowUI, value); }
        }

        public bool FitWindow
        {
            get { return Elements.GetBoolean(Keys.FitWindow); }
            set { Elements.SetBoolean(Keys.FitWindow, value); }
        }

        public bool CenterWindow
        {
            get { return Elements.GetBoolean(Keys.CenterWindow); }
            set { Elements.SetBoolean(Keys.CenterWindow, value); }
        }

        public bool DisplayDocTitle
        {
            get { return Elements.GetBoolean(Keys.DisplayDocTitle); }
            set { Elements.SetBoolean(Keys.DisplayDocTitle, value); }
        }

        public PdfReadingDirection? Direction
        {
            get
            {
                switch (Elements.GetName(Keys.Direction))
                {
                    case "L2R":
                        return PdfReadingDirection.LeftToRight;

                    case "R2L":
                        return PdfReadingDirection.RightToLeft;
                }
                return null;
            }
            set
            {
                if (value.HasValue)
                {
                    switch (value.Value)
                    {
                        case PdfReadingDirection.RightToLeft:
                            Elements.SetName(Keys.Direction, "R2L");
                            break;

                        default:
                            Elements.SetName(Keys.Direction, "L2R");
                            break;
                    }
                }
                else
                    Elements.Remove(Keys.Direction);
            }
        }

        internal sealed class Keys : KeysBase
        {
            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string HideToolbar = "/HideToolbar";

            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string HideMenubar = "/HideMenubar";

            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string HideWindowUI = "/HideWindowUI";

            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string FitWindow = "/FitWindow";

            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string CenterWindow = "/CenterWindow";

            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string DisplayDocTitle = "/DisplayDocTitle";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string NonFullScreenPageMode = "/NonFullScreenPageMode";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string Direction = "/Direction";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string ViewArea = "/ViewArea";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string ViewClip = "/ViewClip";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string PrintArea = "/PrintArea";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string PrintClip = "/PrintClip";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string PrintScaling = "/PrintScaling";

            public static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class TrimMargins
    {
        public XUnit All
        {
            set
            {
                _left = value;
                _right = value;
                _top = value;
                _bottom = value;
            }
        }

        public XUnit Left
        {
            get { return _left; }
            set { _left = value; }
        }
        XUnit _left;

        public XUnit Right
        {
            get { return _right; }
            set { _right = value; }
        }
        XUnit _right;

        public XUnit Top
        {
            get { return _top; }
            set { _top = value; }
        }
        XUnit _top;

        public XUnit Bottom
        {
            get { return _bottom; }
            set { _bottom = value; }
        }
        XUnit _bottom;

        public bool AreSet
        {
            get { return _left.Value != 0 || _right.Value != 0 || _top.Value != 0 || _bottom.Value != 0; }
        }
    }
    public enum PdfAcroFieldFlags
    {
        ReadOnly = 1 << (1 - 1),

        Required = 1 << (2 - 1),

        NoExport = 1 << (3 - 1),

        Pushbutton = 1 << (17 - 1),

        Radio = 1 << (16 - 1),

        NoToggleToOff = 1 << (15 - 1),

        Multiline = 1 << (13 - 1),

        Password = 1 << (14 - 1),

        FileSelect = 1 << (21 - 1),

        DoNotSpellCheckTextField = 1 << (23 - 1),

        DoNotScroll = 1 << (24 - 1),

        Combo = 1 << (18 - 1),

        Edit = 1 << (19 - 1),

        Sort = 1 << (20 - 1),

        MultiSelect = 1 << (22 - 1),

        DoNotSpellCheckChoiseField = 1 << (23 - 1),
    }
    public abstract class PdfAcroField : PdfDictionary
    {
        internal PdfAcroField(PdfDocument document)
            : base(document)
        { }

        protected PdfAcroField(PdfDictionary dict)
            : base(dict)
        { }

        public string Name
        {
            get
            {
                string name = Elements.GetString(Keys.T);
                return name;
            }
        }

        public PdfAcroFieldFlags Flags
        {
            get { return (PdfAcroFieldFlags)Elements.GetInteger(Keys.Ff); }
        }

        internal PdfAcroFieldFlags SetFlags
        {
            get { return (PdfAcroFieldFlags)Elements.GetInteger(Keys.Ff); }
            set { Elements.SetInteger(Keys.Ff, (int)value); }
        }

        public virtual PdfItem Value
        {
            get { return Elements[Keys.V]; }
            set
            {
                if (ReadOnly)
                    throw new InvalidOperationException("The field is read only.");
                if (value is PdfString || value is PdfName)
                    Elements[Keys.V] = value;
                else
                    throw new NotImplementedException("Values other than string cannot be set.");
            }
        }

        public bool ReadOnly
        {
            get { return (Flags & PdfAcroFieldFlags.ReadOnly) != 0; }
            set
            {
                if (value)
                    SetFlags |= PdfAcroFieldFlags.ReadOnly;
                else
                    SetFlags &= ~PdfAcroFieldFlags.ReadOnly;
            }
        }

        public PdfAcroField this[string name]
        {
            get { return GetValue(name); }
        }

        protected virtual PdfAcroField GetValue(string name)
        {
            if (String.IsNullOrEmpty(name))
                return this;
            if (HasKids)
                return Fields.GetValue(name);
            return null;
        }

        public bool HasKids
        {
            get
            {
                PdfItem item = Elements[Keys.Kids];
                if (item == null)
                    return false;
                if (item is PdfArray)
                    return ((PdfArray)item).Elements.Count > 0;
                return false;
            }
        }

        [Obsolete("Use GetDescendantNames")]
        public string[] DescendantNames
        {
            get { return GetDescendantNames(); }
        }

        public string[] GetDescendantNames()
        {
            List<string> names = new List<string>();
            if (HasKids)
            {
                PdfAcroFieldCollection fields = Fields;
                fields.GetDescendantNames(ref names, null);
            }
            List<string> temp = new List<string>();
            foreach (string name in names)
                temp.Add(name);
            return temp.ToArray();
        }

        public string[] GetAppearanceNames()
        {
            Dictionary<string, object> names = new Dictionary<string, object>();
            PdfDictionary dict = Elements["/AP"] as PdfDictionary;
            if (dict != null)
            {
                AppDict(dict, names);

                if (HasKids)
                {
                    PdfItem[] kids = Fields.Elements.Items;
                    foreach (PdfItem pdfItem in kids)
                    {
                        if (pdfItem is PdfReference)
                        {
                            PdfDictionary xxx = ((PdfReference)pdfItem).Value as PdfDictionary;
                            if (xxx != null)
                                AppDict(xxx, names);
                        }
                    }
                }
            }
            string[] array = new string[names.Count];
            names.Keys.CopyTo(array, 0);
            return array;
        }

        static void AppDict(PdfDictionary dict, Dictionary<string, object> names)
        {
            PdfDictionary sub;
            if ((sub = dict.Elements["/D"] as PdfDictionary) != null)
                AppDict2(sub, names);
            if ((sub = dict.Elements["/N"] as PdfDictionary) != null)
                AppDict2(sub, names);
        }

        static void AppDict2(PdfDictionary dict, Dictionary<string, object> names)
        {
            foreach (string key in dict.Elements.Keys)
            {
                if (!names.ContainsKey(key))
                    names.Add(key, null);
            }
        }

        internal virtual void GetDescendantNames(ref List<string> names, string partialName)
        {
            if (HasKids)
            {
                PdfAcroFieldCollection fields = Fields;
                string t = Elements.GetString(Keys.T);
                Debug.Assert(t != "");
                if (t.Length > 0)
                {
                    if (!String.IsNullOrEmpty(partialName))
                        partialName += "." + t;
                    else
                        partialName = t;
                    fields.GetDescendantNames(ref names, partialName);
                }
            }
            else
            {
                string t = Elements.GetString(Keys.T);
                Debug.Assert(t != "");
                if (t.Length > 0)
                {
                    if (!String.IsNullOrEmpty(partialName))
                        names.Add(partialName + "." + t);
                    else
                        names.Add(t);
                }
            }
        }

        public PdfAcroFieldCollection Fields
        {
            get
            {
                if (_fields == null)
                {
                    object o = Elements.GetValue(Keys.Kids, VCF.CreateIndirect);
                    _fields = (PdfAcroFieldCollection)o;
                }
                return _fields;
            }
        }
        PdfAcroFieldCollection _fields;

        public sealed class PdfAcroFieldCollection : PdfArray
        {
            PdfAcroFieldCollection(PdfArray array)
                : base(array)
            { }

            public int Count
            {
                get
                {
                    return Elements.Count;
                }
            }

            public string[] Names
            {
                get
                {
                    int count = Elements.Count;
                    string[] names = new string[count];
                    for (int idx = 0; idx < count; idx++)
                        names[idx] = ((PdfDictionary)((PdfReference)Elements[idx]).Value).Elements.GetString(Keys.T);
                    return names;
                }
            }

            public string[] DescendantNames
            {
                get
                {
                    List<string> names = new List<string>();
                    GetDescendantNames(ref names, null);
                    return names.ToArray();
                }
            }

            internal void GetDescendantNames(ref List<string> names, string partialName)
            {
                int count = Elements.Count;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfAcroField field = this[idx];
                    if (field != null)
                        field.GetDescendantNames(ref names, partialName);
                }
            }

            public PdfAcroField this[int index]
            {
                get
                {
                    PdfItem item = Elements[index];
                    Debug.Assert(item is PdfReference);
                    PdfDictionary dict = ((PdfReference)item).Value as PdfDictionary;
                    Debug.Assert(dict != null);
                    PdfAcroField field = dict as PdfAcroField;
                    if (field == null && dict != null)
                    {
                        field = CreateAcroField(dict);
                    }
                    return field;
                }
            }

            public PdfAcroField this[string name]
            {
                get { return GetValue(name); }
            }

            internal PdfAcroField GetValue(string name)
            {
                if (String.IsNullOrEmpty(name))
                    return null;

                int dot = name.IndexOf('.');
                string prefix = dot == -1 ? name : name.Substring(0, dot);
                string suffix = dot == -1 ? "" : name.Substring(dot + 1);

                int count = Elements.Count;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfAcroField field = this[idx];
                    if (field.Name == prefix)
                        return field.GetValue(suffix);
                }
                return null;
            }

            PdfAcroField CreateAcroField(PdfDictionary dict)
            {
                string ft = dict.Elements.GetName(Keys.FT);
                PdfAcroFieldFlags flags = (PdfAcroFieldFlags)dict.Elements.GetInteger(Keys.Ff);
                switch (ft)
                {
                    case "/Btn":
                        if ((flags & PdfAcroFieldFlags.Pushbutton) != 0)
                            return new PdfPushButtonField(dict);

                        if ((flags & PdfAcroFieldFlags.Radio) != 0)
                            return new PdfRadioButtonField(dict);

                        return new PdfCheckBoxField(dict);

                    case "/Tx":
                        return new PdfTextField(dict);

                    case "/Ch":
                        if ((flags & PdfAcroFieldFlags.Combo) != 0)
                            return new PdfComboBoxField(dict);
                        else
                            return new PdfListBoxField(dict);

                    case "/Sig":
                        return new PdfSignatureField(dict);

                    default:
                        return new PdfGenericField(dict);
                }
            }
        }

        public class Keys : KeysBase
        {
            [KeyInfo(KeyType.Name | KeyType.Required)]
            public const string FT = "/FT";

            [KeyInfo(KeyType.Dictionary)]
            public const string Parent = "/Parent";

            [KeyInfo(KeyType.Array | KeyType.Optional, typeof(PdfAcroFieldCollection))]
            public const string Kids = "/Kids";

            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string T = "/T";

            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string TU = "/TU";

            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string TM = "/TM";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string Ff = "/Ff";

            [KeyInfo(KeyType.Various | KeyType.Optional)]
            public const string V = "/V";

            [KeyInfo(KeyType.Various | KeyType.Optional)]
            public const string DV = "/DV";

            [KeyInfo(KeyType.Dictionary | KeyType.Optional)]
            public const string AA = "/AA";

            [KeyInfo(KeyType.Dictionary | KeyType.Required)]
            public const string DR = "/DR";

            [KeyInfo(KeyType.String | KeyType.Required)]
            public const string DA = "/DA";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string Q = "/Q";

        }
    }
    public sealed class PdfAcroForm : PdfDictionary
    {
        internal PdfAcroForm(PdfDocument document)
            : base(document)
        {
            _document = document;
        }

        internal PdfAcroForm(PdfDictionary dictionary)
            : base(dictionary)
        { }

        public PdfAcroField.PdfAcroFieldCollection Fields
        {
            get
            {
                if (_fields == null)
                {
                    object o = Elements.GetValue(Keys.Fields, VCF.CreateIndirect);
                    _fields = (PdfAcroField.PdfAcroFieldCollection)o;
                }
                return _fields;
            }
        }
        PdfAcroField.PdfAcroFieldCollection _fields;

        public sealed class Keys : KeysBase
        {
            [KeyInfo(KeyType.Array | KeyType.Required, typeof(PdfAcroField.PdfAcroFieldCollection))]
            public const string Fields = "/Fields";

            [KeyInfo(KeyType.Boolean | KeyType.Optional)]
            public const string NeedAppearances = "/NeedAppearances";

            [KeyInfo("1.3", KeyType.Integer | KeyType.Optional)]
            public const string SigFlags = "/SigFlags";

            [KeyInfo(KeyType.Array)]
            public const string CO = "/CO";

            [KeyInfo(KeyType.Dictionary | KeyType.Optional)]
            public const string DR = "/DR";

            [KeyInfo(KeyType.String | KeyType.Optional)]
            public const string DA = "/DA";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string Q = "/Q";

            internal static DictionaryMeta Meta
            {
                get
                {
                    if (s_meta == null)
                        s_meta = CreateMeta(typeof(Keys));
                    return s_meta;
                }
            }
            static DictionaryMeta s_meta;

        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public abstract class PdfButtonField : PdfAcroField
    {
        protected PdfButtonField(PdfDocument document)
            : base(document)
        { }

        protected PdfButtonField(PdfDictionary dict)
            : base(dict)
        { }

        protected string GetNonOffValue()
        {
            PdfDictionary ap = Elements[PdfAnnotation.Keys.AP] as PdfDictionary;
            if (ap != null)
            {
                PdfDictionary n = ap.Elements["/N"] as PdfDictionary;
                if (n != null)
                {
                    foreach (string name in n.Elements.Keys)
                        if (name != "/Off")
                            return name;
                }
            }
            return null;
        }

        internal override void GetDescendantNames(ref List<string> names, string partialName)
        {
            string t = Elements.GetString(PdfAcroField.Keys.T);
            if (t == "")
                t = "???";
            Debug.Assert(t != "");
            if (t.Length > 0)
            {
                if (!String.IsNullOrEmpty(partialName))
                    names.Add(partialName + "." + t);
                else
                    names.Add(t);
            }
        }

        public new class Keys : PdfAcroField.Keys
        {
        }
    }
    public sealed class PdfCheckBoxField : PdfButtonField
    {
        internal PdfCheckBoxField(PdfDocument document)
            : base(document)
        {
            _document = document;
        }

        internal PdfCheckBoxField(PdfDictionary dict)
            : base(dict)
        { }

        public string CheckedName
        {
            get { return _checkedName; }
            set { _checkedName = value; }
        }
        string _checkedName = "/Yes";

        public string UncheckedName
        {
            get { return _uncheckedName; }
            set { _uncheckedName = value; }
        }
        string _uncheckedName = "/Off";

        public new class Keys : PdfButtonField.Keys
        {
            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string Opt = "/Opt";

            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public abstract class PdfChoiceField : PdfAcroField
    {
        protected PdfChoiceField(PdfDocument document)
            : base(document)
        { }

        protected PdfChoiceField(PdfDictionary dict)
            : base(dict)
        { }

        protected int IndexInOptArray(string value)
        {
            PdfArray opt = Elements.GetArray(Keys.Opt);

            if (opt != null)
            {
                int count = opt.Elements.Count;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfItem item = opt.Elements[idx];
                    if (item is PdfString)
                    {
                        if (item.ToString() == value)
                            return idx;
                    }
                    else if (item is PdfArray)
                    {
                        PdfArray array = (PdfArray)item;
                        if (array.Elements.Count != 0)
                        {
                            if (array.Elements[0].ToString() == value)
                                return idx;
                        }
                    }
                }
            }
            return -1;
        }

        protected string ValueInOptArray(int index)
        {
            PdfArray opt = Elements.GetArray(Keys.Opt);
            if (opt != null)
            {
                int count = opt.Elements.Count;
                if (index < 0 || index >= count)
                    throw new ArgumentOutOfRangeException("index");

                PdfItem item = opt.Elements[index];
                if (item is PdfString)
                    return item.ToString();

                if (item is PdfArray)
                {
                    PdfArray array = (PdfArray)item;
                    if (array.Elements.Count != 0)
                        return array.Elements[0].ToString();
                }
            }
            return "";
        }

        public new class Keys : PdfAcroField.Keys
        {
            [KeyInfo(KeyType.Array | KeyType.Optional)]
            public const string Opt = "/Opt";

            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string TI = "/TI";

            [KeyInfo(KeyType.Array | KeyType.Optional)]
            public const string I = "/I";

            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;

        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfComboBoxField : PdfChoiceField
    {
        internal PdfComboBoxField(PdfDocument document)
            : base(document)
        { }

        internal PdfComboBoxField(PdfDictionary dict)
            : base(dict)
        { }

        public int SelectedIndex
        {
            get
            {
                string value = Elements.GetString(Keys.V);
                return IndexInOptArray(value);
            }
            set
            {
                if (value != -1)
                {
                    string key = ValueInOptArray(value);
                    Elements.SetString(Keys.V, key);
                    Elements.SetInteger("/I", value);
                }
            }
        }

        public override PdfItem Value
        {
            get { return Elements[Keys.V]; }
            set
            {
                if (ReadOnly)
                    throw new InvalidOperationException("The field is read only.");
                if (value is PdfString || value is PdfName)
                {
                    Elements[Keys.V] = value;
                    SelectedIndex = SelectedIndex;
                    if (SelectedIndex == -1)
                    {
                        try
                        {
                            ((PdfArray)(((PdfItem[])(Elements.Values))[2])).Elements.Add(Value);
                            SelectedIndex = SelectedIndex;
                        }
                        catch { }
                    }
                }
                else
                    throw new NotImplementedException("Values other than string cannot be set.");
            }
        }

        public new class Keys : PdfAcroField.Keys
        {
            internal static DictionaryMeta Meta
            {
                get
                {
                    if (Keys._meta == null)
                        Keys._meta = CreateMeta(typeof(Keys));
                    return Keys._meta;
                }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfGenericField : PdfAcroField
    {
        internal PdfGenericField(PdfDocument document)
            : base(document)
        { }

        internal PdfGenericField(PdfDictionary dict)
            : base(dict)
        { }

        public new class Keys : PdfAcroField.Keys
        {
            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfListBoxField : PdfChoiceField
    {
        internal PdfListBoxField(PdfDocument document)
            : base(document)
        { }

        internal PdfListBoxField(PdfDictionary dict)
            : base(dict)
        { }

        public int SelectedIndex
        {
            get
            {
                string value = Elements.GetString(Keys.V);
                return IndexInOptArray(value);
            }
            set
            {
                string key = ValueInOptArray(value);
                Elements.SetString(Keys.V, key);
            }
        }

        public new class Keys : PdfAcroField.Keys
        {
            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfPushButtonField : PdfButtonField
    {
        internal PdfPushButtonField(PdfDocument document)
            : base(document)
        {
            _document = document;
        }

        internal PdfPushButtonField(PdfDictionary dict)
            : base(dict)
        { }

        public new class Keys : PdfAcroField.Keys
        {
            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfRadioButtonField : PdfButtonField
    {
        internal PdfRadioButtonField(PdfDocument document)
            : base(document)
        {
            _document = document;
        }

        internal PdfRadioButtonField(PdfDictionary dict)
            : base(dict)
        { }

        public int SelectedIndex
        {
            get
            {
                string value = Elements.GetString(Keys.V);
                return IndexInOptStrings(value);
            }
            set
            {
                PdfArray opt = Elements[Keys.Opt] as PdfArray;

                if (opt == null)
                    opt = Elements[Keys.Kids] as PdfArray;

                if (opt != null)
                {
                    int count = opt.Elements.Count;
                    if (value < 0 || value >= count)
                        throw new ArgumentOutOfRangeException("value");
                    Elements.SetName(Keys.V, opt.Elements[value].ToString());
                }
            }
        }

        int IndexInOptStrings(string value)
        {
            PdfArray opt = Elements[Keys.Opt] as PdfArray;
            if (opt != null)
            {
                int count = opt.Elements.Count;
                for (int idx = 0; idx < count; idx++)
                {
                    PdfItem item = opt.Elements[idx];
                    if (item is PdfString)
                    {
                        if (item.ToString() == value)
                            return idx;
                    }
                }
            }
            return -1;
        }

        public new class Keys : PdfButtonField.Keys
        {
            [KeyInfo(KeyType.Array | KeyType.Optional)]
            public const string Opt = "/Opt";

            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfSignatureField : PdfAcroField
    {
        internal PdfSignatureField(PdfDocument document)
            : base(document)
        { }

        internal PdfSignatureField(PdfDictionary dict)
            : base(dict)
        { }

        public new class Keys : PdfAcroField.Keys
        {
            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string Type = "/Type";

            [KeyInfo(KeyType.Name | KeyType.Required)]
            public const string Filter = "/Filter";

            [KeyInfo(KeyType.Name | KeyType.Optional)]
            public const string SubFilter = "/SubFilter";

            [KeyInfo(KeyType.Array | KeyType.Required)]
            public const string ByteRange = "/ByteRange";

            [KeyInfo(KeyType.String | KeyType.Required)]
            public const string Contents = "/Contents";

            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string Name = "/Name";

            [KeyInfo(KeyType.Date | KeyType.Optional)]
            public const string M = "/M";

            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string Location = "/Location";

            [KeyInfo(KeyType.TextString | KeyType.Optional)]
            public const string Reason = "/Reason";

            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }
    public sealed class PdfTextField : PdfAcroField
    {
        internal PdfTextField(PdfDocument document)
            : base(document)
        { }

        internal PdfTextField(PdfDictionary dict)
            : base(dict)
        { }

        public string Text
        {
            get { return Elements.GetString(Keys.V); }
            set { Elements.SetString(Keys.V, value); RenderAppearance(); }
        }

        public XFont Font
        {
            get { return _font; }
            set { _font = value; }
        }
        XFont _font = new XFont("Courier New", 10);

        public XColor ForeColor
        {
            get { return _foreColor; }
            set { _foreColor = value; }
        }
        XColor _foreColor = XColors.Black;

        public XColor BackColor
        {
            get { return _backColor; }
            set { _backColor = value; }
        }
        XColor _backColor = XColor.Empty;

        public int MaxLength
        {
            get { return Elements.GetInteger(Keys.MaxLen); }
            set { Elements.SetInteger(Keys.MaxLen, value); }
        }

        public bool MultiLine
        {
            get { return (Flags & PdfAcroFieldFlags.Multiline) != 0; }
            set
            {
                if (value)
                    SetFlags |= PdfAcroFieldFlags.Multiline;
                else
                    SetFlags &= ~PdfAcroFieldFlags.Multiline;
            }
        }

        public bool Password
        {
            get { return (Flags & PdfAcroFieldFlags.Password) != 0; }
            set
            {
                if (value)
                    SetFlags |= PdfAcroFieldFlags.Password;
                else
                    SetFlags &= ~PdfAcroFieldFlags.Password;
            }
        }

        void RenderAppearance()
        {
#if true_       
#else
            PdfRectangle rect = Elements.GetRectangle(PdfAnnotation.Keys.Rect);
            XForm form = new XForm(_document, rect.Size);
            XGraphics gfx = XGraphics.FromForm(form);

            if (_backColor != XColor.Empty)
                gfx.DrawRectangle(new XSolidBrush(BackColor), rect.ToXRect() - rect.Location);

            string text = Text;
            if (text.Length > 0)
                gfx.DrawString(Text, Font, new XSolidBrush(ForeColor),
                  rect.ToXRect() - rect.Location + new XPoint(2, 0), XStringFormats.TopLeft);

            form.DrawingFinished();
            form.PdfForm.Elements.Add("/FormType", new PdfLiteral("1"));

            PdfDictionary ap = Elements[PdfAnnotation.Keys.AP] as PdfDictionary;
            if (ap == null)
            {
                ap = new PdfDictionary(_document);
                Elements[PdfAnnotation.Keys.AP] = ap;
            }

            ap.Elements["/N"] = form.PdfForm.Reference;

            PdfFormXObject xobj = form.PdfForm;
            string s = xobj.Stream.ToString();
            s = "/Tx BMC\n" + s + "\nEMC";
            xobj.Stream.Value = new RawEncoding().GetBytes(s);
#endif
        }

        internal override void PrepareForSave()
        {
            base.PrepareForSave();
            RenderAppearance();
        }

        public new class Keys : PdfAcroField.Keys
        {
            [KeyInfo(KeyType.Integer | KeyType.Optional)]
            public const string MaxLen = "/MaxLen";

            internal static DictionaryMeta Meta
            {
                get { return _meta ?? (_meta = CreateMeta(typeof(Keys))); }
            }
            static DictionaryMeta _meta;
        }

        internal override DictionaryMeta Meta
        {
            get { return Keys.Meta; }
        }
    }


































}
